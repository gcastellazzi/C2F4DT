{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"C2F4DT \u2014 Developer Guide","text":"<p> Welcome to the C2F4DT developer documentation. This site collects guidelines, code architecture, theory, and an auto-generated API reference.  </p> <p>C2F4DT is a modular software package designed as a 3D viewer and interaction environment built on VTK. Its primary goal is to provide a framework where plugins can be developed to visualize and interact with point clouds and finite element models. Within this architecture, Cloud2FEM is included as one of the plugins, enabling users to transform point cloud data into finite element meshes.</p> <p>The concept behind C2F4DT is to serve as a host for digital twins of finite element models that can be initialized or continuously updated using point cloud data or IoT (Internet of Things) streams. This first release focuses on the core viewer capabilities, establishing a foundation for visualization, interaction, and plugin integration.</p> <p>Future versions will extend the package with additional plugins and extensions, enhancing functionality and enabling more advanced workflows for digital twin management and structural analysis.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Import and preprocess 3D point clouds from multiple formats</li> <li>Slice point clouds into meaningful cross-sections</li> <li>Generate centroids and polygons to represent structural elements</li> <li>Create grids and finite element meshes for structural analysis</li> <li>Define boundary conditions (BCs) and load cases</li> <li>Visualize point clouds, meshes, and simulation results within the tool</li> </ul>"},{"location":"#publications","title":"Publications","text":"<p>Cloud2FEMi and its underlying methodologies have been described and validated in several key publications:</p> <ul> <li>Cloud2FEM: A finite element mesh generator based on point clouds of existing/historical structures. Castellazzi, G., et al. (2022). SoftwareX.</li> <li>An innovative numerical modeling strategy for the structural analysis of historical monumental buildings. Castellazzi, G., et al. (2017). Engineering Structures.</li> <li>From Laser Scanning to Finite Element Analysis of Complex Buildings by Using a Semi-Automatic Procedure. Castellazzi, G., et al. (2015). Sensors.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To begin exploring C2F4DT, we recommend reviewing the following sections:</p> <ul> <li>Overview </li> <li>Installation </li> <li>Console Guide </li> <li>Architecture </li> <li>Flowchart </li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<p>To get started with the Cloud2FEM for Digital Twins framework, follow these steps:</p> <ul> <li> <p>Step 1: Create a virtual environment to isolate dependencies <pre><code>python -m venv .venv_c2f4dt\n</code></pre></p> </li> <li> <p>Step 2: Activate the virtual environment (On Windows, use: .venv_c2f4dt\\Scripts\\activate) <pre><code>source .venv_c2f4dt/bin/activate  \n</code></pre></p> </li> <li> <p>Step 3: Install the required dependencies from the requirements file <pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Step 4: Install the current package in editable mode for development purposes <pre><code>pip install -e .\n</code></pre></p> </li> <li> <p>Step 5: Run the main script to start the application <pre><code>python main.py\n</code></pre></p> </li> </ul> <p></p>"},{"location":"api/","title":"API Index","text":"<p>Auto-generated index of API modules.</p> <ul> <li>c2f4dt</li> <li>c2f4dt.app</li> <li>c2f4dt.main_window</li> <li>c2f4dt.plugins</li> <li>c2f4dt.plugins.example_display_button</li> <li>c2f4dt.plugins.example_display_button.plugin</li> <li>c2f4dt.plugins.manager</li> <li>c2f4dt.plugins.transform_rt</li> <li>c2f4dt.plugins.transform_rt.plugin</li> <li>c2f4dt.plugins.units</li> <li>c2f4dt.plugins.units.plugin</li> <li>c2f4dt.plugins.vtk_import</li> <li>c2f4dt.plugins.vtk_import.plugin</li> <li>c2f4dt.ui</li> <li>c2f4dt.ui.console</li> <li>c2f4dt.ui.display_panel</li> <li>c2f4dt.ui.import_summary_dialog</li> <li>c2f4dt.ui.viewer3d</li> <li>c2f4dt.utils</li> <li>c2f4dt.utils.icons</li> <li>c2f4dt.utils.io</li> <li>c2f4dt.utils.io.importers</li> <li>c2f4dt.utils.systeminfo</li> <li>c2f4dt.utils.theme</li> </ul>"},{"location":"api/c2f4dt/","title":"c2f4dt","text":""},{"location":"api/c2f4dt/#c2f4dt","title":"<code>c2f4dt</code>","text":"<p>C2F4DT core package.</p>"},{"location":"api/c2f4dt/app/","title":"c2f4dt.app","text":""},{"location":"api/c2f4dt/app/#c2f4dt.app","title":"<code>c2f4dt.app</code>","text":""},{"location":"api/c2f4dt/app/#c2f4dt.app.main","title":"<code>main()</code>","text":"<p>Application entry-point.</p> <p>Initializes the Qt application, shows the splash as early as possible, enforces a minimum splash duration, then shows the main window.</p> Source code in <code>src/c2f4dt/app.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Application entry-point.\n\n    Initializes the Qt application, shows the splash as early as possible,\n    enforces a minimum splash duration, then shows the main window.\n    \"\"\"\n    app = QtWidgets.QApplication(sys.argv)\n\n    # --- Splash screen (show ASAP) --------------------------------------\n    splash = None\n    splash_timer = None\n    # Minimum splash duration (ms). Override with env C2F4DT_SPLASH_MIN_MS\n    min_ms_default = 3200\n    try:\n        MIN_SPLASH_MS = int(os.environ.get(\"C2F4DT_SPLASH_MIN_MS\", str(min_ms_default)))\n    except Exception:\n        MIN_SPLASH_MS = min_ms_default\n\n    try:\n        icons_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), \"c2f4dt/assets/icons\")\n        splash_path = os.path.join(icons_dir, \"C2F4DT_512x512.png\")\n        if os.path.exists(splash_path):\n            pixmap = QtGui.QPixmap(splash_path)\n            if not pixmap.isNull():\n                splash = QtWidgets.QSplashScreen(pixmap)\n                splash.setWindowFlag(QtCore.Qt.WindowStaysOnTopHint, True)\n                splash.show()\n                splash.showMessage(\n                    \"Loading C2F4DT...\",\n                    QtCore.Qt.AlignBottom | QtCore.Qt.AlignHCenter,\n                    QtCore.Qt.black,\n                )\n                app.processEvents()  # ensure splash paints immediately\n\n                # Start elapsed timer to enforce minimum on-screen time\n                splash_timer = QtCore.QElapsedTimer()\n                splash_timer.start()\n    except Exception:\n        splash = None\n        splash_timer = None\n\n    # -------------------------------------------------------------------\n    app.setApplicationName(\"C2F4DT\")\n    app.setOrganizationName(\"C2F4DT\")\n    app.setApplicationVersion(\"1.0\")\n\n    # Set app icon (Cmd+Tab on macOS, Alt+Tab on Windows)\n    try:\n        icon_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), \"c2f4dt/assets/icons\", \"C2F4DT.icns\")\n        if os.path.isfile(icon_path):\n            app.setWindowIcon(QtGui.QIcon(icon_path))\n    except Exception:\n        pass\n\n    # High-DPI friendly defaults\n    if hasattr(QtCore.Qt, \"AA_UseHighDpiPixmaps\"):\n        QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)\n\n    # Build and show the main window\n    win = MainWindow()\n    win.show()\n\n    # --- Finish splash with minimum duration ----------------------------\n    if splash is not None:\n        try:\n            elapsed = splash_timer.elapsed() if splash_timer is not None else MIN_SPLASH_MS\n            remaining = max(0, MIN_SPLASH_MS - int(elapsed))\n            if remaining == 0:\n                splash.finish(win)\n            else:\n                QtCore.QTimer.singleShot(remaining, lambda: splash.finish(win))\n        except Exception:\n            # Best-effort fallback\n            try:\n                splash.finish(win)\n            except Exception:\n                pass\n\n    # Enter event loop\n    sys.exit(app.exec())\n</code></pre>"},{"location":"api/c2f4dt/main_window/","title":"c2f4dt.main_window","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window","title":"<code>c2f4dt.main_window</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow","title":"<code>MainWindow</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>Main GUI window for C2F4DT.</p> <p>This class manages the main application window, including the menu, toolbars, status bar, central widgets, plugin management, and the 3D/2D viewers. It also handles the import and visualization of point clouds and meshes, as well as user interactions with the dataset tree.</p> Source code in <code>src/c2f4dt/main_window.py</code> <pre><code>class MainWindow(QtWidgets.QMainWindow):\n    \"\"\"\n    Main GUI window for C2F4DT.\n\n    This class manages the main application window, including the menu, toolbars, status bar,\n    central widgets, plugin management, and the 3D/2D viewers. It also handles the import and\n    visualization of point clouds and meshes, as well as user interactions with the dataset tree.\n    \"\"\"\n\n    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -&gt; None:\n        super().__init__(parent)\n        self.setWindowTitle(\"C2F4DT \u2013 Release 1.0\")\n        apply_user_theme(self)\n        self._apply_styles()\n\n        self._compute_initial_geometry()\n\n        self.mcts = {}\n        self.mct = {}\n\n        self.undo_stack = QtGui.QUndoStack(self)\n        self._build_actions()\n        self._build_menus()\n        self._build_toolbars()\n        self._build_central_area()\n        self._build_statusbar()\n\n        self.plugin_manager = PluginManager(self, plugins_dir=self._default_plugins_dir())\n\n        self._cloud2fem = Cloud2FEMPlugin(self)\n\n        self._populate_plugins_ui()\n\n        self._start_disk_timer()\n\n        # Debouncer to rebuild the 3D scene once after bursts of changes\n        self._rebuild_timer = QtCore.QTimer(self)\n        self._rebuild_timer.setSingleShot(True)\n        self._rebuild_timer.timeout.connect(self._reset_viewer3d_from_tree)\n\n        self.undo_stack.cleanChanged.connect(self._on_undo_changed)\n        self.undo_stack.indexChanged.connect(self._on_undo_changed)\n        self._on_undo_changed()\n\n        # Preferences\n        self.downsample_method = \"random\"  # or \"voxel\"\n        self._session_path: Optional[str] = None\n\n        # Tree update guard to avoid cascading on auto-updates/partial states\n        # Explicitly ensure the flag exists and starts false\n        self._tree_updating = False\n\n        self._mount_cloud2fem_panel()\n\n    def _iter_children(self, item: QtWidgets.QTreeWidgetItem):\n        \"\"\"Yield direct children of *item* safely.\"\"\"\n        for i in range(item.childCount()):\n            yield item.child(i)\n\n    def _set_item_checked(self, item: QtWidgets.QTreeWidgetItem, on: bool) -&gt; None:\n        \"\"\"Set the checkbox state of *item* without recursive signal storms.\"\"\"\n        try:\n            self._tree_updating = True\n            item.setCheckState(0, QtCore.Qt.CheckState.Checked if on else QtCore.Qt.CheckState.Unchecked)\n        finally:\n            self._tree_updating = False\n\n    @QtCore.Slot(QtWidgets.QTreeWidgetItem, int)\n    # def _on_tree_item_changed(self, item: QtWidgets.QTreeWidgetItem, column: int) -&gt; None:\n    #     \"\"\"\n    #     Handle checkbox toggles in treeMCTS.\n\n    #     Behavior:\n    #     - If 'Tree \u279c Parent check toggles children' is ON, propagate the state to children.\n    #     - Toggle dataset visibility for nodes that carry {'kind': 'points'|'mesh'|'normals', 'ds': int}.\n    #     - Ensure actors are (re)created when turning visibility ON.\n    #     - Keep self.mcts and viewer._datasets['visible'] in sync.\n    #     \"\"\"\n    #     # Guard against programmatic changes\n    #     if getattr(self, \"_tree_updating\", False):\n    #         return\n    #     try:\n    #         role = QtCore.Qt.ItemDataRole.UserRole\n    #         data = item.data(0, role)\n    #         checked = item.checkState(0) == QtCore.Qt.CheckState.Checked\n    #         propagate = False\n    #         try:\n    #             propagate = bool(self.act_tree_propagate.isChecked())\n    #         except Exception:\n    #             propagate = False\n\n    #         # 1) Propagate to children if requested\n    #         if propagate:\n    #             try:\n    #                 self._tree_updating = True\n    #                 for ch in self._iter_children(item):\n    #                     ch.setCheckState(0, QtCore.Qt.CheckState.Checked if checked else QtCore.Qt.CheckState.Unchecked)\n    #             finally:\n    #                 self._tree_updating = False\n\n    #         # 2) If this node maps to a dataset, toggle visibility accordingly\n    #         if isinstance(data, dict):\n    #             kind = data.get(\"kind\")\n    #             ds = data.get(\"ds\")\n    #             if isinstance(ds, int) and kind in (\"points\", \"mesh\", \"normals\"):\n    #                 if kind in (\"points\", \"mesh\"):\n    #                     # Main dataset visibility\n    #                     self._viewer_set_visibility(kind, ds, bool(checked))\n    #                     # Persist visible flag into cache + session dicts\n    #                     try:\n    #                         self._persist_dataset_prop(ds, \"visible\", bool(checked))\n    #                     except Exception:\n    #                         pass\n    #                     # If we just turned OFF points, force normals OFF for that ds\n    #                     if kind == \"points\" and not checked:\n    #                         try:\n    #                             self._viewer_set_visibility(\"normals\", ds, False)\n    #                         except Exception:\n    #                             pass\n    #                 elif kind == \"normals\":\n    #                     # Normals visibility only if dataset exists\n    #                     try:\n    #                         getattr(self.viewer3d, \"set_normals_visibility\", lambda *_: None)(ds, bool(checked))\n    #                     except Exception:\n    #                         pass\n    #                     try:\n    #                         self._persist_dataset_prop(ds, \"normals_visible\", bool(checked))\n    #                     except Exception:\n    #                         pass\n\n    #         # 3) If a parent WITHOUT explicit kind was toggled, and propagate=False,\n    #         #    try to reflect the parent checkbox on immediate children that have ds/kind.\n    #         if (not propagate) and (not isinstance(data, dict)):\n    #             for ch in self._iter_children(item):\n    #                 dch = ch.data(0, role)\n    #                 if isinstance(dch, dict):\n    #                     kind = dch.get(\"kind\")\n    #                     ds = dch.get(\"ds\")\n    #                     if isinstance(ds, int) and kind in (\"points\", \"mesh\", \"normals\"):\n    #                         # Do not change checkbox UI; only re-sync visibility with current child state\n    #                         on = ch.checkState(0) == QtCore.Qt.CheckState.Checked\n    #                         if kind in (\"points\", \"mesh\"):\n    #                             self._viewer_set_visibility(kind, ds, bool(on))\n    #                         elif kind == \"normals\":\n    #                             try:\n    #                                 getattr(self.viewer3d, \"set_normals_visibility\", lambda *_: None)(ds, bool(on))\n    #                             except Exception:\n    #                                 pass\n    #                         try:\n    #                             if kind == \"normals\":\n    #                                 self._persist_dataset_prop(ds, \"normals_visible\", bool(on))\n    #                             else:\n    #                                 self._persist_dataset_prop(ds, \"visible\", bool(on))\n    #                         except Exception:\n    #                             pass\n\n    #         # 4) Best-effort overlays refresh and viewer refresh\n    #         try:\n    #             self._reapply_overlays_safe()\n    #         except Exception:\n    #             pass\n    #         try:\n    #             self.viewer3d.refresh()\n    #         except Exception:\n    #             pass\n    #     except Exception:\n    #         # Avoid breaking the UI due to unexpected data\n    #         pass\n\n    #     # 3D view preferences (dataclass-like dict, for settings dialog)\n    #     self._view_prefs = {\n    #         \"bg\": (82, 87, 110),\n    #         \"grid\": True,\n    #         \"points_as_spheres\": False,\n    #         \"colorbar_mode\": \"vertical-tr\",\n    #         \"colorbar_title\": \"\",\n    #     }\n\n    def _schedule_scene_rebuild(self, delay_ms: int = 60) -&gt; None:\n        \"\"\"Schedule a single full-scene rebuild after a short delay (debounced).\"\"\"\n        try:\n            self._rebuild_timer.start(int(max(1, delay_ms)))\n        except Exception:\n            # Fallback: rebuild immediately\n            self._reset_viewer3d_from_tree()\n\n    def _apply_styles(self) -&gt; None:\n            \"\"\"\n            Apply custom CSS styles to the main window widgets for a consistent look and feel.\n            \"\"\"\n            css = r'''\n                    QPushButton#buttonCANCEL {\n                        background-color: #c62828;\n                        color: white;\n                        border: 1px solid #8e0000;\n                        padding: 2px 8px;\n                        border-radius: 3px;\n                    }\n                    QPushButton#buttonCANCEL:disabled {\n                        background-color: #ef9a9a;\n                        color: #333;\n                        border-color: #e57373;\n                    }\n\n                    QProgressBar#barPROGRESS {\n                        border: 1px solid #3c3f41;\n                        border-radius: 3px;\n                        text-align: center;\n                        background: #2b2b2b;\n                        color: #e6e6e6;\n                    }\n                    QProgressBar#barPROGRESS::chunk {\n                        background-color: #43a047;\n                    }\n\n                    QProgressBar#diskUsageBar {\n                        border: 1px solid #3c3f41;\n                        border-radius: 3px;\n                        background: #2b2b2b;\n                        text-align: center;\n                        color: #e6e6e6;\n                    }\n                    QProgressBar#diskUsageBar::chunk {\n                        background-color: #5dade2;\n                    }\n                    '''\n            self.setStyleSheet(css)\n\n    def _compute_initial_geometry(self) -&gt; None:\n        scr = QtGui.QGuiApplication.screenAt(QtGui.QCursor.pos())\n        if scr is None:\n            scr = QtGui.QGuiApplication.primaryScreen()\n        avail = scr.availableGeometry()\n        w = int(avail.width() * 0.78)\n        h = int(avail.height() * 0.78)\n        x = avail.x() + (avail.width() - w) // 2\n        y = avail.y() + (avail.height() - h) // 2\n        self.setGeometry(x, y, w, h)\n\n    def _default_plugins_dir(self) -&gt; str:\n        base = os.path.dirname(os.path.dirname(__file__))  # .../C2F4DT/c2f4dt\n        return os.path.join(base, \"c2f4dt/plugins\")\n\n    def _build_actions(self) -&gt; None:\n        self.act_new = QtGui.QAction(qicon(\"32x32_document-new.png\"), \"New\", self)\n        self.act_new.setShortcut(QtGui.QKeySequence.New)\n        self.act_open = QtGui.QAction(qicon(\"32x32_document-open.png\"), \"Open\u2026\", self)\n        self.act_open.setShortcut(QtGui.QKeySequence.Open)\n        self.act_save = QtGui.QAction(qicon(\"32x32_document-save.png\"), \"Save\", self)\n        self.act_save.setShortcut(QtGui.QKeySequence.Save)\n        self.act_save_as = QtGui.QAction(qicon(\"32x32_document-save-as.png\"), \"Save As\u2026\", self)\n        self.act_save_as.setShortcut(QtGui.QKeySequence.SaveAs)\n        self.act_new.triggered.connect(self._on_new_session)\n        self.act_open.triggered.connect(self._on_open_session)\n        self.act_save.triggered.connect(self._on_save_session)\n        self.act_save_as.triggered.connect(self._on_save_session_as)\n        self.act_import_cloud = QtGui.QAction(qicon(\"32x32_import_cloud.png\"), \"Import Cloud\", self)\n        self.act_import_cloud.triggered.connect(self._on_import_cloud)\n\n        self.act_undo = self.undo_stack.createUndoAction(self, \"Undo\"); self.act_undo.setIcon(qicon(\"32x32_edit-undo.png\"))\n        self.act_undo.setShortcut(QtGui.QKeySequence.Undo)\n        self.act_redo = self.undo_stack.createRedoAction(self, \"Redo\"); self.act_redo.setIcon(qicon(\"32x32_edit-redo.png\"))\n        self.act_redo.setShortcut(QtGui.QKeySequence.Redo)\n        self.act_clear = QtGui.QAction(qicon(\"32x32_edit-clear.png\"), \"Clear\", self)\n\n        self.act_tab_interaction = QtGui.QAction(qicon(\"32x32_3D_inspector.png\"), \"Interaction\", self)\n        self.act_tab_slices = QtGui.QAction(qicon(\"32x32_slice.png\"), \"Slices\", self)\n        self.act_tab_fem = QtGui.QAction(qicon(\"32x32_mesh_generation.png\"), \"FEM/Mesh\", self)\n        self.act_tab_inspector = QtGui.QAction(qicon(\"32x32_model_info.png\"), \"Inspector\", self)\n        self.act_open_2d = QtGui.QAction(qicon(\"32x32_2D_window.png\"), \"Open 2D Viewer\", self)\n\n        self.act_create_grid = QtGui.QAction(qicon(\"32x32_grid_generation.png\"), \"Create Grid\", self)\n        self.act_toggle_grid = QtGui.QAction(qicon(\"32x32_3D_grid.png\"), \"Toggle Grid\", self); self.act_toggle_grid.setCheckable(True)\n        self.act_toggle_normals = QtGui.QAction(qicon(\"32x32_normals.png\"), \"Toggle Normals\", self); self.act_toggle_normals.setCheckable(True)\n\n        self.act_fit = QtGui.QAction(qicon(\"32x32_view-fullscreen.png\"), \"Fit view\", self)\n        self.act_xp = QtGui.QAction(qicon(\"32x32_view_Xp.png\"), \"View +X\", self)\n        self.act_xm = QtGui.QAction(qicon(\"32x32_view_Xm.png\"), \"View \u2212X\", self)\n        self.act_yp = QtGui.QAction(qicon(\"32x32_view_Yp.png\"), \"View +Y\", self)\n        self.act_ym = QtGui.QAction(qicon(\"32x32_view_Ym.png\"), \"View \u2212Y\", self)\n        self.act_zp = QtGui.QAction(qicon(\"32x32_view_Zp.png\"), \"View +Z\", self)\n        self.act_zm = QtGui.QAction(qicon(\"32x32_view_Zm.png\"), \"View \u2212Z\", self)\n        self.act_iso_p = QtGui.QAction(qicon(\"32x32_view_Isometric_p.png\"), \"Isometric +\", self)\n        self.act_iso_m = QtGui.QAction(qicon(\"32x32_view_Isometric_m.png\"), \"Isometric \u2212\", self)\n        self.act_invert = QtGui.QAction(qicon(\"32x32_view_inverted.png\"), \"Invert view\", self)\n        self.act_refresh = QtGui.QAction(qicon(\"32x32_view-refresh.png\"), \"Refresh\", self)\n\n    def _build_menus(self) -&gt; None:\n        menubar = self.menuBar()\n        m_file = menubar.addMenu(\"&amp;File\")\n        for a in [self.act_new, self.act_open, self.act_save, self.act_save_as, self.act_import_cloud]: m_file.addAction(a)\n        m_edit = menubar.addMenu(\"&amp;Edit\")\n        for a in [self.act_undo, self.act_redo, self.act_clear]: m_edit.addAction(a)\n        m_view = menubar.addMenu(\"&amp;View\")\n        for a in [self.act_tab_interaction, self.act_tab_slices, self.act_tab_fem, self.act_tab_inspector, self.act_open_2d]: m_view.addAction(a)\n        # Add a separator and a new action for 3D View Settings dialog\n        self.act_view_settings = QtGui.QAction(\"3D View Settings\u2026\", self)\n        self.act_view_settings.setIcon(qicon(\"32x32_settings.png\")) if qicon else None\n        self.act_view_settings.triggered.connect(self._on_open_view_settings)\n        m_view.addSeparator()\n        m_view.addAction(self.act_view_settings)\n        m_tools = menubar.addMenu(\"&amp;Tools\")\n        for a in [self.act_create_grid, self.act_toggle_grid, self.act_toggle_normals]:\n            m_tools.addAction(a)\n\n        # --- Tree behaviour submenu -----------------------------------\n        m_tree = m_tools.addMenu(\"Tree\")\n        self.act_tree_propagate = QtGui.QAction(\"Parent check toggles children\", self)\n        self.act_tree_propagate.setCheckable(True)\n        self.act_tree_propagate.setChecked(False)  # default: come ora (propaga ai figli)\n        m_tree.addAction(self.act_tree_propagate)\n\n\n        # Activate Plugins menu\n        self.m_plugins = menubar.addMenu(\"&amp;Plugins\")\n        self.m_plugins.setToolTipsVisible(True)\n        self.m_plugins_about_to_show = False\n\n\n        # Rendering submenu\n        self.act_safe_render = QtGui.QAction(\"Safe Rendering (macOS)\", self)\n        self.act_safe_render.setCheckable(True)\n        self.act_safe_render.toggled.connect(lambda on: getattr(self.viewer3d, \"enable_safe_rendering\", lambda *_: None)(on))\n\n        self.act_points_as_spheres = QtGui.QAction(\"Points as spheres\", self)\n        self.act_points_as_spheres.setCheckable(True)\n        self.act_points_as_spheres.setChecked(True)\n        self.act_points_as_spheres.toggled.connect(lambda on: getattr(self.viewer3d, \"set_points_as_spheres\", lambda *_: None)(on))\n\n        m_render = m_tools.addMenu(\"Rendering\")\n        m_render.addAction(self.act_safe_render)\n        m_render.addAction(self.act_points_as_spheres)\n\n        # Downsampling submenu (import-time behavior)\n        m_ds = m_tools.addMenu(\"Downsampling\")\n        group_ds = QtGui.QActionGroup(self)\n        group_ds.setExclusive(True)\n        self.act_ds_random = QtGui.QAction(\"Random (accurate %)\", self, checkable=True)\n        self.act_ds_voxel = QtGui.QAction(\"Voxel (spatial)\", self, checkable=True)\n        self.act_ds_random.setChecked(True)\n        for a in (self.act_ds_random, self.act_ds_voxel):\n            group_ds.addAction(a)\n            m_ds.addAction(a)\n        self.act_ds_random.triggered.connect(lambda: setattr(self, \"downsample_method\", \"random\"))\n        self.act_ds_voxel.triggered.connect(lambda: setattr(self, \"downsample_method\", \"voxel\"))\n\n        # Testing submenu: run external Python scripts in the console context\n        m_test = m_tools.addMenu(\"Testing\")\n        self.act_run_script = QtGui.QAction(\"Run Script\u2026\", self)\n        self.act_run_script.triggered.connect(self._on_run_script)\n        m_test.addAction(self.act_run_script)\n\n        # Example convenience action (optional) to run project triplet tests\n        self.act_run_triplet = QtGui.QAction(\"Run Triplet Import (tests/*.ply)\", self)\n        self.act_run_triplet.triggered.connect(self._on_run_tests_triplet)\n        m_test.addAction(self.act_run_triplet)\n\n        menubar.addMenu(\"&amp;Help\")\n\n    def _build_toolbars(self) -&gt; None:\n        self.top_toolbar = QtWidgets.QToolBar(\"barTOPCOMMAND\", self)\n        self.top_toolbar.setIconSize(QtCore.QSize(32, 32))\n        self.addToolBar(QtCore.Qt.TopToolBarArea, self.top_toolbar)\n\n        for a in [self.act_new, self.act_open, self.act_save, self.act_save_as, self.act_import_cloud]:\n            self.top_toolbar.addAction(a)\n        self.top_toolbar.addSeparator()\n        for a in [self.act_undo, self.act_redo, self.act_clear]:\n            self.top_toolbar.addAction(a)\n        self.top_toolbar.addSeparator()\n        for a in [self.act_tab_interaction, self.act_tab_slices, self.act_tab_fem, self.act_tab_inspector, self.act_open_2d]:\n            self.top_toolbar.addAction(a)\n        self.top_toolbar.addSeparator()\n        for a in [self.act_create_grid,  self.act_toggle_normals]:\n            self.top_toolbar.addAction(a)\n\n        self.left_toolbar = QtWidgets.QToolBar(\"barVERTICALCOMMAND_left\", self)\n        self.left_toolbar.setIconSize(QtCore.QSize(32, 32))\n        self.left_toolbar.setOrientation(QtCore.Qt.Vertical)\n        self.addToolBar(QtCore.Qt.LeftToolBarArea, self.left_toolbar)\n        # for a in [self.act_fit, self.act_refresh, self.act_xp, self.act_xm, self.act_yp, self.act_ym, self.act_zp, self.act_zm, self.act_iso_p, self.act_iso_m, self.act_invert, self.act_toggle_grid,]:\n        #     self.left_toolbar.addAction(a)\n        for a in [self.act_fit, self.act_refresh, self.act_xp, self.act_yp, self.act_zp,  self.act_iso_p, self.act_iso_m, self.act_invert, self.act_toggle_grid,]:\n            self.left_toolbar.addAction(a)\n\n        self.right_toolbar = QtWidgets.QToolBar(\"barVERTICALCOMMAND_right\", self)\n        self.right_toolbar.setIconSize(QtCore.QSize(32, 32))\n        self.right_toolbar.setOrientation(QtCore.Qt.Vertical)\n        self.addToolBar(QtCore.Qt.RightToolBarArea, self.right_toolbar)\n\n        # Connect view actions\n        self.act_fit.triggered.connect(lambda: self.viewer3d.view_fit())\n        self.act_xp.triggered.connect(lambda: self.viewer3d.view_axis(\"+X\"))\n        self.act_xm.triggered.connect(lambda: self.viewer3d.view_axis(\"-X\"))\n        self.act_yp.triggered.connect(lambda: self.viewer3d.view_axis(\"+Y\"))\n        self.act_ym.triggered.connect(lambda: self.viewer3d.view_axis(\"-Y\"))\n        self.act_zp.triggered.connect(lambda: self.viewer3d.view_axis(\"+Z\"))\n        self.act_zm.triggered.connect(lambda: self.viewer3d.view_axis(\"-Z\"))\n        self.act_iso_p.triggered.connect(lambda: self.viewer3d.view_iso(True))\n        self.act_iso_m.triggered.connect(lambda: self.viewer3d.view_iso(False))\n        self.act_invert.triggered.connect(lambda: self.viewer3d.invert_view())\n        self.act_refresh.triggered.connect(lambda: self.viewer3d.refresh())\n        #\n        self.act_toggle_normals.toggled.connect(self._on_toggle_normals_clicked)\n\n        self.act_toggle_grid.toggled.connect(\n            lambda on: (\n                getattr(self.viewer3d, \"set_grid_enabled\",\n                        getattr(self.viewer3d, \"set_grid_visible\",\n                                getattr(self.viewer3d, \"toggle_grid\", lambda *_: None)))(on),\n                getattr(self.viewer3d, \"reapply_overlays\",\n                        getattr(self.viewer3d, \"_apply_overlays\", lambda: None))()\n            )\n        )\n\n    def _mount_cloud2fem_panel(self):\n        \"\"\"Mount Cloud2FEM panel into right toolbar.\"\"\"\n        try:\n            hooks = HostHooks(\n                window=self,\n                viewer3d=self.viewer3d,\n                log=lambda lvl, msg: self.txtMessages.appendPlainText(f\"[{lvl}] {msg}\"),\n                progress_begin=lambda title: self._progress_start(title),\n                progress_update=lambda p, m: self._import_progress_update(percent=p, message=m),\n                progress_end=lambda: self._progress_finish(),\n                add_badge=lambda name, txt: self.statusBar().showMessage(f\"{name}: {txt}\", 2000),\n            )\n            self._cloud2fem.mount(hooks)\n        except Exception:\n            pass\n\n\n\n    def _build_central_area(self) -&gt; None:\n        central = QtWidgets.QWidget(self)\n        central_layout = QtWidgets.QVBoxLayout(central)\n        central_layout.setContentsMargins(4, 4, 4, 4); central_layout.setSpacing(6)\n\n        mid_split = QtWidgets.QSplitter(QtCore.Qt.Horizontal, central)\n\n        self.tabINTERACTION = QtWidgets.QTabWidget(mid_split)\n        self.tabINTERACTION.setObjectName(\"tabINTERACTION\")\n        self.tabINTERACTION.setMinimumWidth(334)  # Set minimum width to 320 for better alignment with scrollDISPLAY\n\n        self.tabDISPLAY = QtWidgets.QWidget()\n        v = QtWidgets.QVBoxLayout(self.tabDISPLAY); v.setContentsMargins(4, 4, 4, 4)\n        split = QtWidgets.QSplitter(QtCore.Qt.Vertical, self.tabDISPLAY)\n\n        self.treeMCTS = QtWidgets.QTreeWidget()\n        self.treeMCTS.setHeaderLabels([\"Object\"]); self.treeMCTS.setColumnCount(1)\n        self.treeMCTS.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)\n        self.treeMCTS.customContextMenuRequested.connect(self._on_tree_context_menu)\n        self.treeMCTS.itemSelectionChanged.connect(self._on_tree_selection_changed)\n        split.addWidget(self.treeMCTS)\n\n\n        self.scrollDISPLAY = QtWidgets.QScrollArea(); self.scrollDISPLAY.setWidgetResizable(True)\n        self.displayPanel = DisplayPanel(); self.scrollDISPLAY.setWidget(self.displayPanel)\n        # --- Wire normals UI from DisplayPanel ---\n        dp = self.displayPanel\n        dp.sigNormalsStyleChanged.connect(self._on_normals_style_changed)\n        dp.sigNormalsColorChanged.connect(self._on_normals_color_changed)\n        dp.sigNormalsPercentChanged.connect(self._on_normals_percent_changed)\n        dp.sigNormalsScaleChanged.connect(self._on_normals_scale_changed)\n        dp.sigComputeNormals.connect(self._on_compute_normals)       # gi\u00e0 esistente, riusa il tuo handler\n        dp.sigFastNormalsChanged.connect(self._on_fast_normals_toggled)  # opzionale: salva preferenza FAST\n        split.addWidget(self.scrollDISPLAY)\n\n        v.addWidget(split)\n        self.tabINTERACTION.addTab(self.tabDISPLAY, \"DISPLAY\")\n\n        self.tabSLICING = QtWidgets.QWidget()\n        v2 = QtWidgets.QVBoxLayout(self.tabSLICING)\n        self.scrollSLICING = QtWidgets.QScrollArea(); self.scrollSLICING.setWidgetResizable(True)\n        v2.addWidget(self.scrollSLICING)\n        self.tabINTERACTION.addTab(self.tabSLICING, \"SLICING\")\n\n        self.tabFEM = QtWidgets.QWidget()\n        v3 = QtWidgets.QVBoxLayout(self.tabFEM)\n        self.scrollFEM = QtWidgets.QScrollArea(); self.scrollFEM.setWidgetResizable(True)\n        v3.addWidget(self.scrollFEM)\n        self.tabINTERACTION.addTab(self.tabFEM, \"FEM\")\n\n        self.tabINSPECTOR = QtWidgets.QWidget()\n        v4 = QtWidgets.QVBoxLayout(self.tabINSPECTOR)\n\n        # Top bar with a Refresh button for the Inspector\n        bar_ins = QtWidgets.QHBoxLayout()\n        bar_ins.addStretch(1)\n        self.btnRefreshInspector = QtWidgets.QPushButton(\"Refresh\")\n        self.btnRefreshInspector.setObjectName(\"btnRefreshInspector\")\n        bar_ins.addWidget(self.btnRefreshInspector)\n        v4.addLayout(bar_ins)\n\n        # Tree that shows the current MCT content\n        self.treeMCT = QtWidgets.QTreeWidget()\n        self.treeMCT.setObjectName(\"treeMCT\")\n        self.treeMCT.setHeaderLabels([\"Key\", \"Value\"])\n        self.treeMCT.setColumnCount(2)\n        self.treeMCT.header().setStretchLastSection(True)\n        v4.addWidget(self.treeMCT, 1)\n\n        # Hook up refresh\n        self.btnRefreshInspector.clicked.connect(self._refresh_inspector_tree)\n\n        self.tabINTERACTION.addTab(self.tabINSPECTOR, \"INSPECTOR\")\n\n        viewer_container = QtWidgets.QWidget()\n        viewer_layout = QtWidgets.QVBoxLayout(viewer_container)\n        viewer_layout.setContentsMargins(4, 4, 4, 4); viewer_layout.setSpacing(4)\n\n        bar_plugin = QtWidgets.QHBoxLayout()\n        self.comboPlugins = QtWidgets.QComboBox()\n        self.comboPlugins.addItem(\"\u2014 No plugins installed \u2014\"); self.comboPlugins.setEnabled(False)\n        bar_plugin.addWidget(QtWidgets.QLabel(\"Plugin scope:\"))\n        bar_plugin.addWidget(self.comboPlugins, 1)\n        self.comboPlugins.activated.connect(self._on_plugin_combo_activated)\n\n        viewer_layout.addLayout(bar_plugin)\n\n        self.viewer3d = _Viewer3D()\n        viewer_layout.addWidget(self.viewer3d, 1)\n        # React to check/uncheck from the MCTS tree (avoid duplicates)\n        self.treeMCTS.itemChanged.connect(\n            self._on_tree_item_changed,\n            QtCore.Qt.ConnectionType.UniqueConnection\n        )\n        # Ora che viewer3d esiste, aggiorna la visibilit\u00e0\n        self._refresh_tree_visibility()\n\n        mid_split.addWidget(self.tabINTERACTION)\n        mid_split.addWidget(viewer_container)\n        mid_split.setStretchFactor(0, 0); mid_split.setStretchFactor(1, 1)\n\n        # central_layout.addWidget(mid_split, 1)   # REMOVE this line, replaced by splitter below\n\n        self.tabCONSOLE_AND_MESSAGES = QtWidgets.QTabWidget()\n        self.tabMESSAGES = QtWidgets.QWidget()\n        vm = QtWidgets.QVBoxLayout(self.tabMESSAGES)\n        self.txtMessages = QtWidgets.QPlainTextEdit(); self.txtMessages.setReadOnly(True)\n        vm.addWidget(self.txtMessages)\n        self.tabCONSOLE_AND_MESSAGES.addTab(self.tabMESSAGES, \"Messages\")\n\n        self.console = ConsoleWidget(context_provider=self._console_context)\n        self.console.sigExecuted.connect(self._on_console_executed)\n        self.tabCONSOLE_AND_MESSAGES.addTab(self.console, \"Console\")\n\n        # central_layout.addWidget(self.tabCONSOLE_AND_MESSAGES, 0)   # REMOVE this line, replaced by splitter below\n\n        # --- Make the upper (interaction+viewer) and lower (messages/console) panes vertically resizable ---\n        main_split = QtWidgets.QSplitter(QtCore.Qt.Vertical, central)\n        main_split.setObjectName(\"splitMAIN_VERTICAL\")\n        main_split.setChildrenCollapsible(False)\n        # put the big middle UI (tabs + viewer) on top, and the messages/console tabs below\n        main_split.addWidget(mid_split)\n        main_split.addWidget(self.tabCONSOLE_AND_MESSAGES)\n        # sizing hints: top takes most of the space, bottom a fixed minimum height\n        self.tabCONSOLE_AND_MESSAGES.setMinimumHeight(140)  # tweak if you want a different minimum\n        main_split.setStretchFactor(0, 1)\n        main_split.setStretchFactor(1, 0)\n        try:\n            # give an initial 80/20 split (best-effort; works after first show)\n            main_split.setSizes([self.height() * 4 // 5, self.height() * 1 // 5])\n        except Exception:\n            pass\n\n        # Add the vertical splitter to the central layout (instead of adding the two widgets separately)\n        central_layout.addWidget(main_split, 1)\n\n        self.setCentralWidget(central)\n\n        # Collega il DisplayPanel agli handler specifici.\n        # Wire the DisplayPanel to specific handlers.\n        self.displayPanel.sigPointSizeChanged.connect(self._on_point_size_changed)\n        self.displayPanel.sigPointBudgetChanged.connect(self._on_point_budget_changed)\n        self.displayPanel.sigColorModeChanged.connect(self._on_color_mode_changed)\n        self.displayPanel.sigSolidColorChanged.connect(self._on_solid_color_changed)\n        self.displayPanel.sigColormapChanged.connect(self._on_colormap_changed)\n        self.displayPanel.sigMeshRepresentationChanged.connect(self._on_mesh_rep_changed)\n        self.displayPanel.sigMeshOpacityChanged.connect(self._on_mesh_opacity_changed)\n        # --- Normals visualization ---\n        self.displayPanel.sigNormalsStyleChanged.connect(self._on_normals_style_changed)\n        self.displayPanel.sigNormalsColorChanged.connect(self._on_normals_color_changed)\n        self.displayPanel.sigNormalsPercentChanged.connect(self._on_normals_percent_changed)\n        self.displayPanel.sigNormalsScaleChanged.connect(self._on_normals_scale_changed)\n        #\n\n    def _on_console_executed(self, cmd: str) -&gt; None:\n        \"\"\"Append executed console command to the MESSAGES panel.\"\"\"\n        try:\n            self.txtMessages.appendPlainText(cmd)\n        except Exception:\n            pass\n\n    def _on_tree_selection_changed(self) -&gt; None:\n        \"\"\"\n        Synchronize the `mct` dictionary with the currently selected item in the treeMCTS widget.\n        Updates the display panel with the parameters of the selected dataset (point size, budget, color mode, etc).\n\n        This ensures that when a user selects a node in the tree, the display panel reflects the properties\n        of the corresponding dataset, allowing for correct editing and visualization.\n        \"\"\"\n        item = self.treeMCTS.currentItem()\n        if item is None:\n            return\n        # Find the root (file node) and its name\n        root = item\n        while root.parent() is not None:\n            root = root.parent()\n        name = root.text(0)\n        entry = self.mcts.get(name)\n        if not entry:\n            return\n        # Find dataset info and ds_index\n        info = self._dataset_info_from_item(item)\n        ds_index = info.get(\"ds\") if info else None\n        #\n        # ... dopo aver determinato ds_index / entry_to_use ...\n        try:\n            ds = self._current_dataset_index()\n            if ds is not None:\n                recs = getattr(self.viewer3d, \"_datasets\", [])\n                if 0 &lt;= ds &lt; len(recs):\n                    nvis = bool(recs[ds].get(\"normals_visible\", False))\n                    self.act_toggle_normals.blockSignals(True)\n                    self.act_toggle_normals.setChecked(nvis)\n                    self.act_toggle_normals.blockSignals(False)\n        except Exception:\n            pass\n        # Select the correct entry if it exists for ds_index\n        entry_to_use = entry\n        if ds_index is not None:\n            for e in self.mcts.values():\n                if e.get(\"ds_index\") == ds_index:\n                    entry_to_use = e\n                    break\n        self.mct = entry_to_use\n        # Update the display panel with the selected dataset's parameters\n        if info:\n            self.displayPanel.set_mode(info.get(\"kind\", \"points\"))\n            self.displayPanel.apply_properties(entry_to_use)\n        # Keep the INSPECTOR tab in sync with the current MCT\n        try:\n            self._refresh_inspector_tree()\n        except Exception:\n            pass\n\n\n    def _refresh_inspector_tree(self) -&gt; None:\n        \"\"\"Rebuild the Inspector tree from a synthesized snapshot of the current state.\n        Includes: current mct entry, viewer settings, per-dataset details and app options.\n        \"\"\"\n        try:\n            data = self._inspector_current_payload()\n            self._populate_inspector_tree(data)\n        except Exception:\n            # Best effort: clear on failure\n            try:\n                self.treeMCT.clear()\n            except Exception:\n                pass\n\n    def _inspector_current_payload(self) -&gt; dict:\n        \"\"\"Collect a rich snapshot of the current session for the INSPECTOR tab.\n\n        Structure:\n            {\n                'mct': ...,                    # currently selected entry (as-is)\n                'options': { ... },            # app/UI options affecting behavior\n                'plugins': [ ... ],            # plugins summary from PluginManager\n                'viewer': { ... },             # global viewer settings\n                'dataset': { ... },            # details for the currently selected dataset\n            }\n        \"\"\"\n        payload: dict = {}\n\n        # --- mct (as-is) -----------------------------------------------------\n        try:\n            payload['mct'] = self.mct\n        except Exception:\n            payload['mct'] = None\n\n        # --- options (app-wide knobs) ----------------------------------------\n        opts = {}\n        try:\n            opts['downsample_method'] = getattr(self, 'downsample_method', None)\n        except Exception:\n            pass\n        # Normals controls (from DisplayPanel if available)\n        try:\n            fast = None\n            if hasattr(self, 'displayPanel') and self.displayPanel is not None:\n                # `fast_normals_enabled()` is our helper; fallback to attr\n                try:\n                    fast = bool(self.displayPanel.fast_normals_enabled())\n                except Exception:\n                    fast = None\n            if fast is None:\n                fast = bool(getattr(self, 'normals_fast_enabled', False))\n            opts['normals_fast_enabled'] = fast\n        except Exception:\n            pass\n        for k, default in (('normals_k', 16), ('normals_fast_max_points', 250_000)):\n            try:\n                opts[k] = getattr(self, k)\n            except Exception:\n                opts[k] = default\n        payload['options'] = opts\n\n        # --- plugins summary --------------------------------------------------\n        plugs = []\n        try:\n            items = self.plugin_manager.ui_combo_items()\n            for it in items:\n                plugs.append({\n                    'key': it.get('key'),\n                    'label': it.get('label'),\n                    'enabled': it.get('enabled', True),\n                    'color': it.get('color'),\n                    'tooltip': it.get('tooltip', ''),\n                    'order': it.get('order'),\n                })\n        except Exception:\n            pass\n        payload['plugins'] = plugs\n\n        # --- viewer global settings ------------------------------------------\n        viewer = {}\n        try:\n            v = self.viewer3d\n            viewer['color_mode'] = getattr(v, '_color_mode', None)\n            viewer['colormap'] = getattr(v, '_cmap', None)\n            viewer['point_size'] = getattr(v, '_point_size', None)\n            viewer['view_budget_percent'] = getattr(v, '_view_budget_percent', None)\n            viewer['points_as_spheres'] = getattr(v, '_points_as_spheres', None)\n            # Safe rendering toggle (if exposed via menu action)\n            try:\n                viewer['safe_rendering'] = bool(self.act_safe_render.isChecked())\n            except Exception:\n                viewer['safe_rendering'] = None\n            # Counts\n            try:\n                recs = getattr(v, '_datasets', [])\n                viewer['datasets_count'] = len(recs)\n            except Exception:\n                viewer['datasets_count'] = None\n        except Exception:\n            pass\n        payload['viewer'] = viewer\n\n        # --- current dataset details -----------------------------------------\n        ds_info = {}\n        try:\n            ds = self._current_dataset_index()\n            ds_info['index'] = ds\n            v = self.viewer3d\n            recs = getattr(v, '_datasets', [])\n            if isinstance(ds, int) and 0 &lt;= ds &lt; len(recs):\n                rec = recs[ds]\n                # Basic flags\n                ds_info['visible'] = bool(rec.get('visible', True))\n                ds_info['kind'] = rec.get('kind', 'points')\n                ds_info['solid_color'] = tuple(rec.get('solid_color', (1.0, 1.0, 1.0)))\n                # PolyData summary\n                try:\n                    pdata = rec.get('pdata')\n                    ds_info['n_points'] = int(getattr(pdata, 'n_points', 0)) if pdata is not None else None\n                    ds_info['n_cells'] = int(getattr(pdata, 'n_cells', 0)) if pdata is not None else None\n                    # Available arrays\n                    pt_names = []\n                    try:\n                        if hasattr(pdata, 'point_data'):\n                            pt_names = list(pdata.point_data.keys())\n                    except Exception:\n                        pass\n                    ds_info['point_arrays'] = pt_names\n                except Exception:\n                    pass\n                # Normals section (per-dataset state kept by viewer)\n                norms = {\n                    'has_normals_array': False,\n                    'normals_visible': bool(rec.get('normals_visible', False)),\n                    'normals_style': rec.get('normals_style'),\n                    'normals_color': tuple(rec.get('normals_color', (1.0, 0.8, 0.2))),\n                    'normals_percent': int(rec.get('normals_percent', getattr(v, '_normals_percent', 1))),\n                    'normals_scale': int(rec.get('normals_scale', getattr(v, '_normals_scale', 20))),\n                    'actor_exists': rec.get('actor_normals') is not None,\n                }\n                try:\n                    pdata = rec.get('pdata')\n                    norms['has_normals_array'] = bool(pdata is not None and ('Normals' in getattr(pdata, 'point_data', {})))\n                except Exception:\n                    pass\n                ds_info['normals'] = norms\n            else:\n                ds_info['note'] = 'No valid dataset selected.'\n        except Exception:\n            pass\n        payload['dataset'] = ds_info\n\n        return payload\n\n    def _populate_inspector_tree(self, data) -&gt; None:\n        \"\"\"Populate the Inspector QTreeWidget with a nested view of *data*.\"\"\"\n        try:\n            self.treeMCT.clear()\n        except Exception:\n            return\n\n        root = QtWidgets.QTreeWidgetItem([\"session\", self._format_inspector_value(data)])\n        self.treeMCT.addTopLevelItem(root)\n        self._inspector_add_children(root, data)\n        try:\n            self.treeMCT.expandAll()\n        except Exception:\n            pass\n\n    def _inspector_add_children(self, parent: QtWidgets.QTreeWidgetItem, obj) -&gt; None:\n        \"\"\"Recursive expansion of mappings, sequences, numpy arrays, and PyVista datasets.\"\"\"\n        # Avoid deep expansion of basic/leaf values\n        try:\n            import numpy as _np\n        except Exception:\n            _np = None\n        try:\n            import pyvista as _pv  # type: ignore\n        except Exception:\n            _pv = None\n\n        # Dict-like\n        try:\n            from collections.abc import Mapping, Sequence\n        except Exception:\n            Mapping, Sequence = dict, (list, tuple)  # fallbacks\n\n        if isinstance(obj, Mapping):\n            for k, v in obj.items():\n                key = str(k)\n                val = self._format_inspector_value(v)\n                child = QtWidgets.QTreeWidgetItem([key, val])\n                parent.addChild(child)\n                self._inspector_add_children(child, v)\n            return\n\n        # List/tuple-like (but not str/bytes)\n        if isinstance(obj, Sequence) and not isinstance(obj, (str, bytes, bytearray)):\n            for i, v in enumerate(obj):\n                key = f\"[{i}]\"\n                val = self._format_inspector_value(v)\n                child = QtWidgets.QTreeWidgetItem([key, val])\n                parent.addChild(child)\n                self._inspector_add_children(child, v)\n            return\n\n        # numpy arrays: show shape/dtype\n        if _np is not None and isinstance(obj, _np.ndarray):\n            # Already summarized in the value; also expose shape/dtype explicitly\n            sh = tuple(obj.shape)\n            dt = str(obj.dtype)\n            parent.addChild(QtWidgets.QTreeWidgetItem([\"shape\", str(sh)]))\n            parent.addChild(QtWidgets.QTreeWidgetItem([\"dtype\", dt]))\n            return\n\n        # PyVista datasets: summarize counts and arrays\n        if _pv is not None and isinstance(obj, _pv.DataSet):\n            try:\n                parent.addChild(QtWidgets.QTreeWidgetItem([\"type\", type(obj).__name__]))\n            except Exception:\n                pass\n            try:\n                parent.addChild(QtWidgets.QTreeWidgetItem([\"n_points\", str(getattr(obj, \"n_points\", \"?\"))]))\n            except Exception:\n                pass\n            try:\n                parent.addChild(QtWidgets.QTreeWidgetItem([\"n_cells\", str(getattr(obj, \"n_cells\", \"?\"))]))\n            except Exception:\n                pass\n            # Point data arrays\n            try:\n                if hasattr(obj, \"point_data\") and len(obj.point_data) &gt; 0:\n                    pd = QtWidgets.QTreeWidgetItem([\"point_data\", f\"{len(obj.point_data)} arrays\"])\n                    parent.addChild(pd)\n                    for name in obj.point_data.keys():\n                        arr = obj.point_data[name]\n                        label = f\"{name}  shape={getattr(arr, 'shape', '?')} dtype={getattr(arr, 'dtype', '?')}\"\n                        pd.addChild(QtWidgets.QTreeWidgetItem([name, label]))\n            except Exception:\n                pass\n            # Cell data arrays\n            try:\n                if hasattr(obj, \"cell_data\") and len(obj.cell_data) &gt; 0:\n                    cd = QtWidgets.QTreeWidgetItem([\"cell_data\", f\"{len(obj.cell_data)} arrays\"])\n                    parent.addChild(cd)\n                    for name in obj.cell_data.keys():\n                        arr = obj.cell_data[name]\n                        label = f\"{name}  shape={getattr(arr, 'shape', '?')} dtype={getattr(arr, 'dtype', '?')}\"\n                        cd.addChild(QtWidgets.QTreeWidgetItem([name, label]))\n            except Exception:\n                pass\n            return\n        # Other types are treated as leaves\n\n    def _format_inspector_value(self, v) -&gt; str:\n        \"\"\"Short one-line summary for Inspector values.\"\"\"\n        try:\n            import numpy as _np\n        except Exception:\n            _np = None\n        try:\n            import pyvista as _pv  # type: ignore\n        except Exception:\n            _pv = None\n\n        if v is None:\n            return \"None\"\n        if isinstance(v, (bool, int, float, str)):\n            return str(v)\n        if isinstance(v, dict):\n            return f\"dict[{len(v)}]\"\n        if isinstance(v, (list, tuple)):\n            return f\"{type(v).__name__}[{len(v)}]\"\n        if _np is not None and isinstance(v, _np.ndarray):\n            try:\n                return f\"ndarray shape={v.shape} dtype={v.dtype}\"\n            except Exception:\n                return \"ndarray\"\n        if _pv is not None and isinstance(v, _pv.DataSet):\n            try:\n                npts = getattr(v, 'n_points', '?')\n                ncells = getattr(v, 'n_cells', '?')\n                return f\"{type(v).__name__} (pts={npts}, cells={ncells})\"\n            except Exception:\n                return type(v).__name__\n        # Generic fallback\n        return type(v).__name__\n\n    def _defer(self, ms: int, fn) -&gt; None:\n        \"\"\"Run callable *fn* after *ms* milliseconds on the GUI thread (best-effort).\"\"\"\n        try:\n            QtCore.QTimer.singleShot(int(max(0, ms)), fn)\n        except Exception:\n            try:\n                fn()\n            except Exception:\n                pass\n\n    def _apply_cached_visuals(self, ds: int) -&gt; None:\n        \"\"\"Reapply cached per-dataset visual properties to the live actor.\n\n        Ensures that after a full-scene rebuild or actor creation, the dataset\n        keeps its styling (point size, color mode, colormap, solid color, opacity).\n        \"\"\"\n        v = getattr(self, \"viewer3d\", None)\n        if v is None:\n            return\n        try:\n            recs = getattr(v, \"_datasets\", [])\n            if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n                return\n            rec = recs[ds]\n            if \"point_size\" in rec:\n                try:\n                    getattr(v, \"set_point_size\", lambda *_: None)(int(rec.get(\"point_size\", 3)), ds)\n                except Exception:\n                    pass\n            # Point budget / visible percentage for points datasets\n            if \"point_budget\" in rec:\n                try:\n                    getattr(v, \"set_point_budget\", lambda *_: None)(int(rec.get(\"point_budget\", 100)), ds)\n                except Exception:\n                    pass\n            if \"color_mode\" in rec:\n                try:\n                    getattr(v, \"set_color_mode\", lambda *_: None)(str(rec.get(\"color_mode\")), ds)\n                except Exception:\n                    pass\n            if \"colormap\" in rec:\n                try:\n                    getattr(v, \"set_colormap\", lambda *_: None)(str(rec.get(\"colormap\")), ds)\n                except Exception:\n                    pass\n            if \"solid_color\" in rec:\n                try:\n                    r, g, b = rec[\"solid_color\"]\n                    if all(isinstance(c, float) and 0.0 &lt;= c &lt;= 1.0 for c in (r, g, b)):\n                        r, g, b = int(r*255), int(g*255), int(b*255)\n                    getattr(v, \"set_dataset_color\", lambda *_: None)(ds, int(r), int(g), int(b))\n                except Exception:\n                    pass\n            if \"opacity\" in rec:\n                try:\n                    getattr(v, \"set_mesh_opacity\", lambda *_: None)(ds, int(rec.get(\"opacity\", 100)))\n                except Exception:\n                    pass\n            # Mesh representation (e.g., 'Surface', 'Wireframe')\n            if \"representation\" in rec:\n                try:\n                    getattr(v, \"set_mesh_representation\", lambda *_: None)(ds, str(rec.get(\"representation\")))\n                except Exception:\n                    pass\n            # Points rendering style (if exposed)\n            try:\n                if \"points_as_spheres\" in rec:\n                    getattr(v, \"set_points_as_spheres\", lambda *_: None)(bool(rec.get(\"points_as_spheres\", True)))\n            except Exception:\n                pass\n            # Honor cached normals visibility without enabling when False\n            try:\n                if bool(rec.get(\"normals_visible\", False)):\n                    getattr(v, \"set_normals_visibility\", lambda *_: None)(ds, True)\n                else:\n                    self._hide_normals_actor(ds)\n            except Exception:\n                pass\n        except Exception:\n            pass\n\n    def _hide_normals_actor(self, ds: int) -&gt; None:\n        \"\"\"Ensure normals are hidden for dataset *ds* (actor off + cache flag).\"\"\"\n        v = getattr(self, \"viewer3d\", None)\n        if v is None:\n            return\n        try:\n            getattr(v, \"set_normals_visibility\", lambda *_: None)(ds, False)\n        except Exception:\n            pass\n        try:\n            recs = getattr(v, \"_datasets\", [])\n            if 0 &lt;= ds &lt; len(recs):\n                rec = recs[ds]\n                rec[\"normals_visible\"] = False\n                act = rec.get(\"actor_normals\") or rec.get(\"normals_actor\")\n                if act is not None:\n                    try:\n                        act.SetVisibility(0)\n                    except Exception:\n                        try:\n                            act.visibility = False  # type: ignore[attr-defined]\n                        except Exception:\n                            pass\n        except Exception:\n            pass\n\n    def _reset_viewer3d_from_tree(self) -&gt; None:\n        \"\"\"\n        Clear the 3D scene and rebuild visibility/actors of all objects based solely on each node's own check state.\n        Also restores normals visibility based on a dedicated 'normals' node or per-dataset state.\n        \"\"\"\n        v = getattr(self, \"viewer3d\", None)\n        if v is None:\n            return\n\n        # 1) Clear scene\n        try:\n            if hasattr(v, \"clear\"):\n                v.clear()\n            else:\n                getattr(v, \"refresh\", lambda: None)()\n        except Exception:\n            pass\n\n        # 2) Re-apply according to each dataset node's own check (no propagation)\n        normals_requests: list[tuple[int, bool]] = []  # (ds, visible)\n        try:\n            def recurse(node: QtWidgets.QTreeWidgetItem) -&gt; None:\n                data = node.data(0, QtCore.Qt.ItemDataRole.UserRole)\n                if isinstance(data, dict):\n                    kind = data.get(\"kind\")\n                    ds = data.get(\"ds\")\n                    if ds is not None and kind in (\"points\", \"mesh\", \"normals\"):\n                        visible = self._node_self_checked(node)\n                        # Build (or ensure) actors for data-bearing kinds\n                        if kind in (\"points\", \"mesh\"):\n                            # Ensure actor exists before toggling visibility\n                            if bool(visible):\n                                self._viewer_ensure_actor(kind, int(ds))\n                            # Reapply cached visuals after actor creation\n                            self._apply_cached_visuals(int(ds))\n                            self._viewer_set_visibility(kind, int(ds), bool(visible))\n                        elif kind == \"normals\":\n                            normals_requests.append((int(ds), bool(visible)))\n                # Recurse\n                for i in range(node.childCount()):\n                    recurse(node.child(i))\n\n            for i in range(self.treeMCTS.topLevelItemCount()):\n                recurse(self.treeMCTS.topLevelItem(i))\n        except Exception:\n            pass\n\n        # 3) Apply normals visibility AFTER points actors exist\n        try:\n            for ds, on in normals_requests:\n                getattr(v, \"set_normals_visibility\", lambda *_: None)(ds, bool(on))\n                if not on:\n                    self._hide_normals_actor(ds)\n        except Exception:\n            pass\n\n        # 4) If no explicit normals node exists, restore per-dataset state (best effort)\n        try:\n            recs = getattr(v, \"_datasets\", [])\n            for ds, rec in enumerate(recs):\n                want = bool(rec.get(\"normals_visible\", False))\n                # Only if we didn't already apply an explicit request for this ds\n                if all(ds_req != ds for ds_req, _ in normals_requests):\n                    if want:\n                        getattr(v, \"set_normals_visibility\", lambda *_: None)(ds, True)\n        except Exception:\n            pass\n\n        # 5) Restore overlays (grid, units) and refresh\n        try:\n            self._restore_default_overlays()\n        except Exception:\n            pass\n        try:\n            v.refresh()\n        except Exception:\n            pass\n\n    def _node_self_checked(self, item: QtWidgets.QTreeWidgetItem) -&gt; bool:\n        \"\"\"Return True if the item's own checkbox is checked (no parent/child propagation).\"\"\"\n        try:\n            return item.checkState(0) == QtCore.Qt.CheckState.Checked\n        except Exception:\n            return False\n\n    def _reapply_overlays_safe(self) -&gt; None:\n        \"\"\"\n        Ask the viewer to re-apply overlays (grid, units overlay, etc.) without changing camera.\n        Safe no-op if the viewer does not implement it.\n        \"\"\"\n        v = getattr(self, \"viewer3d\", None)\n        if v is None:\n            return\n        # Prefer a public method if available; otherwise accept a private one.\n        for name in (\"reapply_overlays\", \"_apply_overlays\"):\n            fn = getattr(v, name, None)\n            if callable(fn):\n                try:\n                    fn()\n                    return\n                except Exception:\n                    continue\n        # Fallback: ripristina come in _restore_default_overlays\n        try:\n            self._restore_default_overlays()\n        except Exception:\n            pass\n\n    def _restore_default_overlays(self) -&gt; None:\n        \"\"\"\n        Re-enable default viewer overlays after a full scene reset:\n        - Grid (according to toolbar toggle)\n        - Units overlay/ruler if UnitsPlugin is available\n        \"\"\"\n        v = getattr(self, \"viewer3d\", None)\n        if v is None:\n            return\n        # Grid\n        try:\n            on = bool(self.act_toggle_grid.isChecked())\n        except Exception:\n            on = True\n        try:\n            for name in (\"set_grid_visible\", \"toggle_grid\", \"show_grid\"):\n                fn = getattr(v, name, None)\n                if callable(fn):\n                    try:\n                        fn(on)\n                        break\n                    except Exception:\n                        continue\n        except Exception:\n            pass\n        # Units overlay (best effort)\n        try:\n            pm = getattr(self, \"plugin_manager\", None)\n            if pm is not None:\n                units = None\n                for getter in (\"get\", \"plugin_by_key\"):\n                    fn = getattr(pm, getter, None)\n                    if callable(fn):\n                        units = fn(\"units\")\n                        if units:\n                            break\n                if units and hasattr(units, \"overlay\") and hasattr(units, \"state\"):\n                    try:\n                        units.overlay.show_text(units.state)\n                    except Exception:\n                        pass\n        except Exception:\n            pass\n\n    def _dataset_info_from_item(self, item: QtWidgets.QTreeWidgetItem | None):\n        \"\"\"\n        Retrieve dataset info from the given tree item or its neighbors.\n\n        Args:\n            item (QtWidgets.QTreeWidgetItem | None): The tree item to extract info from.\n\n        Returns:\n            dict | None: The dataset info dictionary if found, otherwise None.\n        \"\"\"\n        if item is None:\n            return None\n        data = item.data(0, QtCore.Qt.ItemDataRole.UserRole)\n        if isinstance(data, dict) and data.get(\"ds\") is not None:\n            return data\n        for i in range(item.childCount()):\n            found = self._dataset_info_from_item(item.child(i))\n            if found:\n                return found\n        parent = item.parent()\n        if parent is not None:\n            return self._dataset_info_from_item(parent)\n        return None\n\n    def _viewer_set_visibility(self, kind: str, ds: int, visible: bool) -&gt; None:\n        \"\"\"Toggle dataset visibility in the 3D viewer; ensure actor exists when turning ON.\n        Also: when POINTS are OFF, force normals OFF for the same dataset.\"\"\"\n        v = getattr(self, \"viewer3d\", None)\n        if v is None:\n            return\n\n        # Ensure actor exists if we are turning ON after a clear()\n        if visible and kind in (\"points\", \"mesh\"):\n            self._viewer_ensure_actor(kind, ds)\n        # Re-apply cached visuals so color/colormap don't reset to white defaults\n        if visible:\n            try:\n                self._apply_cached_visuals(ds)\n            except Exception:\n                pass\n\n        # Preferred explicit API\n        for name in (\"set_dataset_visibility\", \"set_visibility\", \"set_points_visibility\", \"set_mesh_visibility\"):\n            fn = getattr(v, name, None)\n            if callable(fn):\n                try:\n                    try:\n                        fn(ds, bool(visible))\n                    except TypeError:\n                        fn(kind, ds, bool(visible))\n                    if kind == \"points\" and not visible:\n                        getattr(v, \"set_normals_visibility\", lambda *_: None)(ds, False)\n                    # Persist visible flag into cache + session dicts\n                    try:\n                        if kind == \"points\":\n                            self._persist_dataset_prop(ds, \"visible\", bool(visible))\n                        elif kind == \"mesh\":\n                            self._persist_dataset_prop(ds, \"visible\", bool(visible))\n                    except Exception:\n                        pass\n                    v.refresh()\n                    return\n                except Exception:\n                    pass\n\n        # Fallback: cached record + actor toggling\n        try:\n            recs = getattr(v, \"_datasets\", [])\n            if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n                return\n            rec = recs[ds]\n            rec[\"visible\"] = bool(visible)\n            actor = rec.get(\"actor\") or rec.get(\"actor_mesh\") or rec.get(\"actor_points\")\n            if actor is None and visible:\n                # Try again to build (another safety)\n                self._viewer_ensure_actor(kind, ds)\n                actor = rec.get(\"actor\") or rec.get(\"actor_mesh\") or rec.get(\"actor_points\")\n            # After (re)creating the actor, re-apply cached styling (solid color, colormap, rep, etc.)\n            if visible:\n                try:\n                    self._apply_cached_visuals(ds)\n                except Exception:\n                    pass\n            if actor is not None:\n                try:\n                    actor.SetVisibility(1 if visible else 0)\n                except Exception:\n                    try:\n                        actor.visibility = bool(visible)  # type: ignore[attr-defined]\n                    except Exception:\n                        pass\n            if kind == \"points\" and not visible:\n                try:\n                    getattr(v, \"set_normals_visibility\", lambda *_: None)(ds, False)\n                except Exception:\n                    pass\n            # Persist visible flag into cache + session dicts\n            try:\n                if kind == \"points\":\n                    self._persist_dataset_prop(ds, \"visible\", bool(visible))\n                elif kind == \"mesh\":\n                    self._persist_dataset_prop(ds, \"visible\", bool(visible))\n            except Exception:\n                pass\n            v.refresh()\n        except Exception:\n            pass\n\n    def _viewer_ensure_actor(self, kind: str, ds: int) -&gt; None:\n        \"\"\"Best-effort: (re)build the actor for dataset `ds` of type `kind`.\n        Used after a full viewer clear() or when an actor is missing.\"\"\"\n        v = getattr(self, \"viewer3d\", None)\n        if v is None:\n            return\n        try:\n            recs = getattr(v, \"_datasets\", [])\n            if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n                return\n            rec = recs[ds]\n            # If an actor already exists, nothing to do\n            actor = rec.get(\"actor\") or rec.get(\"actor_mesh\") or rec.get(\"actor_points\")\n            if actor is not None:\n                return\n\n            # Try public/safe rebuild paths first\n            for name in (\"rebuild_dataset\", \"ensure_dataset_actor\", \"build_dataset_actor\"):\n                fn = getattr(v, name, None)\n                if callable(fn):\n                    try:\n                        fn(ds)\n                        try:\n                            self._apply_cached_visuals(ds)\n                        except Exception:\n                            pass\n                        return\n                    except Exception:\n                        pass\n\n            # Fall back to common internal helpers (pyvista-based viewers often have these)\n            if kind == \"points\":\n                # common internal name\n                for name in (\"_rebuild_points_actor\", \"_update_points_actor\", \"_ensure_points_actor\"):\n                    fn = getattr(v, name, None)\n                    if callable(fn):\n                        try:\n                            fn(ds)\n                            try:\n                                self._apply_cached_visuals(ds)\n                            except Exception:\n                                pass\n                            return\n                        except Exception:\n                            pass\n                # very last resort: add from pdata directly\n                pdata = rec.get(\"pdata\") or rec.get(\"full_pdata\")\n                if pdata is not None:\n                    try:\n                        actor = v.plotter.add_mesh(\n                            pdata, render_points_as_spheres=bool(rec.get(\"points_as_spheres\", True)),\n                            point_size=int(rec.get(\"point_size\", 3)), name=f\"points_ds{ds}\"\n                        )\n                        rec[\"actor_points\"] = actor\n                        try:\n                            self._apply_cached_visuals(ds)\n                        except Exception:\n                            pass\n                    except Exception:\n                        pass\n\n            elif kind == \"mesh\":\n                for name in (\"_rebuild_mesh_actor\", \"_update_mesh_actor\", \"_ensure_mesh_actor\"):\n                    fn = getattr(v, name, None)\n                    if callable(fn):\n                        try:\n                            fn(ds)\n                            try:\n                                self._apply_cached_visuals(ds)\n                            except Exception:\n                                pass\n                            return\n                        except Exception:\n                            pass\n                mesh = rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n                if mesh is not None:\n                    try:\n                        actor = v.plotter.add_mesh(\n                            mesh,\n                            opacity=float(rec.get(\"opacity\", 100))/100.0,\n                            name=f\"mesh_ds{ds}\"\n                        )\n                        rec[\"actor_mesh\"] = actor\n                        try:\n                            self._apply_cached_visuals(ds)\n                        except Exception:\n                            pass\n                    except Exception:\n                        pass\n        except Exception:\n            pass\n\n    def _current_dataset_index(self) -&gt; Optional[int]:\n        \"\"\"\n        Return the dataset index of the currently selected tree item.\n\n        Returns:\n            Optional[int]: The dataset index if available, otherwise None.\n        \"\"\"\n        item = self.treeMCTS.currentItem()\n        info = self._dataset_info_from_item(item)\n        if info:\n            return info.get(\"ds\")\n        return None\n\n    def _persist_dataset_prop(self, ds: int, key: str, value) -&gt; None:\n        \"\"\"Persist a per\u2011dataset property both in the viewer cache (self.viewer3d._datasets)\n        and in the corresponding entry of self.mcts used for session snapshots.\n\n        Args:\n            ds: Dataset index in the viewer cache.\n            key: Property name (e.g., 'point_size').\n            value: Property value to store.\n        \"\"\"\n        # Update viewer cache (used by actor rebuilds)\n        try:\n            recs = getattr(self.viewer3d, \"_datasets\", [])\n            if isinstance(ds, int) and 0 &lt;= ds &lt; len(recs):\n                recs[ds][key] = value\n        except Exception:\n            pass\n\n        # Update mcts registry snapshot (used by UI + sessions)\n        try:\n            for e in self.mcts.values():\n                if e.get(\"ds_index\") == ds:\n                    e[key] = value\n        except Exception:\n            pass\n\n    def _persist_dataset_color(self, ds: int, rgb_tuple: tuple[int, int, int]) -&gt; None:\n        \"\"\"Specialized helper for solid RGB color persistence (kept separate for clarity).\"\"\"\n        self._persist_dataset_prop(ds, \"solid_color\", tuple(rgb_tuple))\n\n    def _on_point_size_changed(self, size: int) -&gt; None:\n        \"\"\"\n        Update the point size for the currently selected dataset.\n\n        Args:\n            size (int): The new point size to set.\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        self.viewer3d.set_point_size(int(size), ds)\n        if self.mct:\n            self.mct[\"point_size\"] = int(size)\n        # Persist also into the viewer cache so actor rebuilds keep the new size\n        self._persist_dataset_prop(ds, \"point_size\", int(size))\n        def _post_psize():\n            try:\n                self._apply_cached_visuals(ds)\n            except Exception:\n                pass\n        self._defer(0, _post_psize)\n\n    def _on_point_budget_changed(self, percent: int) -&gt; None:\n        \"\"\"\n        Update the visible points percentage (point budget) for the selected dataset.\n\n        Args:\n            percent (int): The percentage of points to display.\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        self.viewer3d.set_point_budget(int(percent), ds)\n        if self.mct:\n            self.mct[\"point_budget\"] = int(percent)\n        self._persist_dataset_prop(ds, \"point_budget\", int(percent))\n        try:\n            self._viewer_ensure_actor(\"points\", ds)\n        except Exception:\n            pass\n        def _post_budget():\n            try:\n                self._apply_cached_visuals(ds)\n            except Exception:\n                pass\n        self._defer(0, _post_budget)\n        try:\n            self.viewer3d.refresh()\n        except Exception:\n            pass\n\n    def _on_color_mode_changed(self, mode: str) -&gt; None:\n        \"\"\"\n        Change the color mode of the selected dataset.\n\n        Args:\n            mode (str): The color mode to set (e.g., 'Normal RGB', 'Normal Colormap').\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        self.viewer3d.set_color_mode(mode, ds)\n        if self.mct:\n            self.mct[\"color_mode\"] = mode\n        self._persist_dataset_prop(ds, \"color_mode\", str(mode))\n        try:\n            self.viewer3d.refresh()\n        except Exception:\n            pass\n\n    def _on_solid_color_changed(self, col: QtGui.QColor) -&gt; None:\n        \"\"\"\n        Set the solid color for the selected dataset.\n\n        Args:\n            col (QtGui.QColor): The color to set.\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None or not col.isValid():\n            return\n        self.viewer3d.set_dataset_color(ds, col.red(), col.green(), col.blue())\n        if self.mct:\n            self.mct[\"solid_color\"] = (col.red(), col.green(), col.blue())\n        self._persist_dataset_color(ds, (col.red(), col.green(), col.blue()))\n        try:\n            self.viewer3d.refresh()\n        except Exception:\n            pass\n\n    def _on_colormap_changed(self, name: str) -&gt; None:\n        \"\"\"\n        Update the colormap for the selected dataset.\n\n        Args:\n            name (str): The name of the colormap to apply.\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        self.viewer3d.set_colormap(name, ds)\n        if self.mct:\n            self.mct[\"colormap\"] = name\n        self._persist_dataset_prop(ds, \"colormap\", str(name))\n        try:\n            self.viewer3d.refresh()\n        except Exception:\n            pass\n\n    def _on_mesh_rep_changed(self, mode: str) -&gt; None:\n        \"\"\"\n        Change the mesh representation mode for the selected mesh dataset.\n\n        Args:\n            mode (str): The mesh representation mode (e.g., 'Surface', 'Wireframe').\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        self.viewer3d.set_mesh_representation(ds, mode)\n        if self.mct:\n            self.mct[\"representation\"] = mode\n        self._persist_dataset_prop(ds, \"representation\", str(mode))\n        # TEMP: rebuild scene once to avoid desync/orphan actors\n        self._schedule_scene_rebuild()\n\n    def _on_mesh_opacity_changed(self, val: int) -&gt; None:\n        \"\"\"\n        Update the opacity for the selected mesh dataset.\n\n        Args:\n            val (int): The opacity value (0-100).\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        self.viewer3d.set_mesh_opacity(ds, int(val))\n        if self.mct:\n            self.mct[\"opacity\"] = int(val)\n        self._persist_dataset_prop(ds, \"opacity\", int(val))\n        # TEMP: rebuild scene once to avoid desync/orphan actors\n        self._schedule_scene_rebuild()\n\n    def _on_toggle_normals_clicked(self, on: bool) -&gt; None:\n        \"\"\"Toggle Normals dal pulsante della toolbar sul dataset selezionato.\"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            # niente dataset selezionato\n            return\n\n        # Se non esiste il nodo \"Normals\" nel tree, crealo (non lo spunta ancora).\n        normals_item = None\n        try:\n            normals_item = self._ensure_normals_tree_child(ds)\n        except Exception:\n            normals_item = None\n        if normals_item is not None:\n            try:\n                normals_item.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"normals\", \"ds\": int(ds)})\n            except Exception:\n                pass\n\n        # Attiva/disattiva visibilit\u00e0 lato viewer\n        try:\n            getattr(self.viewer3d, \"set_normals_visibility\", lambda *_: None)(ds, bool(on))\n        except Exception:\n            return\n\n        # Persist normals visibility in the dataset record\n        try:\n            self._persist_dataset_prop(ds, \"normals_visible\", bool(on))\n        except Exception:\n            pass\n\n        def _post_normals_toggle():\n            try:\n                self._apply_cached_visuals(ds)\n            except Exception:\n                pass\n            try:\n                self.viewer3d.refresh()\n            except Exception:\n                pass\n        self._defer(1, _post_normals_toggle)\n        try:\n            self._reapply_overlays_safe()\n        except Exception:\n            pass\n\n        # Sincronizza lo stato del nodo \"Normals\" nell'albero (se presente)\n        try:\n            item = self.treeMCTS.currentItem()\n            if item is not None:\n                # sali al root (file)\n                root = item\n                while root.parent() is not None:\n                    root = root.parent()\n                # trova il figlio \"Point cloud\" e poi \"Normals\"\n                target = None\n                for i in range(root.childCount()):\n                    if root.child(i).text(0) == \"Point cloud\":\n                        target = root.child(i)\n                        break\n                if target is not None:\n                    for i in range(target.childCount()):\n                        ch = target.child(i)\n                        data = ch.data(0, QtCore.Qt.ItemDataRole.UserRole)\n                        if ch.text(0) == \"Normals\" and isinstance(data, dict) and data.get(\"ds\") == ds:\n                            ch.setCheckState(0, QtCore.Qt.CheckState.Checked if on else QtCore.Qt.CheckState.Unchecked)\n                            break\n        except Exception:\n            pass\n        # TEMP: rebuild scene once to avoid desync/orphan actors\n        # self._schedule_scene_rebuild()\n\n    def _build_statusbar(self) -&gt; None:\n        sb = QtWidgets.QStatusBar(self)\n        self.setStatusBar(sb)\n\n        # --- Widgets -----------------------------------------------------\n        self.btnCancel = QtWidgets.QPushButton(\"CANCEL\")\n        self.btnCancel.setObjectName(\"buttonCANCEL\")\n        self.btnCancel.setEnabled(False)\n        self.btnCancel.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)\n\n        self.progress = QtWidgets.QProgressBar()\n        self.progress.setObjectName(\"barPROGRESS\")\n        self.progress.setRange(0, 100)\n        self.progress.setValue(0)\n        self.progress.setFormat(\"Idle\")\n        self.progress.setTextVisible(True)\n        self.progress.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Preferred)\n\n        self.disk = QtWidgets.QProgressBar()\n        self.disk.setObjectName(\"diskUsageBar\")\n        self.disk.setRange(0, 100)\n        self.disk.setValue(0)\n        self.disk.setTextVisible(True)\n        self.disk.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Preferred)\n\n        # Container to control layout &amp; stretches (so showMessage won't hide widgets)\n        panel = QtWidgets.QWidget()\n        lay = QtWidgets.QHBoxLayout(panel)\n        lay.setContentsMargins(0, 0, 0, 0)\n        lay.setSpacing(6)\n        lay.addWidget(self.btnCancel)\n        lay.addWidget(self.progress, 3)  # ~60%\n        lay.addWidget(self.disk, 2)      # ~40%\n\n        # Add as permanent widget so temporary status messages don't hide it\n        sb.addPermanentWidget(panel, 1)\n\n    def _start_disk_timer(self) -&gt; None:\n        self._disk_timer = QtCore.QTimer(self)\n        self._disk_timer.timeout.connect(self._update_disk)\n        self._disk_timer.start(2000)\n        self._update_disk()\n\n    def _update_disk(self) -&gt; None:\n        used, free, percent = disk_usage_percent()\n        self.disk.setValue(int(percent))\n        self.disk.setFormat(f\"Disk used: {percent:.0f}%\")\n\n    # ------------------------------------------------------------------\n    # Progress bar helpers + background-worker slots\n    # ------------------------------------------------------------------\n    # --- Progress helpers (import cloud) ---------------------------------\n    def _import_progress_begin(self, title: str = \"Importing cloud\u2026\") -&gt; None:\n        \"\"\"Begin an import progress section (safe to call multiple times).\"\"\"\n        try:\n            # Reuse the generic progress bar helpers already wired to the status bar\n            self._progress_start(title)\n        except Exception:\n            pass\n\n    def _import_progress_update(self, percent: int | None = None, message: str | None = None) -&gt; None:\n        \"\"\"Update progress bar during import.\"\"\"\n        try:\n            if percent is not None:\n                v = int(max(0, min(100, percent)))\n                try:\n                    self.progress.setValue(v)\n                except Exception:\n                    pass\n            if message:\n                # Show a short status text while keeping the bar visible\n                try:\n                    self.progress.setFormat(str(message))\n                except Exception:\n                    pass\n                try:\n                    self.statusBar().showMessage(message, 2000)\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n    def _import_progress_end(self) -&gt; None:\n        \"\"\"End the import progress section.\"\"\"\n        try:\n            self._progress_finish()\n        except Exception:\n            pass\n    # ---------------------------------------------------------------------\n    def _progress_start(self, text: str = \"Working\u2026\") -&gt; None:\n        \"\"\"Initialize the statusbar progress bar.\"\"\"\n        try:\n            self.progress.setRange(0, 100)\n            self.progress.setValue(0)\n            self.progress.setFormat(text)\n            self.progress.setTextVisible(True)\n        except Exception:\n            pass\n\n    def _progress_set(self, value: int | float, text: str | None = None) -&gt; None:\n        \"\"\"Update progress value (0..100) and optional text.\"\"\"\n        try:\n            v = int(max(0, min(100, round(float(value)))))\n            self.progress.setValue(v)\n            if text is not None:\n                self.progress.setFormat(str(text))\n        except Exception:\n            pass\n\n    def _progress_finish(self, text: str = \"Ready\") -&gt; None:\n        \"\"\"Finish the progress and reset UI bits.\"\"\"\n        try:\n            self.progress.setValue(100)\n            self.progress.setFormat(text)\n        except Exception:\n            pass\n        # Disable cancel if it was enabled\n        try:\n            self.btnCancel.setEnabled(False)\n        except Exception:\n            pass\n        # Clear active job context\n        try:\n            self._active_job = None\n        except Exception:\n            pass\n\n    def _ensure_cancel_button(self) -&gt; None:\n        \"\"\"Best-effort: ensure the Cancel button is visible/enabled for jobs.\"\"\"\n        try:\n            self.btnCancel.setEnabled(True)\n        except Exception:\n            pass\n\n    @QtCore.Slot()\n    def _on_cancel_job(self) -&gt; None:\n        \"\"\"User pressed CANCEL: ask the active worker to stop.\"\"\"\n        job = getattr(self, \"_active_job\", None)\n        worker = None\n        if isinstance(job, dict):\n            worker = job.get(\"worker\")\n        try:\n            if worker is not None and hasattr(worker, \"request_cancel\"):\n                worker.request_cancel()\n            self.statusBar().showMessage(\"Cancelling\u2026\", 2000)\n        except Exception:\n            pass\n\n    # --- Slots used by _NormalsWorker (progress/message/finished) -----------\n    @QtCore.Slot(int)\n    def _slot_worker_progress(self, p: int) -&gt; None:\n        \"\"\"Update the progress bar percentage.\"\"\"\n        self._progress_set(p)\n\n    @QtCore.Slot(str)\n    def _slot_worker_message(self, msg: str) -&gt; None:\n        \"\"\"Reflect worker text into the progress format.\"\"\"\n        self._progress_set(self.progress.value(), msg)\n\n    @QtCore.Slot(object)\n    def _slot_worker_finished(self, normals_obj) -&gt; None:\n        \"\"\"\n        Worker finished. If `normals_obj` is an Nx3 array, attach/store it to the\n        current dataset and (optionally) show normals based on the toolbar toggle.\n        Always tear down the worker thread and finalize the progress bar.\n        \"\"\"\n        # Tear down the worker thread (best-effort)\n        try:\n            ctx = getattr(self, \"_normals_ctx\", {}) or {}\n            thread = ctx.get(\"thread\")\n            if thread is not None:\n                try:\n                    thread.quit()\n                    thread.wait()\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n        # If we got normals, persist them into the viewer's dataset\n        try:\n            import numpy as _np  # local import to keep module import-time light\n            ds = int(self._normals_ctx.get(\"ds\")) if hasattr(self, \"_normals_ctx\") else None\n            if normals_obj is not None and ds is not None:\n                arr = _np.asarray(normals_obj)\n                if arr.ndim == 2 and arr.shape[1] == 3:\n                    # Try a dedicated API first\n                    set_api = getattr(self.viewer3d, \"set_normals_array\", None)\n                    if callable(set_api):\n                        try:\n                            set_api(ds, arr)\n                        except Exception:\n                            pass\n                    # Also update the cached record and point_data if accessible\n                    try:\n                        recs = getattr(self.viewer3d, \"_datasets\", [])\n                        if 0 &lt;= ds &lt; len(recs):\n                            rec = recs[ds]\n                            rec[\"normals_array\"] = arr\n                            pdata = rec.get(\"pdata\") or rec.get(\"full_pdata\")\n                            if pdata is not None and hasattr(pdata, \"point_data\"):\n                                pdata.point_data[\"Normals\"] = arr\n                    except Exception:\n                        pass\n\n                    # Apply initial display percentage from context, default 1%\n                    try:\n                        percent = int(getattr(self, \"_normals_ctx\", {}).get(\"percent\", 1))\n                    except Exception:\n                        percent = 1\n                    # Persist into the dataset record so builder uses it\n                    try:\n                        recs = getattr(self.viewer3d, \"_datasets\", [])\n                        if 0 &lt;= ds &lt; len(recs):\n                            rec = recs[ds]\n                            rec[\"normals_percent\"] = percent\n                    except Exception:\n                        pass\n                    # If the viewer exposes a setter for percent, use it; otherwise trigger a rebuild\n                    try:\n                        setp = getattr(self.viewer3d, \"set_normals_percent\", None)\n                        if callable(setp):\n                            # Some implementations accept (ds, percent, rebuild=True)\n                            try:\n                                setp(ds, percent, True)\n                            except TypeError:\n                                setp(ds, percent)\n                        else:\n                            # Best-effort: rebuild normals actor so the new percent is honored\n                            rebuild = getattr(self.viewer3d, \"_rebuild_normals_actor\", None)\n                            if callable(rebuild):\n                                rebuild(ds)\n                    except Exception:\n                        pass\n\n                    # --- Ensure normals are actually shown once computed: force-build actor and toggle ON ---\n                    try:\n                        # Persist visibility flag in cache\n                        recs = getattr(self.viewer3d, \"_datasets\", [])\n                        if 0 &lt;= ds &lt; len(recs):\n                            recs[ds][\"normals_visible\"] = True\n                    except Exception:\n                        pass\n                    try:\n                        # Build or rebuild the normals actor explicitly if the viewer exposes it\n                        rebuild_normals = getattr(self.viewer3d, \"_rebuild_normals_actor\", None)\n                        if callable(rebuild_normals):\n                            rebuild_normals(ds)\n                    except Exception:\n                        pass\n                    try:\n                        # Turn on the toolbar toggle (UI) without emitting recursive signals\n                        self.act_toggle_normals.blockSignals(True)\n                        self.act_toggle_normals.setChecked(True)\n                        self.act_toggle_normals.blockSignals(False)\n                    except Exception:\n                        pass\n                    try:\n                        # Finally, ensure visibility ON at the viewer level\n                        getattr(self.viewer3d, \"set_normals_visibility\", lambda *_: None)(ds, True)\n                    except Exception:\n                        pass\n\n                    # Visibility handled above: we explicitly turned normals ON after compute.\n                    # (Old code removed here.)\n        except Exception:\n            pass\n\n        # Finalize UI\n        self._progress_finish(\"Normals done\")\n\n    def _on_compute_normals(self) -&gt; None:\n        \"\"\"Compute point\u2011cloud normals in a background thread (non\u2011blocking UI).\n\n        Priority: PCA on k-NN neighborhoods with optional FAST mode (subset + propagate).\n        On success, stores normals into the current dataset entry and updates the UI.\n        \"\"\"\n        import numpy as np\n\n        self._progress_start(\"Starting normals computation\u2026\")\n        self._ensure_cancel_button()\n\n        # Grab current dataset points from viewer cache if available via self.mct\n        entry = getattr(self, \"mct\", None)\n        if not entry or entry.get(\"ds_index\") is None:\n            self._append_message(\"[Normals] No active dataset selected.\")\n            self._progress_finish(\"Normals not computed: no dataset\")\n            return\n        ds = int(entry[\"ds_index\"]) if entry.get(\"ds_index\") is not None else None\n\n        # Try to fetch points back from viewer; fall back to stored structures if available\n        P = None\n        try:\n            datasets = getattr(self.viewer3d, \"_datasets\", [])\n            if isinstance(ds, int) and 0 &lt;= ds &lt; len(datasets):\n                fp = datasets[ds].get(\"full_pdata\") or datasets[ds].get(\"pdata\")\n                # Expect PyVista PolyData or numpy array alike\n                if hasattr(fp, \"points\"):\n                    P = np.asarray(fp.points, dtype=float)\n                elif hasattr(fp, \"to_numpy\"):\n                    P = np.asarray(fp.to_numpy(), dtype=float)\n                else:\n                    P = np.asarray(fp, dtype=float)\n        except Exception:\n            P = None\n\n        if P is None or P.ndim != 2 or P.shape[1] != 3 or P.shape[0] == 0:\n            self._append_message(\"[Normals] Cannot access points for current dataset.\")\n            self._progress_finish(\"Normals not computed: invalid points\")\n            return\n\n        # Read fast flag\n        # Fast-mode flag: prefer DisplayPanel state if present, otherwise fallback\n        fast_flag = False\n        try:\n            if hasattr(self, \"displayPanel\") and self.displayPanel is not None:\n                fast_flag = bool(self.displayPanel.fast_normals_enabled())\n            else:\n                fast_flag = bool(getattr(self, \"normals_fast_enabled\", False))\n        except Exception:\n            pass\n\n        # Parameters (you can expose k via settings later)\n        k_nn = int(getattr(self, \"normals_k\", 16))\n        max_fast = int(getattr(self, \"normals_fast_max_points\", 250_000))\n\n        # Initial display percentage for normals (default 1%)\n        try:\n            percent_ui = int(self.displayPanel.spinNormalsPercent.value())\n        except Exception:\n            percent_ui = 1\n\n        # Harden against macOS/Accelerate and OpenMP threading issues inside background threads\n        try:\n            import os as _os\n            _os.environ.setdefault(\"OMP_NUM_THREADS\", \"1\")\n            _os.environ.setdefault(\"OPENBLAS_NUM_THREADS\", \"1\")\n            _os.environ.setdefault(\"MKL_NUM_THREADS\", \"1\")\n            _os.environ.setdefault(\"VECLIB_MAXIMUM_THREADS\", \"1\")\n            _os.environ.setdefault(\"NUMEXPR_NUM_THREADS\", \"1\")\n        except Exception:\n            pass\n\n        # Prepare worker\n        worker = _NormalsWorker(points=P, k=k_nn, subset_size=80_000,\n                                fast=fast_flag, fast_max_points=max_fast)\n        thread = QtCore.QThread(self)\n        worker.moveToThread(thread)\n\n        # salva contesto per lo slot di fine\n        self._normals_ctx = {\"P\": P, \"ds\": ds, \"entry\": entry, \"thread\": thread, \"percent\": percent_ui}\n\n        # connessioni ai nuovi slot (GUI thread garantito)\n        worker.progress.connect(self._slot_worker_progress, QtCore.Qt.ConnectionType.QueuedConnection)\n        worker.message.connect(self._slot_worker_message, QtCore.Qt.ConnectionType.QueuedConnection)\n        worker.finished.connect(self._slot_worker_finished, QtCore.Qt.ConnectionType.QueuedConnection)\n\n        thread.started.connect(worker.run)\n        thread.start()\n\n        # Expose active job for cancellation\n        self._active_job = {\"worker\": worker, \"thread\": thread}\n        self.btnCancel.clicked.connect(self._on_cancel_job, QtCore.Qt.ConnectionType.UniqueConnection)\n        self.btnCancel.setEnabled(True)\n\n    # ------------------------------------------------------------------\n    # Session I/O: New / Open / Save / Save As\n    # ------------------------------------------------------------------\n    def _on_new_session(self) -&gt; None:\n        \"\"\"Start a new empty session, clearing tree, viewer and state.\"\"\"\n        try:\n            if self.mcts:\n                ret = QtWidgets.QMessageBox.question(\n                    self, \"New Session\",\n                    \"Discard current session and start a new one?\",\n                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,\n                    QtWidgets.QMessageBox.No,\n                )\n                if ret != QtWidgets.QMessageBox.Yes:\n                    return\n        except Exception:\n            pass\n        # Clear UI state\n        try:\n            self.treeMCTS.clear()\n        except Exception:\n            pass\n        try:\n            if hasattr(self.viewer3d, \"clear\"):\n                self.viewer3d.clear()\n        except Exception:\n            pass\n        self.mcts = {}\n        self.mct = {}\n        self._session_path = None\n        try:\n            self.statusBar().showMessage(\"New session\", 3000)\n        except Exception:\n            pass\n\n    def _on_open_session(self) -&gt; None:\n        \"\"\"Open a saved C2F4DT session (.c2f4dt.json).\"\"\"\n        dlg = QtWidgets.QFileDialog(self, \"Open session\")\n        dlg.setFileMode(QtWidgets.QFileDialog.ExistingFile)\n        dlg.setNameFilters([\"C2F4DT Session (*.c2f4dt.json)\", \"JSON (*.json)\", \"All files (*)\"])\n        if not dlg.exec():\n            return\n        paths = dlg.selectedFiles()\n        if not paths:\n            return\n        self._load_session_from_file(paths[0])\n\n    def _on_save_session(self) -&gt; None:\n        \"\"\"Save the current session to disk; if untitled, fallback to Save As.\"\"\"\n        if not self._session_path:\n            self._on_save_session_as()\n            return\n        data = self._session_snapshot()\n        try:\n            with open(self._session_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(data, f, indent=2)\n            try:\n                self.statusBar().showMessage(f\"Saved session to {os.path.basename(self._session_path)}\", 3000)\n            except Exception:\n                pass\n        except Exception as ex:\n            QtWidgets.QMessageBox.critical(self, \"Save error\", str(ex))\n\n    def _on_save_session_as(self) -&gt; None:\n        \"\"\"Prompt for a path and save the session JSON there.\"\"\"\n        dlg = QtWidgets.QFileDialog(self, \"Save session as\")\n        dlg.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)\n        dlg.setNameFilters([\"C2F4DT Session (*.c2f4dt.json)\", \"JSON (*.json)\", \"All files (*)\"])\n        dlg.setDefaultSuffix(\"c2f4dt.json\")\n        if not dlg.exec():\n            return\n        paths = dlg.selectedFiles()\n        if not paths:\n            return\n        self._session_path = paths[0]\n        # ensure extension\n        if not (self._session_path.endswith(\".c2f4dt.json\") or self._session_path.endswith(\".json\")):\n            self._session_path += \".c2f4dt.json\"\n        self._on_save_session()\n\n    def _session_snapshot(self) -&gt; dict:\n        \"\"\"Capture a lightweight, JSON\u2011serializable snapshot of the current session.\"\"\"\n        snap: dict = {\"version\": 1, \"datasets\": [], \"viewer\": {}, \"options\": {}}\n        # Viewer globals\n        try:\n            v = self.viewer3d\n            snap[\"viewer\"] = {\n                \"color_mode\": getattr(v, \"_color_mode\", None),\n                \"colormap\": getattr(v, \"_cmap\", None),\n                \"point_size\": getattr(v, \"_point_size\", None),\n                \"view_budget_percent\": getattr(v, \"_view_budget_percent\", None),\n                \"points_as_spheres\": getattr(v, \"_points_as_spheres\", None),\n            }\n        except Exception:\n            pass\n        # App options\n        try:\n            snap[\"options\"][\"downsample_method\"] = getattr(self, \"downsample_method\", None)\n            snap[\"options\"][\"normals_fast_enabled\"] = bool(getattr(self, \"normals_fast_enabled\", False))\n            snap[\"options\"][\"normals_k\"] = int(getattr(self, \"normals_k\", 16))\n            snap[\"options\"][\"normals_fast_max_points\"] = int(getattr(self, \"normals_fast_max_points\", 250_000))\n        except Exception:\n            pass\n        # Datasets (from mcts registry)\n        try:\n            for name, entry in self.mcts.items():\n                ds = {\n                    \"name\": name,\n                    \"kind\": entry.get(\"kind\"),\n                    \"ds_index\": entry.get(\"ds_index\"),\n                    \"point_size\": entry.get(\"point_size\"),\n                    \"point_budget\": entry.get(\"point_budget\"),\n                    \"color_mode\": entry.get(\"color_mode\"),\n                    \"colormap\": entry.get(\"colormap\"),\n                    \"solid_color\": entry.get(\"solid_color\"),\n                    \"points_as_spheres\": entry.get(\"points_as_spheres\"),\n                    # Optional: if your importers store the original path\n                    \"source_path\": entry.get(\"source_path\"),\n                }\n                snap[\"datasets\"].append(ds)\n        except Exception:\n            pass\n        return snap\n\n    def _load_session_from_file(self, path: str) -&gt; None:\n        \"\"\"Load a session JSON and rebuild the scene as much as possible.\n\n        If a dataset has `source_path`, it will be re-imported automatically.\n        \"\"\"\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n        except Exception as ex:\n            QtWidgets.QMessageBox.critical(self, \"Open error\", f\"Cannot read session: {ex}\")\n            return\n        # Reset current state\n        self._on_new_session()\n        self._session_path = path\n        # Restore viewer/app options (best effort)\n        try:\n            opts = data.get(\"options\", {})\n            self.downsample_method = opts.get(\"downsample_method\", self.downsample_method)\n            self.normals_fast_enabled = bool(opts.get(\"normals_fast_enabled\", getattr(self, \"normals_fast_enabled\", False)))\n            self.normals_k = int(opts.get(\"normals_k\", getattr(self, \"normals_k\", 16)))\n            self.normals_fast_max_points = int(opts.get(\"normals_fast_max_points\", getattr(self, \"normals_fast_max_points\", 250_000)))\n        except Exception:\n            pass\n        # Re-import datasets by source_path if available\n        restored = 0\n        for ds in data.get(\"datasets\", []):\n            src = ds.get(\"source_path\")\n            if src and os.path.exists(src):\n                try:\n                    # Use programmatic import if available\n                    if hasattr(self, \"import_cloud_programmatic\"):\n                        self.import_cloud_programmatic(src)\n                        restored += 1\n                except Exception:\n                    continue\n        try:\n            self.statusBar().showMessage(f\"Opened session: restored {restored} dataset(s)\", 5000)\n        except Exception:\n            pass\n\n    def _populate_plugins_ui(self) -&gt; None:\n        \"\"\"Riempi la combo e ricostruisci il men\u00f9 Plugins con le azioni esposte dai plugin.\"\"\"\n        items = self.plugin_manager.ui_combo_items()\n        self.comboPlugins.clear()\n        if not items:\n            self.comboPlugins.addItem(\"\u2014 No plugins installed \u2014\")\n            self.comboPlugins.setEnabled(False)\n        else:\n            self.comboPlugins.setEnabled(True)\n\n            color_map = {\n                \"red\": QtGui.QColor(\"#e53935\"),\n                \"green\": QtGui.QColor(\"#43a047\"),\n                \"gray\": QtGui.QColor(\"#9e9e9e\"),\n                \"black\": QtGui.QColor(\"#000000\"),\n            }\n\n            for it in items:\n                self.comboPlugins.addItem(it[\"label\"], userData=it.get(\"key\"))\n                idx = self.comboPlugins.count() - 1\n                # tooltip e colore\n                self.comboPlugins.setItemData(idx, it.get(\"tooltip\", \"\"), QtCore.Qt.ItemDataRole.ToolTipRole)\n                qcol = color_map.get(it.get(\"color\", \"black\"), color_map[\"black\"])\n                self.comboPlugins.setItemData(idx, qcol, QtCore.Qt.ItemDataRole.TextColorRole)\n                # disabilita se non disponibile\n                if not it.get(\"enabled\", True):\n                    mdl = self.comboPlugins.model()\n                    mitem = mdl.item(idx)\n                    if mitem is not None:\n                        mitem.setEnabled(False)\n\n        # Ricostruisci il men\u00f9 Plugins\n        try:\n            self._rebuild_plugins_menu(items)\n        except Exception:\n            pass\n\n    # --------------------- Plugins wiring ---------------------------------\n\n    def _plugin_context(self) -&gt; dict:\n        \"\"\"Contesto standard passato ai plugin.\"\"\"\n        return {\n            \"window\": self,\n            \"viewer3d\": getattr(self, \"viewer3d\", None),\n            \"mcts\": getattr(self, \"mcts\", {}),\n            \"mct\": getattr(self, \"mct\", {}),\n            \"current_dataset\": self._current_dataset_index(),\n            \"display\": getattr(self, \"displayPanel\", None),\n            \"console\": getattr(self, \"console\", None),\n            # aggiungi qui oggetti utili che i tuoi plugin si aspettano\n        }\n\n    @QtCore.Slot(int)\n    def _on_plugin_combo_activated(self, index: int) -&gt; None:\n        try:\n            key = self.comboPlugins.itemData(index)  # lo impostiamo in _populate_plugins_ui\n            if not key:\n                return\n            self._run_plugin_by_key(str(key))\n        except Exception as ex:\n            QtWidgets.QMessageBox.warning(self, \"Plugin\", f\"Cannot run plugin: {ex}\")\n\n    def _run_plugin_by_key(self, key: str) -&gt; None:\n        \"\"\"Trova il plugin per 'key' e prova ad eseguirlo in modo robusto (senza introspezione fragile).\"\"\"\n        try:\n            # 1) recupera l'oggetto plugin (lazy get)\n            plugin = None\n            for attr in (\"get\", \"plugin_by_key\"):\n                fn_get = getattr(self.plugin_manager, attr, None)\n                if callable(fn_get):\n                    plugin = fn_get(key)\n                    break\n\n            # fallback: guarda nella lista items se gi\u00e0 istanziato\n            if plugin is None:\n                try:\n                    for it in self.plugin_manager.ui_combo_items():\n                        if it.get(\"key\") == key and it.get(\"plugin_obj\") is not None:\n                            plugin = it[\"plugin_obj\"]\n                            break\n                except Exception:\n                    pass\n\n            if plugin is None:\n                QtWidgets.QMessageBox.warning(self, \"Plugin\", f\"Plugin '{key}' not found.\")\n                return\n\n            ctx = self._plugin_context()\n\n            # helper per chiamare callables in modo sicuro\n            def _call_safe(fn):\n                try:\n                    fn(ctx)\n                    return True\n                except TypeError:\n                    try:\n                        fn()\n                        return True\n                    except Exception:\n                        return False\n                except Exception:\n                    return False\n\n            # 2) se il plugin espone azioni strutturate, usale\n            actions = None\n            for attr in (\"actions\", \"get_actions\"):\n                getter = getattr(plugin, attr, None)\n                if callable(getter):\n                    try:\n                        actions = getter()\n                    except Exception:\n                        actions = None\n                    break\n\n            if isinstance(actions, (list, tuple)) and actions:\n                if len(actions) == 1:\n                    self._invoke_plugin_action(plugin, actions[0], ctx)\n                    return\n                menu = QtWidgets.QMenu(self)\n                for desc in actions:\n                    act = QtGui.QAction(str(desc.get(\"label\", \"Action\")), self)\n                    act.triggered.connect(lambda _=False, d=desc: self._invoke_plugin_action(plugin, d, ctx))\n                    menu.addAction(act)\n                pt = self.comboPlugins.mapToGlobal(QtCore.QPoint(0, self.comboPlugins.height()))\n                menu.exec(pt)\n                return\n\n            # 3) entry-point comuni del plugin (metodi d'istanza)\n            for attr in (\"run\", \"apply\", \"open\", \"open_dialog\", \"show\", \"__call__\"):\n                fn = getattr(plugin, attr, None)\n                if callable(fn) and _call_safe(fn):\n                    return\n\n            # 4) modulo con funzioni globali\n            import types\n            if isinstance(plugin, types.ModuleType):\n                for attr in (\"run\", \"main\"):\n                    fn = getattr(plugin, attr, None)\n                    if callable(fn) and _call_safe(fn):\n                        return\n\n            QtWidgets.QMessageBox.information(self, \"Plugin\", f\"Plugin '{key}' does not expose any known actions.\")\n        except Exception as ex:\n            QtWidgets.QMessageBox.critical(self, \"Plugin error\", str(ex))\n\n    def _invoke_plugin_action(self, plugin, action_desc, ctx: dict) -&gt; None:\n        \"\"\"Executes a single plugin action described as a dictionary:\n           {'label': 'Do X', 'slot': callable} or {'label': ..., 'method': 'run'}.\n        \"\"\"\n        try:\n            slot = action_desc.get(\"slot\")\n            if callable(slot):\n                # tenta (ctx) se il callable accetta argomenti\n                try:\n                    slot(ctx)\n                except TypeError:\n                    slot()\n                return\n            method_name = action_desc.get(\"method\") or action_desc.get(\"name\")\n            if method_name and hasattr(plugin, method_name):\n                fn = getattr(plugin, method_name)\n                try:\n                    fn(ctx)\n                except TypeError:\n                    fn()\n                return\n            # fallback: se c'\u00e8 'command' stringa e il plugin ha un dispatcher\n            cmd = action_desc.get(\"command\")\n            if cmd and hasattr(plugin, \"dispatch\"):\n                plugin.dispatch(cmd, ctx)\n                return\n            raise RuntimeError(\"Unsupported action descriptor\")\n        except Exception as ex:\n            QtWidgets.QMessageBox.critical(self, \"Plugin action error\", str(ex))\n\n    def _rebuild_plugins_menu(self, items: list[dict]) -&gt; None:\n        \"\"\"Rigenera il men\u00f9 &amp;Plugins con le azioni dei plugin.\"\"\"\n        if not hasattr(self, \"m_plugins\") or self.m_plugins is None:\n            return\n        self.m_plugins.clear()\n        if not items:\n            act = QtGui.QAction(\"No plugins installed\", self)\n            act.setEnabled(False)\n            self.m_plugins.addAction(act)\n            return\n\n        for it in items:\n            key = it.get(\"key\")\n            label = it.get(\"label\", key or \"Plugin\")\n            tooltip = it.get(\"tooltip\", \"\")\n            enabled = bool(it.get(\"enabled\", True))\n\n            submenu = QtWidgets.QMenu(label, self.m_plugins)\n            submenu.setEnabled(enabled)\n            if tooltip:\n                submenu.setToolTipsVisible(True)\n                submenu.setToolTip(tooltip)\n\n            # prova a ottenere il plugin e le sue azioni\n            plugin = None\n            get_fn = getattr(self.plugin_manager, \"get\", None)\n            if callable(get_fn):\n                try:\n                    plugin = get_fn(key)\n                except Exception:\n                    plugin = None\n            actions = None\n            if plugin is not None:\n                for attr in (\"actions\", \"get_actions\"):\n                    getter = getattr(plugin, attr, None)\n                    if callable(getter):\n                        try:\n                            actions = getter()\n                        except Exception:\n                            actions = None\n                        break\n\n            if isinstance(actions, (list, tuple)) and actions:\n                # crea QAction per ciascuna azione\n                for a in actions:\n                    q = QtGui.QAction(str(a.get(\"label\", \"Action\")), self)\n                    q.setToolTip(str(a.get(\"tooltip\", \"\")))\n                    q.triggered.connect(lambda _=False, plug=plugin, desc=a: self._invoke_plugin_action(plug, desc, self._plugin_context()))\n                    submenu.addAction(q)\n            else:\n                # azione di default: Run &lt;label&gt;\n                run_act = QtGui.QAction(f\"Run {label}\", self)\n                run_act.setToolTip(\"Execute default entry-point\")\n                run_act.triggered.connect(lambda _=False, k=key: self._run_plugin_by_key(k))\n                submenu.addAction(run_act)\n\n            self.m_plugins.addMenu(submenu)\n\n\n    def _on_undo_changed(self) -&gt; None:\n        self.act_undo.setEnabled(self.undo_stack.canUndo())\n        self.act_redo.setEnabled(self.undo_stack.canRedo())\n\n    def _console_context(self) -&gt; dict:\n        return {\"mcts\": self.mcts, \"mct\": self.mct, \"window\": self, \"undo_stack\": self.undo_stack}\n\n    def _on_import_cloud(self) -&gt; None:\n        \"\"\"Handle Import Cloud: open dialog, parse file, show summary, then add to scene &amp; tree.\"\"\"\n        dlg = QtWidgets.QFileDialog(self, \"Import point cloud / mesh\")\n        dlg.setFileMode(QtWidgets.QFileDialog.ExistingFile)\n        dlg.setNameFilters([\n            \"All supported (*.ply *.obj *.vtp *.stl *.vtk *.gltf *.glb *.las *.laz *.e57)\",\n            \"Point clouds (*.ply *.las *.laz *.e57)\",\n            \"Meshes (*.ply *.obj *.vtp *.stl *.vtk *.gltf *.glb)\",\n            \"All files (*)\",\n        ])\n        if not dlg.exec():\n            return\n        paths = dlg.selectedFiles()\n        if not paths:\n            return\n        path = paths[0]\n        # --- Start progress bar immediately (UI feedback before heavy I/O) ---\n        self._import_progress_begin(\"Opening file\u2026\")\n        try:\n            # Force the UI to repaint the progress bar before blocking I/O\n            QtWidgets.QApplication.processEvents()\n        except Exception:\n            pass\n\n        # Import\n        from .utils.io.importers import import_file\n        from .ui.import_summary_dialog import ImportSummaryDialog\n\n        try:\n            # Prefer importer with a progress callback (newer versions)\n            try:\n                objects = import_file(\n                    path,\n                    progress_cb=lambda p=None, msg=None: self._import_progress_update(\n                        p if p is not None else self.progress.value(),\n                        msg if msg is not None else \"Reading\u2026\"\n                    )\n                )\n            except TypeError:\n                # Fallback: older importer without progress_cb\n                objects = import_file(path)\n\n            # Give a final nudge to the bar/format before showing the summary\n            try:\n                self._import_progress_update(100, \"Parsing complete\")\n                QtWidgets.QApplication.processEvents()\n            except Exception:\n                pass\n\n        except Exception as ex:\n            # Make sure progress ends even on error\n            self._import_progress_end()\n            QtWidgets.QMessageBox.critical(self, \"Import error\", str(ex))\n            return\n\n        summary = ImportSummaryDialog(objects, self)\n        if summary.exec() != QtWidgets.QDialog.Accepted:\n            self._import_progress_end()\n            return\n\n        # Dopo aver letto le operazioni scelte dall\u2019utente:\n        ops = summary.operations()\n        self._import_progress_update(45, \"Applying options (axis / normals / budget)\u2026\")\n\n        # --- helpers -----------------------------------------------------\n        def _apply_axis_map(arr, axis_map):\n            \"\"\"Apply an axis remapping with sign to an (N,3) array.\n\n            Args:\n                arr: Points or normals array with shape (N, 3) or None.\n                axis_map: Dict like {'X': '+Y', 'Y': '-Z', 'Z': '+X'}.\n            Returns:\n                New array with same shape, or the original if None/error.\n            \"\"\"\n            try:\n                import numpy as _np\n                if arr is None:\n                    return None\n                src = _np.asarray(arr, dtype=float)\n                if src.ndim != 2 or src.shape[1] != 3:\n                    return arr\n                out = _np.empty_like(src)\n                axes = {\"X\": 0, \"Y\": 1, \"Z\": 2}\n                for tgt_key, expr in axis_map.items():\n                    sign = -1.0 if expr.startswith(\"-\") else 1.0\n                    src_axis = axes[expr[-1]]  # last char is X/Y/Z\n                    out[:, axes[tgt_key]] = sign * src[:, src_axis]\n                return out\n            except Exception:\n                return arr\n\n        def _compute_normals_for_points(P, k=16, subset=80000, fast=True):\n            \"\"\"Compute PCA normals for an (N,3) numpy array `P` without touching the viewer.\n\n            This avoids creating temporary datasets that would shift `_datasets` indices.\n            \"\"\"\n            import numpy as _np\n            from numpy.linalg import eigh as _eigh\n\n            P = _np.asarray(P, dtype=float)\n            if P.ndim != 2 or P.shape[1] != 3 or P.shape[0] == 0:\n                return None\n            n = P.shape[0]\n            k = int(max(3, min(k, n)))\n\n            # Try fast subset + nearest propagation when large and SciPy is available\n            if fast and n &gt; max(10000, subset):\n                try:\n                    from scipy.spatial import cKDTree as _KD  # type: ignore\n                    rng = _np.random.default_rng(42)\n                    idx_sub = rng.choice(n, size=subset, replace=False)\n                    Psub = P[idx_sub]\n\n                    tree_sub = _KD(Psub)\n                    # compute normals on subset\n                    Nsub = _np.empty_like(Psub)\n                    # kNN within subset\n                    _, knn_idx = tree_sub.query(Psub, k=min(k, Psub.shape[0]))\n                    if knn_idx.ndim == 1:\n                        knn_idx = knn_idx[:, None]\n                    for i in range(Psub.shape[0]):\n                        nbrs = Psub[knn_idx[i]]\n                        C = _np.cov(nbrs.T)\n                        w, v = _eigh(C)\n                        nrm = v[:, 0]\n                        if _np.dot(nrm, Psub[i] - nbrs.mean(axis=0)) &lt; 0:\n                            nrm = -nrm\n                        Nsub[i] = nrm\n                    # propagate to full set\n                    tree_full = _KD(Psub)\n                    _, j = tree_full.query(P, k=1)\n                    return Nsub[j]\n                except Exception:\n                    # fall back to full computation\n                    pass\n\n            # Full PCA normals (no SciPy dependency)\n            try:\n                # Brute-force kNN; for large N you may replace with a KD-tree if available\n                N = _np.empty_like(P)\n                for i in range(n):\n                    d2 = _np.sum((P - P[i]) ** 2, axis=1)\n                    sel = _np.argpartition(d2, kth=k-1)[:k]\n                    nbrs = P[sel]\n                    C = _np.cov(nbrs.T)\n                    w, v = _eigh(C)\n                    nrm = v[:, 0]\n                    if _np.dot(nrm, P[i] - nbrs.mean(axis=0)) &lt; 0:\n                        nrm = -nrm\n                    N[i] = nrm\n                return N\n            except Exception:\n                return None\n        # -----------------------------------------------------------------\n\n        # 1) Apply axis mapping / normals ops per object (before downsampling)\n        for obj, spec in zip(objects, ops):\n            # Points mapping\n            obj.points = _apply_axis_map(obj.points, spec['axis_map'])\n            # Normals mapping or compute if missing\n            if spec.get('map_normals', True):\n                if getattr(obj, 'normals', None) is not None:\n                    obj.normals = _apply_axis_map(obj.normals, spec['axis_map'])\n                elif spec.get('compute_normals_if_missing', False):\n                    n = _compute_normals_for_points(obj.points, k=int(getattr(self, \"normals_k\", 16)))\n                    if n is not None:\n                        obj.normals = n\n                    if n is not None:\n                        obj.normals = n\n            # Store color preference for later use\n            obj.meta['color_preference'] = spec.get('color_preference', 'rgb')\n\n        # SUGGESTED VIEW BUDGET (cap as hint): compute a percent based on total visible points\n        try:\n            import sys\n            # Count current visible points in the viewer\n            total_current = 0\n            try:\n                for _rec in getattr(self.viewer3d, \"_datasets\", []):\n                    if not _rec.get(\"visible\", True):\n                        continue\n                    fp = _rec.get(\"full_pdata\", _rec.get(\"pdata\"))\n                    if hasattr(fp, \"n_points\"):\n                        total_current += int(fp.n_points)\n            except Exception:\n                total_current = 0\n\n            # Count incoming points (post axis-map but pre downsampling)\n            total_incoming = 0\n            try:\n                for _o in objects:\n                    if _o.kind == \"points\" and _o.points is not None:\n                        total_incoming += int(_o.points.shape[0])\n            except Exception:\n                pass\n\n            total_after = max(1, total_current + total_incoming)\n\n            # Heuristic caps similar to viewer3d (_target_visible_points)\n            points_as_spheres = bool(getattr(self.viewer3d, \"_points_as_spheres\", False))\n            if sys.platform == \"darwin\":\n                cap = 600_000 if points_as_spheres else 2_000_000\n            else:\n                cap = 2_200_000 if points_as_spheres else 8_000_000\n\n            suggested = min(100, max(1, int(cap * 100 / total_after)))\n\n            # Update UI slider and viewer with suggested percent (user can override later)\n            try:\n                if hasattr(self.displayPanel, \"spinBudget\") and self.displayPanel.spinBudget is not None:\n                    self.displayPanel.spinBudget.blockSignals(True)\n                    self.displayPanel.spinBudget.setValue(suggested)\n                    self.displayPanel.spinBudget.blockSignals(False)\n            except Exception:\n                pass\n            try:\n                getattr(self.viewer3d, \"set_point_budget\", lambda *_: None)(suggested)\n            except Exception:\n                pass\n        except Exception:\n            pass\n\n        # 2) Apply point budget on import (from Display panel)\n        try:\n            budget = int(getattr(self.displayPanel, \"spinBudget\", None).value())\n        except Exception:\n            budget = 100\n\n        if budget &lt; 100:\n            from .utils.io.importers import downsample_random, downsample_voxel_auto\n            for obj in objects:\n                if obj.kind == \"points\" and obj.points is not None and obj.points.shape[0] &gt; 0:\n                    n0 = obj.points.shape[0]\n                    if self.downsample_method == \"voxel\":\n                        idx = downsample_voxel_auto(obj.points, budget)\n                    else:\n                        idx = downsample_random(obj.points, budget)\n                    obj.points = obj.points[idx]\n                    if obj.colors is not None and obj.colors.shape[0] == n0:\n                        obj.colors = obj.colors[idx]\n                    if obj.intensity is not None and obj.intensity.shape[0] == n0:\n                        obj.intensity = obj.intensity[idx]\n                    if getattr(obj, 'normals', None) is not None and obj.normals.shape[0] == n0:\n                        obj.normals = obj.normals[idx]\n                    obj.meta[\"downsample\"] = {\"method\": self.downsample_method, \"percent\": budget, \"kept\": int(obj.points.shape[0])}\n\n        self._import_progress_update(65, \"Adding objects to the scene\u2026\")\n\n        # 3) Add transformed objects to the viewer honoring color preference\n        for obj in objects:\n            # Temporarily adjust viewer color mode according to preference\n            try:\n                prev_mode = getattr(self.viewer3d, '_color_mode', None)\n                pref = obj.meta.get('color_preference', 'rgb')\n                if pref == 'colormap':\n                    self.viewer3d.set_color_mode('Normal Colormap')\n                else:\n                    self.viewer3d.set_color_mode('Normal RGB')\n            except Exception:\n                prev_mode = None\n\n            if obj.kind == \"points\" and obj.points is not None:\n                ds_index = self.viewer3d.add_points(\n                    obj.points, obj.colors, getattr(obj, \"normals\", None)\n                )\n            elif obj.kind == \"mesh\" and obj.pv_mesh is not None:\n                ds_index = self.viewer3d.add_pyvista_mesh(obj.pv_mesh)\n\n            try:\n                self._reapply_overlays_safe()\n            except Exception:\n                pass\n\n            # Tree: hierarchical, checkable, with metadata.\n            self.treeMCTS.blockSignals(True)\n            root = QtWidgets.QTreeWidgetItem([obj.name])\n            root.setFlags(\n                root.flags()\n                | QtCore.Qt.ItemFlag.ItemIsUserCheckable\n                | QtCore.Qt.ItemFlag.ItemIsAutoTristate\n            )\n            root.setCheckState(0, QtCore.Qt.CheckState.Checked)\n            self.treeMCTS.addTopLevelItem(root)\n\n            if obj.kind == \"points\":\n                # Point cloud child\n                it_points = QtWidgets.QTreeWidgetItem([\"Point cloud\"])\n                it_points.setFlags(\n                    it_points.flags()\n                    | QtCore.Qt.ItemFlag.ItemIsUserCheckable\n                    # | QtCore.Qt.ItemFlag.ItemIsAutoTristate\n                )\n                it_points.setCheckState(0, QtCore.Qt.CheckState.Checked)\n                it_points.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"points\", \"ds\": ds_index})\n                root.addChild(it_points)\n                # Normals child (if available)\n                if getattr(obj, \"normals\", None) is not None:\n                    it_normals = QtWidgets.QTreeWidgetItem([\"Normals\"])\n                    it_normals.setFlags(\n                        it_normals.flags() | QtCore.Qt.ItemFlag.ItemIsUserCheckable\n                    )\n                    it_normals.setCheckState(0, QtCore.Qt.CheckState.Unchecked)\n                    it_normals.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"normals\", \"ds\": ds_index})\n                    it_points.addChild(it_normals)\n            else:\n                # Mesh node\n                it_mesh = QtWidgets.QTreeWidgetItem([\"Mesh\"])\n                it_mesh.setFlags(it_mesh.flags() | QtCore.Qt.ItemFlag.ItemIsUserCheckable)\n                it_mesh.setCheckState(0, QtCore.Qt.CheckState.Checked)\n                it_mesh.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"mesh\", \"ds\": ds_index})\n                root.addChild(it_mesh)\n\n            # Unblock signals after building the subtree\n            self.treeMCTS.blockSignals(False)\n\n            # Register into MCTS and set current MCT so it's visible in console\n            try:\n                entry = {\n                    \"name\": obj.name,\n                    \"kind\": obj.kind,\n                    \"has_rgb\": obj.colors is not None,\n                    \"has_intensity\": getattr(obj, 'intensity', None) is not None,\n                    \"has_normals\": getattr(obj, 'normals', None) is not None,\n                    \"ds_index\": ds_index,\n                    \"source_path\": path,  # keep original file path for session reopen\n                }\n                if obj.kind == \"points\":\n                    entry.update(\n                        {\n                            \"point_size\": getattr(self.viewer3d, \"_point_size\", 3),\n                            \"point_budget\": getattr(\n                                self.viewer3d, \"_view_budget_percent\", 100\n                            ),\n                            \"color_mode\": getattr(self.viewer3d, \"_color_mode\", \"Normal RGB\"),\n                            \"colormap\": getattr(self.viewer3d, \"_cmap\", \"viridis\"),\n                            \"solid_color\": self.viewer3d._datasets[ds_index].get(\n                                \"solid_color\", (1.0, 1.0, 1.0)\n                            ),\n                            \"points_as_spheres\": getattr(\n                                self.viewer3d, \"_points_as_spheres\", False\n                            ),\n                        }\n                    )\n                else:\n                    entry.update(\n                        {\n                            \"representation\": \"Surface\",\n                            \"opacity\": 100,\n                            \"solid_color\": (1.0, 1.0, 1.0),\n                        }\n                    )\n                self.mcts[obj.name] = entry\n                self.mct = entry\n                # Always select and check the \"Point cloud\" node if it exists\n                selected = root\n                for i in range(root.childCount()):\n                    child = root.child(i)\n                    data = child.data(0, QtCore.Qt.ItemDataRole.UserRole)\n                    if isinstance(data, dict) and data.get(\"kind\") == \"points\":\n                        child.setCheckState(0, QtCore.Qt.CheckState.Checked)\n                        selected = child\n                        break\n                try:\n                    self.treeMCTS.setCurrentItem(selected)\n                except Exception:\n                    pass\n            except Exception:\n                pass\n\n            self.statusBar().showMessage(f\"Imported {len(objects)} object(s) from {path}\", 5000)\n            # \n            self._refresh_tree_visibility()\n            try:\n                self._reapply_overlays_safe()\n            except Exception:\n                pass\n            self._import_progress_update(100, \"Import finished\")\n            self._import_progress_end()\n            try:\n                if self.progress.value() &lt; 100:\n                    self._import_progress_end()\n            except Exception:\n                pass\n\n\n    def _refresh_tree_visibility(self) -&gt; None:\n        \"\"\"Sync visibility of all datasets from the tree using 'effective checked' (node and all ancestors).\"\"\"\n        if self.treeMCTS.topLevelItemCount() == 0:\n            return\n\n        def recurse(node: QtWidgets.QTreeWidgetItem) -&gt; None:\n            data = node.data(0, QtCore.Qt.ItemDataRole.UserRole)\n            eff_on = self._is_effectively_checked(node)\n            if isinstance(data, dict) and data.get(\"ds\") is not None:\n                ds = int(data.get(\"ds\"))\n                kind = data.get(\"kind\") or \"points\"\n                # If this is the \"Normals\" child node, toggle normals only.\n                if node.text(0) == \"Normals\" or data.get(\"normals_node\", False):\n                    try:\n                        getattr(self.viewer3d, \"set_normals_visibility\", lambda *_: None)(ds, bool(eff_on))\n                    except Exception:\n                        pass\n                else:\n                    self._viewer_set_visibility(kind, ds, bool(eff_on))\n                    # Safety: if points are off, ensure normals off too\n                    if kind == \"points\" and not eff_on:\n                        try:\n                            getattr(self.viewer3d, \"set_normals_visibility\", lambda *_: None)(ds, False)\n                        except Exception:\n                            pass\n\n            for i in range(node.childCount()):\n                recurse(node.child(i))\n\n        self._tree_updating = True\n        try:\n            for i in range(self.treeMCTS.topLevelItemCount()):\n                recurse(self.treeMCTS.topLevelItem(i))\n        finally:\n            self._tree_updating = False\n\n\n    def _on_tree_item_changed(self, item: QtWidgets.QTreeWidgetItem) -&gt; None:\n        \"\"\"\n        TEMP: do not propagate check state between parent/children.\n        Simply schedule a single full-scene rebuild from current tree state.\n        \"\"\"\n        # Evita rientranze/ricorsioni\n        if getattr(self, \"_tree_updating\", False):\n            return\n        # Assicurati non sia tristate; non toccare parent/children\n        try:\n            self._tree_updating = True\n            item.setFlags((item.flags() | QtCore.Qt.ItemFlag.ItemIsUserCheckable) &amp; ~QtCore.Qt.ItemFlag.ItemIsTristate)\n        except Exception:\n            pass\n        finally:\n            self._tree_updating = False\n        # Debounced full-scene rebuild\n        self._schedule_scene_rebuild()\n\n    def _update_parent_checkstate(self, child: QtWidgets.QTreeWidgetItem) -&gt; None:\n        \"\"\"\n        Update ancestors according to these rules:\n        - If a parent has a 'points' child, the parent's state follows ONLY the state of 'points'.\n        - Otherwise: Checked if all children are Checked; Unchecked if all are Unchecked; otherwise PartiallyChecked.\n        - Does NOT modify children (no downward propagation here).\n        \"\"\"\n        if child is None:\n            return\n\n        self._tree_updating = True\n        try:\n            parent = child.parent()\n            while parent is not None:\n                # 1) prova la regola \"point-centric\"\n                points_child = None\n                for i in range(parent.childCount()):\n                    c = parent.child(i)\n                    data = c.data(0, QtCore.Qt.ItemDataRole.UserRole)\n                    if isinstance(data, dict) and data.get(\"kind\") == \"points\":\n                        points_child = c\n                        break\n\n                if points_child is not None:\n                    # Il parent segue SOLO lo stato del figlio \"points\"\n                    parent.setCheckState(0, points_child.checkState(0))\n                else:\n                    # 2) fallback: tri-stato classico basato su tutti i figli\n                    total = parent.childCount()\n                    if total == 0:\n                        break\n                    checked = 0\n                    unchecked = 0\n                    for i in range(total):\n                        st = parent.child(i).checkState(0)\n                        if st == QtCore.Qt.CheckState.Checked:\n                            checked += 1\n                        elif st == QtCore.Qt.CheckState.Unchecked:\n                            unchecked += 1\n                    if checked == total:\n                        parent.setCheckState(0, QtCore.Qt.CheckState.Checked)\n                    elif unchecked == total:\n                        parent.setCheckState(0, QtCore.Qt.CheckState.Unchecked)\n                    else:\n                        parent.setCheckState(0, QtCore.Qt.CheckState.PartiallyChecked)\n\n                parent = parent.parent()\n        finally:\n            self._tree_updating = False\n\n    def _uncheck_descendants(self, item: QtWidgets.QTreeWidgetItem) -&gt; None:\n        \"\"\"Spegni solo i discendenti (non accende nulla).\"\"\"\n        for i in range(item.childCount()):\n            child = item.child(i)\n            if child.checkState(0) != QtCore.Qt.CheckState.Unchecked:\n                child.setCheckState(0, QtCore.Qt.CheckState.Unchecked)\n            self._uncheck_descendants(child)\n\n    def _set_descendant_checkstate(\n        self, item: QtWidgets.QTreeWidgetItem, state: QtCore.Qt.CheckState\n        ) -&gt; None:\n        \"\"\"Set the check state of all descendants.\"\"\"\n        for i in range(item.childCount()):\n            child = item.child(i)\n            child.setCheckState(0, state)\n            self._set_descendant_checkstate(child, state)\n\n    # def _is_effectively_checked(self, item: QtWidgets.QTreeWidgetItem) -&gt; bool:\n    #     \"\"\"\n    #     Visible if *this* item is Checked and no ancestor is Unchecked.\n\n    #     - The current item must be Qt.Checked.\n    #     - Ancestors with Qt.PartiallyChecked do NOT block their children.\n    #     - An ancestor with Qt.Unchecked disables all its descendants.\n    #     \"\"\"\n    #     if item is None or item.checkState(0) != QtCore.Qt.CheckState.Checked:\n    #         return False\n    #     parent = item.parent()\n    #     while parent is not None:\n    #         if parent.checkState(0) == QtCore.Qt.CheckState.Unchecked:\n    #             return False\n    #         parent = parent.parent()\n    #     return True\n    def _is_effectively_checked(self, item: QtWidgets.QTreeWidgetItem) -&gt; bool:\n        \"\"\"\n        Return True if `item` and **all** its ancestors are checked.\n        This ensures children cannot remain logically 'on' if a parent is 'off'.\n        \"\"\"\n        cur = item\n        while cur is not None:\n            try:\n                if cur.checkState(0) != QtCore.Qt.CheckState.Checked:\n                    return False\n            except Exception:\n                return False\n            cur = cur.parent()\n        return True\n\n    def _on_tree_context_menu(self, pos: QtCore.QPoint) -&gt; None:\n        item = self.treeMCTS.itemAt(pos)\n        if item is None:\n            return\n        data = item.data(0, QtCore.Qt.ItemDataRole.UserRole)\n        if not isinstance(data, dict):\n            return\n        # Consentire la modifica del colore solo per i nodi della nuvola di punti.\n        # Only allow color edit for point cloud nodes.\n        if data.get(\"kind\") != \"points\":\n            return\n        ds = data.get(\"ds\")\n        if ds is None:\n            return\n        menu = QtWidgets.QMenu(self)\n        act_color = menu.addAction(\"Set Color\u2026\")\n        act_random = menu.addAction(\"Random Color\")\n        chosen = menu.exec(self.treeMCTS.viewport().mapToGlobal(pos))\n        if chosen is None:\n            return\n        if chosen is act_color:\n            col = QtWidgets.QColorDialog.getColor(parent=self, title=\"Choose color for point cloud\")\n            if col.isValid():\n                getattr(self.viewer3d, \"set_dataset_color\", lambda *_: None)(ds, col.red(), col.green(), col.blue())\n        elif chosen is act_random:\n            import random\n            r, g, b = [random.randint(32, 224) for _ in range(3)]\n            getattr(self.viewer3d, \"set_dataset_color\", lambda *_: None)(ds, r, g, b)\n\n    # ------------------------------------------------------------------\n    # Test / Esecutore di script\n    # Testing / Script runner\n    # ------------------------------------------------------------------\n    def _on_run_script(self) -&gt; None:\n        \"\"\"Open a .py file and execute it inside the console context.\n\n        The script has access to: mcts, mct, window, undo_stack and a helper\n        function `import_cloud(path, **kwargs)` (see `import_cloud_programmatic`).\n        \"\"\"\n        dlg = QtWidgets.QFileDialog(self, \"Select Python script to run\")\n        dlg.setFileMode(QtWidgets.QFileDialog.ExistingFile)\n        dlg.setNameFilters([\"Python scripts (*.py)\", \"All files (*)\"])\n        # Default to tests/ directory if it exists\n        project_root = os.path.dirname(os.path.dirname(__file__))\n        tests_dir = os.path.abspath(os.path.join(project_root, \"tests\"))\n        if os.path.isdir(tests_dir):\n            dlg.setDirectory(tests_dir)\n        if not dlg.exec():\n            return\n        sel = dlg.selectedFiles()\n        if not sel:\n            return\n        self._exec_script_file(sel[0])\n\n    def _exec_script_file(self, path: str) -&gt; None:\n        \"\"\"Execute a Python file in the same context used by the console.\n\n        Args:\n            path: path to a .py file\n        \"\"\"\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                code = f.read()\n        except Exception as ex:\n            QtWidgets.QMessageBox.critical(self, \"Script error\", f\"Cannot read script: {ex}\")\n            return\n\n        # Build execution context\n        ctx = dict(self._console_context())\n        ctx.setdefault(\"window\", self)\n        ctx.setdefault(\"import_cloud\", self.import_cloud_programmatic)\n        try:\n            import numpy as _np  # noqa: F401\n            ctx.setdefault(\"np\", _np)\n        except Exception:\n            pass\n        try:\n            import pyvista as _pv  # noqa: F401\n            ctx.setdefault(\"pv\", _pv)\n        except Exception:\n            pass\n        ctx.setdefault(\"QtWidgets\", QtWidgets)\n        ctx.setdefault(\"QtCore\", QtCore)\n        ctx.setdefault(\"QtGui\", QtGui)\n\n        # Provide dunder variables for compatibility\n        ctx[\"__file__\"] = path\n        ctx[\"__name__\"] = \"__main__\"\n        ctx[\"__package__\"] = None\n\n        # Allow relative imports and relative paths like in a normal script\n        import sys\n        script_dir = os.path.dirname(os.path.abspath(path))\n        project_root = os.path.dirname(os.path.dirname(__file__))\n        tests_dir = os.path.abspath(os.path.join(project_root, \"tests\"))\n        old_cwd = os.getcwd()\n        try:\n            # Update sys.path\n            for pth in (script_dir, tests_dir, project_root):\n                if pth and pth not in sys.path:\n                    sys.path.insert(0, pth)\n            # Run with the script's folder as CWD\n            os.chdir(script_dir)\n\n            compiled = compile(code, path, \"exec\")\n            exec(compiled, ctx, ctx)\n            self.statusBar().showMessage(f\"Executed script: {os.path.basename(path)}\", 4000)\n        except Exception as ex:\n            QtWidgets.QMessageBox.critical(self, \"Script execution error\", str(ex))\n        finally:\n            # Restore working directory\n            try:\n                os.chdir(old_cwd)\n            except Exception:\n                pass\n\n    def _on_run_tests_triplet(self) -&gt; None:\n        \"\"\"Convenience: import the three example PLYs from tests/ directory.\"\"\"\n        project_root = os.path.dirname(os.path.dirname(__file__))\n        tests_dir = os.path.abspath(os.path.join(project_root, \"tests\"))\n        files = [\n            \"test_1_Corinthian_Column_Capital_RGB_no_normals.ply\",\n            \"test_2_Rocca_North_tower_no_RGB.ply\",\n            \"test_3_Turkish_pillar_RGB_normals.ply\",\n        ]\n        missing = []\n        for name in files:\n            p = os.path.join(tests_dir, name)\n            if os.path.isfile(p):\n                try:\n                    self.import_cloud_programmatic(p)\n                except Exception as ex:\n                    QtWidgets.QMessageBox.critical(self, \"Import error\", f\"{name}: {ex}\")\n                    return\n            else:\n                missing.append(name)\n        if missing:\n            QtWidgets.QMessageBox.warning(self, \"Missing files\", \"\\n\".join([\"Not found in tests/:\", *missing]))\n        else:\n            self.statusBar().showMessage(\"Triplet import completed\", 4000)\n\n    # ------------------------------------------------------------------\n    # Programmatic import (no dialog)\n    # ------------------------------------------------------------------\n    def import_cloud_programmatic(\n        self,\n        path: str,\n        *,\n        axis_preset: str = \"Z-up (identity)\",\n        color_preference: str = \"auto\",\n        compute_normals_if_missing: bool = True,\n        map_normals: bool = True,\n    ) -&gt; None:\n        \"\"\"Import a geometry file without showing the summary dialog.\n\n        Mirrors `_on_import_cloud` pipeline with sensible defaults:\n        - axis_preset: one of the presets in the summary dialog\n        - color_preference: 'auto' | 'rgb' | 'colormap'\n        - compute_normals_if_missing: compute rough normals if absent\n        - map_normals: if True, apply axis preset also to normals\n        \"\"\"\n        from .utils.io.importers import import_file\n\n        # Presets consistent with ImportSummaryDialog\n        presets = {\n            \"Z-up (identity)\":  {\"X\": \"+X\", \"Y\": \"+Y\", \"Z\": \"+Z\"},\n            \"Y-up (swap Y/Z)\":  {\"X\": \"+X\", \"Y\": \"+Z\", \"Z\": \"-Y\"},\n            \"X-up (swap X/Z)\":  {\"X\": \"+Z\", \"Y\": \"+Y\", \"Z\": \"-X\"},\n            \"Flip Z\":           {\"X\": \"+X\", \"Y\": \"+Y\", \"Z\": \"-Z\"},\n            \"Flip Y\":           {\"X\": \"+X\", \"Y\": \"-Y\", \"Z\": \"+Z\"},\n            \"Flip X\":           {\"X\": \"-X\", \"Y\": \"+Y\", \"Z\": \"+Z\"},\n        }\n        axis_map = presets.get(axis_preset, presets[\"Z-up (identity)\"])\n\n        try:\n            objects = import_file(path)\n        except Exception as ex:\n            raise RuntimeError(f\"Import error: {ex}\")\n\n        # Helpers (reuse lambdas from _on_import_cloud but kept local here)\n        def _apply_axis_map(arr, axis_map):\n            try:\n                import numpy as _np\n                if arr is None:\n                    return None\n                src = _np.asarray(arr, dtype=float)\n                if src.ndim != 2 or src.shape[1] != 3:\n                    return arr\n                out = _np.empty_like(src)\n                axes = {\"X\": 0, \"Y\": 1, \"Z\": 2}\n                for tgt_key, expr in axis_map.items():\n                    sign = -1.0 if expr.startswith(\"-\") else 1.0\n                    src_axis = axes[expr[-1]]\n                    out[:, axes[tgt_key]] = sign * src[:, src_axis]\n                return out\n            except Exception:\n                return arr\n\n        def _compute_normals(obj):\n            try:\n                import numpy as _np\n                import pyvista as _pv  # type: ignore\n                if obj.points is None or obj.points.shape[0] == 0:\n                    return None\n                pdata = _pv.PolyData(_np.asarray(obj.points))\n                pdata = pdata.compute_normals(\n                    consistent=False,\n                    auto_orient_normals=False,\n                    feature_angle=180.0,\n                )\n                n = getattr(pdata, 'point_normals', None)\n                if n is not None:\n                    return _np.asarray(n, dtype=_np.float32)\n            except Exception:\n                return None\n            return None\n\n        # 1) Apply axis mapping / normals ops per object\n        for obj in objects:\n            obj.points = _apply_axis_map(obj.points, axis_map)\n            if map_normals and getattr(obj, 'normals', None) is not None:\n                obj.normals = _apply_axis_map(obj.normals, axis_map)\n            elif compute_normals_if_missing and getattr(obj, 'normals', None) is None:\n                n = _compute_normals(obj)\n                if n is not None:\n                    obj.normals = n\n            # Color preference per object (auto: prefer RGB if available)\n            if color_preference == \"auto\":\n                obj.meta['color_preference'] = 'rgb' if obj.colors is not None else 'colormap'\n            else:\n                obj.meta['color_preference'] = color_preference\n\n        # 2) Reuse the final part of the GUI pipeline to add to viewer &amp; tree\n        # Temporarily set viewer color-mode per object, as in _on_import_cloud\n        for obj in objects:\n            prev_mode = getattr(self.viewer3d, '_color_mode', None)\n            try:\n                pref = obj.meta.get('color_preference', 'rgb')\n                if pref == 'colormap':\n                    self.viewer3d.set_color_mode('Normal Colormap')\n                else:\n                    self.viewer3d.set_color_mode('Normal RGB')\n            except Exception:\n                prev_mode = None\n\n            if obj.kind == \"points\" and obj.points is not None:\n                ds_index = self.viewer3d.add_points(obj.points, obj.colors, getattr(obj, \"normals\", None))\n            elif obj.kind == \"mesh\" and obj.pv_mesh is not None:\n                ds_index = self.viewer3d.add_pyvista_mesh(obj.pv_mesh)\n            else:\n                ds_index = None\n\n            try:\n                self._reapply_overlays_safe()\n            except Exception:\n                pass\n            try:\n                if prev_mode is not None:\n                    self.viewer3d.set_color_mode(prev_mode)\n            except Exception:\n                pass\n\n            # \n            # Build the tree entries (same as interactive import)\n            self.treeMCTS.blockSignals(True)\n            root = QtWidgets.QTreeWidgetItem([obj.name])\n            root.setFlags(\n                root.flags()\n                | QtCore.Qt.ItemFlag.ItemIsUserCheckable\n                | QtCore.Qt.ItemFlag.ItemIsAutoTristate\n            )\n            root.setCheckState(0, QtCore.Qt.CheckState.Checked)\n            self.treeMCTS.addTopLevelItem(root)\n\n            if obj.kind == \"points\":\n                it_points = QtWidgets.QTreeWidgetItem([\"Point cloud\"])\n                it_points.setFlags(\n                    it_points.flags()\n                    | QtCore.Qt.ItemFlag.ItemIsUserCheckable\n                    # | QtCore.Qt.ItemFlag.ItemIsAutoTristate\n                )\n                it_points.setCheckState(0, QtCore.Qt.CheckState.Checked)\n                it_points.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"points\", \"ds\": ds_index})\n                root.addChild(it_points)\n\n                if getattr(obj, \"normals\", None) is not None:\n                    it_normals = QtWidgets.QTreeWidgetItem([\"Normals\"])\n                    it_normals.setFlags(\n                        it_normals.flags() | QtCore.Qt.ItemFlag.ItemIsUserCheckable\n                    )\n                    it_normals.setCheckState(0, QtCore.Qt.CheckState.Unchecked)\n                    it_normals.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"normals\", \"ds\": ds_index})\n                    it_points.addChild(it_normals)\n            else:\n                it_mesh = QtWidgets.QTreeWidgetItem([\"Mesh\"])\n                it_mesh.setFlags(it_mesh.flags() | QtCore.Qt.ItemFlag.ItemIsUserCheckable)\n                it_mesh.setCheckState(0, QtCore.Qt.CheckState.Checked)\n                it_mesh.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"mesh\", \"ds\": ds_index})\n                root.addChild(it_mesh)\n\n            self.treeMCTS.blockSignals(False)\n            # \n            # Update visibility after adding.\n            self._refresh_tree_visibility()\n\n            # Register into MCTS and set current MCT so it's visible in console\n            try:\n                entry = {\n                    \"name\": obj.name,\n                    \"kind\": obj.kind,\n                    \"has_rgb\": obj.colors is not None,\n                    \"has_intensity\": getattr(obj, 'intensity', None) is not None,\n                    \"has_normals\": getattr(obj, 'normals', None) is not None,\n                    \"ds_index\": ds_index if (obj.kind == 'points' and ds_index is not None) else None,\n                }\n                self.mcts[obj.name] = entry\n                self.mct = entry\n                try:\n                    self.treeMCTS.setCurrentItem(root)\n                except Exception:\n                    pass\n            except Exception:\n                pass\n\n        self.statusBar().showMessage(f\"Imported from {os.path.basename(path)}\", 3000)\n\n    # ----------------------- Normals: UI helpers ----------------------------\n    def _invoke_set_progress_value(self, v: int) -&gt; None:\n        try:\n            val = int(v)\n            QtCore.QTimer.singleShot(0, lambda: self.progress.setValue(val))\n        except Exception:\n            pass\n\n    def _invoke_set_progress_format(self, text: str) -&gt; None:\n        try:\n            msg = str(text)\n            QtCore.QTimer.singleShot(0, lambda: self.progress.setFormat(msg))\n        except Exception:\n            pass\n\n    def _invoke_append_message(self, text: str) -&gt; None:\n        try:\n            msg = str(text)\n            QtCore.QTimer.singleShot(0, lambda: self.txtMessages.appendPlainText(msg))\n        except Exception:\n            pass\n\n    def _append_message(self, text: str) -&gt; None:\n        self._invoke_append_message(text)\n\n    # def _progress_start(self, text: str) -&gt; None:\n    #     try:\n    #         self.progress.setRange(0, 100)\n    #         self._invoke_set_progress_value(0)\n    #         self._invoke_set_progress_format(text)\n    #     except Exception:\n    #         pass\n\n    def _progress_update(self, value: int, text: Optional[str] = None) -&gt; None:\n        try:\n            v = max(0, min(100, int(value)))\n            self._invoke_set_progress_value(v)\n            if text is not None:\n                self._invoke_set_progress_format(text)\n        except Exception:\n            pass\n\n    # def _progress_finish(self, text: str) -&gt; None:\n    #     try:\n    #         self._invoke_set_progress_value(100)\n    #         self._invoke_set_progress_format(text)\n    #     except Exception:\n    #         pass\n\n    # @QtCore.Slot(int)\n    # def _slot_worker_progress(self, pct: int) -&gt; None:\n    #     try:\n    #         txt = getattr(self, \"_last_progress_text\", \"\")\n    #         v = max(0, min(100, int(pct)))\n    #         self._progress_update(v, txt)\n    #     except Exception:\n    #         pass\n\n    # @QtCore.Slot(str)\n    # def _slot_worker_message(self, msg: str) -&gt; None:\n    #     try:\n    #         self._last_progress_text = str(msg)\n    #         self._invoke_set_progress_format(self._last_progress_text)\n    #         self._invoke_append_message(self._last_progress_text)\n    #     except Exception:\n    #         pass\n\n    # def _ensure_cancel_button(self) -&gt; None:\n    #     \"\"\"Enable the CANCEL button for an active job.\"\"\"\n    #     try:\n    #         self.btnCancel.setEnabled(True)\n    #     except Exception:\n    #         pass\n\n    # def _on_cancel_job(self) -&gt; None:\n    #     \"\"\"Request cancellation of the active job, if supported by the worker.\"\"\"\n    #     job = getattr(self, \"_active_job\", None)\n    #     if not job:\n    #         return\n    #     worker = job.get(\"worker\")\n    #     if hasattr(worker, \"request_cancel\"):\n    #         worker.request_cancel()\n    #     self._append_message(\"[Job] Cancel requested by user.\")\n\n    def _ensure_normals_tree_child(self, ds_index: int) -&gt; None:\n        \"\"\"Ensure a 'Normals' child exists under the current file node for the active dataset.\"\"\"\n        try:\n            item = self.treeMCTS.currentItem()\n            if item is None:\n                return\n            # Ascend to root file node\n            root = item\n            while root.parent() is not None:\n                root = root.parent()\n            # Look for a child labeled 'Point cloud' or existing 'Normals'\n            target = None\n            for i in range(root.childCount()):\n                c = root.child(i)\n                if c.text(0) == \"Point cloud\":\n                    target = c\n                if c.text(0) == \"Normals\":\n                    return  # already present at root level (older structure)\n            if target is None:\n                # Create the 'Point cloud' node if missing\n                target = QtWidgets.QTreeWidgetItem([\"Point cloud\"])\n                target.setFlags(target.flags() | QtCore.Qt.ItemFlag.ItemIsUserCheckable | QtCore.Qt.ItemFlag.ItemIsAutoTristate)\n                target.setCheckState(0, QtCore.Qt.CheckState.Checked)\n                target.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"points\", \"ds\": ds_index})\n                root.addChild(target)\n            # Add Normals child if not present\n            for i in range(target.childCount()):\n                if target.child(i).text(0) == \"Normals\":\n                    return\n            it_normals = QtWidgets.QTreeWidgetItem([\"Normals\"])\n            it_normals.setFlags(it_normals.flags() | QtCore.Qt.ItemFlag.ItemIsUserCheckable)\n            it_normals.setCheckState(0, QtCore.Qt.CheckState.Unchecked)\n            it_normals.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"normals\", \"ds\": ds_index})\n            target.addChild(it_normals)\n        except Exception:\n            pass\n\n\n    # --------- Normals: helpers ---------------------------------------------\n\n    def _current_ds_index(self) -&gt; int | None:\n        \"\"\"Return the current dataset index or None if nothing is selected.\"\"\"\n        try:\n            ds = self._current_dataset_index()\n            return int(ds) if ds is not None else None\n        except Exception:\n            return None\n\n    def _ensure_normals_visible(self, ds: int) -&gt; None:\n        \"\"\"Ensure normals actor exists/visible for dataset ds before applying edits.\"\"\"\n        v3d = self.viewer3d\n        # Prova API moderna\n        set_vis = getattr(v3d, \"set_normals_visibility\", None)\n        if callable(set_vis):\n            set_vis(ds, True)\n            # Sincronizza anche il toggle della toolbar se esiste\n            try:\n                self.act_toggle_normals.blockSignals(True)\n                self.act_toggle_normals.setChecked(True)\n                self.act_toggle_normals.blockSignals(False)\n            except Exception:\n                pass\n            return\n        # Fallback: prova a ricostruire direttamente\n        rb = getattr(v3d, \"_rebuild_normals_actor\", None)\n        if callable(rb):\n            rb(ds)\n        try:\n            # best effort: attivalo come \u201cvisibile\u201d nello stato locale\n            rec = v3d._datasets[ds]\n            rec[\"normals_visible\"] = True\n        except Exception:\n            pass\n\n    def _apply_normals_rebuild(self, ds: int) -&gt; None:\n        \"\"\"Chiama il rebuild con i parametri correnti del dataset.\"\"\"\n        v3d = self.viewer3d\n        # Se la API granulari esistono, non serve forzare il rebuild manuale\n        rb = getattr(v3d, \"_rebuild_normals_actor\", None)\n        if callable(rb):\n            # Recupera parametri correnti (con fallback a default)\n            try:\n                rec = v3d._datasets[ds]\n                style = str(rec.get(\"normals_style\", getattr(v3d, \"_normals_style\", \"Uniform\")))\n                color = tuple(rec.get(\"normals_color\", getattr(v3d, \"_normals_color\", (1.0, 0.2, 0.2))))\n                percent = int(rec.get(\"normals_percent\", getattr(v3d, \"_normals_percent\", 1)))\n                scale = int(rec.get(\"normals_scale\", getattr(v3d, \"_normals_scale\", 20)))\n            except Exception:\n                style, color, percent, scale = \"Uniform\", (1.0, 0.2, 0.2), 50, 20\n            rb(ds, style=style, color=color, percent=percent, scale=scale)\n\n    # --------- Normals: handlers from DisplayPanel --------------------------\n\n    # ------------------------------\n    # Normals display live updates\n    # ------------------------------\n    # ----------------------- Normals: handlers ----------------------------\n    def _on_normals_style_changed(self, mode: str) -&gt; None:\n        \"\"\"\n        Change the visualization style of normals for the currently selected dataset.\n\n        Args:\n            mode (str): The style mode to apply. Options include:\n                - 'Uniform': Uniform color for all normals.\n                - 'Axis RGB': Color normals based on their axis orientation.\n                - 'RGB Components': Color normals based on their RGB components.\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        # Update the internal MCT (Metadata Context Table) state if available\n        try:\n            if self.mct is not None:\n                self.mct[\"normals_style\"] = mode\n        except Exception:\n            pass\n        # Attempt to use the viewer's public API; if unavailable, fallback to rebuilding\n        try:\n            fn = getattr(self.viewer3d, \"set_normals_style\", None)\n            if callable(fn):\n                fn(ds, mode)\n            else:\n                # Fallback: force a rebuild with the new parameters while maintaining current visibility\n                self._apply_normals_update(ds, style=mode)\n        except Exception:\n            pass\n\n    def _on_normals_color_changed(self, col: QtGui.QColor) -&gt; None:\n        \"\"\"\n        Change the uniform color of normals. This is only applicable if the style is set to 'Uniform'.\n\n        Args:\n            col (QtGui.QColor): The new color to apply.\n        \"\"\"\n        if col is None or not col.isValid():\n            return\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        rgb = (col.red(), col.green(), col.blue())\n        # Update the internal MCT state if available\n        try:\n            if self.mct is not None:\n                self.mct[\"normals_color\"] = rgb\n        except Exception:\n            pass\n        # Attempt to use the viewer's public API; if unavailable, fallback to rebuilding\n        try:\n            fn = getattr(self.viewer3d, \"set_normals_color\", None)\n            if callable(fn):\n                fn(ds, *rgb)\n            else:\n                self._apply_normals_update(ds, color=rgb)\n        except Exception:\n            pass\n\n    def _on_normals_percent_changed(self, percent: int) -&gt; None:\n        \"\"\"\n        Change the percentage of normals displayed for the currently selected dataset.\n\n        Args:\n            percent (int): The percentage of normals to display (1 to 100).\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        p = int(max(1, min(100, percent)))  # Clamp the value between 1 and 100\n        # Update the internal MCT state if available\n        try:\n            if self.mct is not None:\n                self.mct[\"normals_percent\"] = p\n        except Exception:\n            pass\n        # Attempt to use the viewer's public API; if unavailable, fallback to rebuilding\n        try:\n            fn = getattr(self.viewer3d, \"set_normals_percent\", None)\n            if callable(fn):\n                fn(ds, p)\n            else:\n                self._apply_normals_update(ds, percent=p)\n        except Exception:\n            pass\n\n    def _on_normals_scale_changed(self, scale: int) -&gt; None:\n        \"\"\"\n        Change the scale (vector size) of normals for the currently selected dataset.\n\n        Args:\n            scale (int): The scale factor for normals. Valid range is 1 to 200.\n        \"\"\"\n        ds = self._current_dataset_index()\n        if ds is None:\n            return\n        s = int(max(1, min(200, scale)))  # Clamp the value between 1 and 200\n        # Update the internal MCT state if available\n        try:\n            if self.mct is not None:\n                self.mct[\"normals_scale\"] = s\n        except Exception:\n            pass\n        # Attempt to use the viewer's public API; if unavailable, fallback to rebuilding\n        try:\n            fn = getattr(self.viewer3d, \"set_normals_scale\", None)\n            if callable(fn):\n                fn(ds, s)\n            else:\n                self._apply_normals_update(ds, scale=s)\n        except Exception:\n            pass\n\n    # Helper: apply changes to normals by rebuilding the glyph actor if necessary\n    def _apply_normals_update(self, ds: int, *, style: str | None = None,\n                              color: tuple[int, int, int] | None = None,\n                              percent: int | None = None,\n                              scale: int | None = None) -&gt; None:\n        \"\"\"\n        Updates the normals parameters in the viewer's dataset record and forces the\n        reconstruction of the glyph actor while maintaining the current visibility state.\n\n        Args:\n            ds (int): The dataset index to update.\n            style (str | None): The visualization style for normals (e.g., 'Uniform', 'Axis RGB').\n            color (tuple[int, int, int] | None): The RGB color for normals, as integers in the range 0-255.\n            percent (int | None): The percentage of normals to display (1 to 100).\n            scale (int | None): The scale factor for normals (1 to 200).\n        \"\"\"\n        try:\n            recs = getattr(self.viewer3d, \"_datasets\", [])\n            if not (0 &lt;= ds &lt; len(recs)):\n                return\n            rec = recs[ds]\n            # Update per-dataset state\n            if style is not None:\n                rec[\"normals_style\"] = style\n            if color is not None:\n                # Normalize color to float 0..1 if the viewer expects it, otherwise keep 0..255\n                try:\n                    rec[\"normals_color\"] = tuple(float(c)/255.0 for c in color)\n                except Exception:\n                    rec[\"normals_color\"] = color\n            if percent is not None:\n                rec[\"normals_percent\"] = int(max(1, min(100, percent)))\n            if scale is not None:\n                rec[\"normals_scale\"] = int(max(1, min(200, scale)))\n\n            # If normals are currently visible, rebuild the actor; otherwise, do nothing\n            # (the actor will be rebuilt when toggled ON).\n            visible = bool(rec.get(\"normals_visible\", False))\n            if visible:\n                # Prefer public API if it exists\n                rb = getattr(self.viewer3d, \"_rebuild_normals_actor\", None)\n                if callable(rb):\n                    rb(\n                        ds,\n                        style=str(rec.get(\"normals_style\", \"Axis RGB\")),\n                        color=tuple(rec.get(\"normals_color\", (0.9, 0.9, 0.2))),\n                        percent=int(rec.get(\"normals_percent\", 1)),\n                        scale=int(rec.get(\"normals_scale\", 20)),\n                    )\n                else:\n                    # As a fallback, force set_normals_visibility(True), which internally triggers a rebuild\n                    getattr(self.viewer3d, \"set_normals_visibility\", lambda *_: None)(ds, True)\n            # Perform a lightweight refresh of the viewer\n            try:\n                self.viewer3d.refresh()\n            except Exception:\n                pass\n        except Exception:\n            pass\n\n\n    def _on_fast_normals_toggled(self, enabled: bool) -&gt; None:\n        \"\"\"\n        Persist the user's preference for 'Fast normals' in the window state.\n\n        Args:\n            enabled (bool): Whether the 'Fast normals' mode is enabled or not.\n        \"\"\"\n        try:\n            self.normals_fast_enabled = bool(enabled)\n        except Exception:\n            pass\n    # ------------------------------------------------------------------\n    # ViewSettingsDialog: edit 3D viewer settings (background, grid, colorbar, points style)\n    # ------------------------------------------------------------------\n    class ViewSettingsDialog(QtWidgets.QDialog):\n        \"\"\"Dialog to customize 3D view preferences (background, grid, colorbar, points style).\"\"\"\n        def __init__(self, parent=None, state: dict | None = None):\n            super().__init__(parent)\n            self.setWindowTitle(\"3D View Settings\")\n            self.setModal(True)\n            self._state = dict(state or {})\n\n            lay = QtWidgets.QVBoxLayout(self)\n\n            # Background color picker\n            row_bg = QtWidgets.QHBoxLayout()\n            row_bg.addWidget(QtWidgets.QLabel(\"Background:\"))\n            self.btnBg = QtWidgets.QPushButton()\n            self.btnBg.setFixedWidth(120)\n            self.btnBg.clicked.connect(self._pick_bg)\n            row_bg.addWidget(self.btnBg)\n            row_bg.addStretch(1)\n            lay.addLayout(row_bg)\n\n            # Grid + points style\n            self.chkGrid = QtWidgets.QCheckBox(\"Show grid\")\n            self.chkPtsSpheres = QtWidgets.QCheckBox(\"Render points as spheres\")\n            lay.addWidget(self.chkGrid)\n            lay.addWidget(self.chkPtsSpheres)\n\n            # Colorbar controls\n            gb = QtWidgets.QGroupBox(\"Colorbar\")\n            gl = QtWidgets.QFormLayout(gb)\n            self.cmbBar = QtWidgets.QComboBox()\n            self.cmbBar.addItems([\"Hidden\", \"Horizontal (bottom-right)\", \"Vertical (top-right)\"])\n            self.edBarTitle = QtWidgets.QLineEdit()\n            gl.addRow(\"Mode:\", self.cmbBar)\n            gl.addRow(\"Title:\", self.edBarTitle)\n            lay.addWidget(gb)\n\n            # Buttons\n            btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Apply)\n            btns.accepted.connect(self.accept)\n            btns.rejected.connect(self.reject)\n            btns.button(QtWidgets.QDialogButtonBox.Apply).clicked.connect(self._apply_only)\n            lay.addWidget(btns)\n\n            self._load_state()\n\n        def _load_state(self):\n            \"\"\"Populate widgets from the provided state dict.\"\"\"\n            bg = tuple(self._state.get(\"bg\", (30, 30, 30)))\n            self._set_btn_bg(bg)\n            self.chkGrid.setChecked(bool(self._state.get(\"grid\", True)))\n            self.chkPtsSpheres.setChecked(bool(self._state.get(\"points_as_spheres\", True)))\n            mode = str(self._state.get(\"colorbar_mode\", \"vertical-tr\"))\n            idx = {\"hidden\":0, \"horizontal-br\":1, \"vertical-tr\":2}.get(mode, 2)\n            self.cmbBar.setCurrentIndex(idx)\n            self.edBarTitle.setText(str(self._state.get(\"colorbar_title\", \"\")))\n\n        def _set_btn_bg(self, rgb: tuple[int, int, int]):\n            \"\"\"Update the background button swatch.\"\"\"\n            try:\n                r, g, b = map(int, rgb)\n                self.btnBg.setText(f\"RGB {r},{g},{b}\")\n                self.btnBg.setStyleSheet(f\"background-color: rgb({r},{g},{b}); color: white;\")\n            except Exception:\n                pass\n\n        def _pick_bg(self):\n            \"\"\"Open a QColorDialog to pick a background color.\"\"\"\n            try:\n                c0 = QtGui.QColor(*self._state.get(\"bg\", (30, 30, 30)))\n                col = QtWidgets.QColorDialog.getColor(c0, self, \"Pick background color\")\n                if col.isValid():\n                    self._state[\"bg\"] = (col.red(), col.green(), col.blue())\n                    self._set_btn_bg(self._state[\"bg\"])\n            except Exception:\n                pass\n\n        def values(self) -&gt; dict:\n            \"\"\"Return current dialog values as a dict.\"\"\"\n            mode_idx = int(self.cmbBar.currentIndex())\n            mode = {0:\"hidden\", 1:\"horizontal-br\", 2:\"vertical-tr\"}.get(mode_idx, \"vertical-tr\")\n            return {\n                \"bg\": tuple(self._state.get(\"bg\", (30,30,30))),\n                \"grid\": bool(self.chkGrid.isChecked()),\n                \"points_as_spheres\": bool(self.chkPtsSpheres.isChecked()),\n                \"colorbar_mode\": mode,\n                \"colorbar_title\": self.edBarTitle.text().strip(),\n            }\n\n        def _apply_only(self):\n            self.done(2)  # custom code for Apply\n\n    def _on_open_view_settings(self) -&gt; None:\n        \"\"\"Open the 3D view settings dialog and apply changes (Apply/OK).\"\"\"\n        st = dict(getattr(self, \"_view_prefs\", {}))\n        dlg = self.ViewSettingsDialog(self, state=st)\n        code = dlg.exec()\n\n        def _apply(vals: dict):\n            v3d = getattr(self, \"viewer3d\", None)\n            if v3d is None:\n                return\n            # Background\n            try:\n                getattr(v3d, \"set_background_color\", lambda *_: None)(vals[\"bg\"])  # (r,g,b)\n            except Exception:\n                pass\n            # Grid\n            try:\n                on = bool(vals.get(\"grid\", True))\n                for name in (\"set_grid_enabled\", \"set_grid_visible\", \"toggle_grid\", \"show_grid\"):\n                    fn = getattr(v3d, name, None)\n                    if callable(fn):\n                        try:\n                            fn(on)\n                            break\n                        except Exception:\n                            continue\n            except Exception:\n                pass\n            # Points as spheres\n            try:\n                getattr(v3d, \"set_points_as_spheres\", lambda *_: None)(bool(vals.get(\"points_as_spheres\", True)))\n            except Exception:\n                pass\n            # Colorbar placement\n            try:\n                getattr(v3d, \"set_colorbar_mode\", lambda *_: None)(str(vals.get(\"colorbar_mode\", \"vertical-tr\")), str(vals.get(\"colorbar_title\", \"\")))\n            except Exception:\n                # Fallback: try vertical/hide helper if available\n                mode = str(vals.get(\"colorbar_mode\", \"vertical-tr\"))\n                if mode == \"hidden\":\n                    try:\n                        v3d.set_colorbar_vertical(False)\n                    except Exception:\n                        pass\n                elif mode == \"vertical-tr\":\n                    try:\n                        v3d.set_colorbar_vertical(True, str(vals.get(\"colorbar_title\", \"\")))\n                    except Exception:\n                        pass\n\n            try:\n                v3d._apply_background(); v3d._apply_scalarbar()\n            except Exception:\n                pass\n            # Keep a copy for next time\n            try:\n                self._view_prefs.update(vals)\n            except Exception:\n                pass\n            try:\n                v3d.refresh()\n            except Exception:\n                pass\n\n        # Apply immediately for Apply/OK\n        if code == 2 or code == QtWidgets.QDialog.Accepted:\n            _apply(dlg.values())\n</code></pre>"},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.downsample_method","title":"<code>downsample_method = 'random'</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.mct","title":"<code>mct = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.mcts","title":"<code>mcts = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.plugin_manager","title":"<code>plugin_manager = PluginManager(self, plugins_dir=(self._default_plugins_dir()))</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.undo_stack","title":"<code>undo_stack = QtGui.QUndoStack(self)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.ViewSettingsDialog","title":"<code>ViewSettingsDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog to customize 3D view preferences (background, grid, colorbar, points style).</p> Source code in <code>src/c2f4dt/main_window.py</code> <pre><code>class ViewSettingsDialog(QtWidgets.QDialog):\n    \"\"\"Dialog to customize 3D view preferences (background, grid, colorbar, points style).\"\"\"\n    def __init__(self, parent=None, state: dict | None = None):\n        super().__init__(parent)\n        self.setWindowTitle(\"3D View Settings\")\n        self.setModal(True)\n        self._state = dict(state or {})\n\n        lay = QtWidgets.QVBoxLayout(self)\n\n        # Background color picker\n        row_bg = QtWidgets.QHBoxLayout()\n        row_bg.addWidget(QtWidgets.QLabel(\"Background:\"))\n        self.btnBg = QtWidgets.QPushButton()\n        self.btnBg.setFixedWidth(120)\n        self.btnBg.clicked.connect(self._pick_bg)\n        row_bg.addWidget(self.btnBg)\n        row_bg.addStretch(1)\n        lay.addLayout(row_bg)\n\n        # Grid + points style\n        self.chkGrid = QtWidgets.QCheckBox(\"Show grid\")\n        self.chkPtsSpheres = QtWidgets.QCheckBox(\"Render points as spheres\")\n        lay.addWidget(self.chkGrid)\n        lay.addWidget(self.chkPtsSpheres)\n\n        # Colorbar controls\n        gb = QtWidgets.QGroupBox(\"Colorbar\")\n        gl = QtWidgets.QFormLayout(gb)\n        self.cmbBar = QtWidgets.QComboBox()\n        self.cmbBar.addItems([\"Hidden\", \"Horizontal (bottom-right)\", \"Vertical (top-right)\"])\n        self.edBarTitle = QtWidgets.QLineEdit()\n        gl.addRow(\"Mode:\", self.cmbBar)\n        gl.addRow(\"Title:\", self.edBarTitle)\n        lay.addWidget(gb)\n\n        # Buttons\n        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Apply)\n        btns.accepted.connect(self.accept)\n        btns.rejected.connect(self.reject)\n        btns.button(QtWidgets.QDialogButtonBox.Apply).clicked.connect(self._apply_only)\n        lay.addWidget(btns)\n\n        self._load_state()\n\n    def _load_state(self):\n        \"\"\"Populate widgets from the provided state dict.\"\"\"\n        bg = tuple(self._state.get(\"bg\", (30, 30, 30)))\n        self._set_btn_bg(bg)\n        self.chkGrid.setChecked(bool(self._state.get(\"grid\", True)))\n        self.chkPtsSpheres.setChecked(bool(self._state.get(\"points_as_spheres\", True)))\n        mode = str(self._state.get(\"colorbar_mode\", \"vertical-tr\"))\n        idx = {\"hidden\":0, \"horizontal-br\":1, \"vertical-tr\":2}.get(mode, 2)\n        self.cmbBar.setCurrentIndex(idx)\n        self.edBarTitle.setText(str(self._state.get(\"colorbar_title\", \"\")))\n\n    def _set_btn_bg(self, rgb: tuple[int, int, int]):\n        \"\"\"Update the background button swatch.\"\"\"\n        try:\n            r, g, b = map(int, rgb)\n            self.btnBg.setText(f\"RGB {r},{g},{b}\")\n            self.btnBg.setStyleSheet(f\"background-color: rgb({r},{g},{b}); color: white;\")\n        except Exception:\n            pass\n\n    def _pick_bg(self):\n        \"\"\"Open a QColorDialog to pick a background color.\"\"\"\n        try:\n            c0 = QtGui.QColor(*self._state.get(\"bg\", (30, 30, 30)))\n            col = QtWidgets.QColorDialog.getColor(c0, self, \"Pick background color\")\n            if col.isValid():\n                self._state[\"bg\"] = (col.red(), col.green(), col.blue())\n                self._set_btn_bg(self._state[\"bg\"])\n        except Exception:\n            pass\n\n    def values(self) -&gt; dict:\n        \"\"\"Return current dialog values as a dict.\"\"\"\n        mode_idx = int(self.cmbBar.currentIndex())\n        mode = {0:\"hidden\", 1:\"horizontal-br\", 2:\"vertical-tr\"}.get(mode_idx, \"vertical-tr\")\n        return {\n            \"bg\": tuple(self._state.get(\"bg\", (30,30,30))),\n            \"grid\": bool(self.chkGrid.isChecked()),\n            \"points_as_spheres\": bool(self.chkPtsSpheres.isChecked()),\n            \"colorbar_mode\": mode,\n            \"colorbar_title\": self.edBarTitle.text().strip(),\n        }\n\n    def _apply_only(self):\n        self.done(2)  # custom code for Apply\n</code></pre>"},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.ViewSettingsDialog.btnBg","title":"<code>btnBg = QtWidgets.QPushButton()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.ViewSettingsDialog.chkGrid","title":"<code>chkGrid = QtWidgets.QCheckBox('Show grid')</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.ViewSettingsDialog.chkPtsSpheres","title":"<code>chkPtsSpheres = QtWidgets.QCheckBox('Render points as spheres')</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.ViewSettingsDialog.cmbBar","title":"<code>cmbBar = QtWidgets.QComboBox()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.ViewSettingsDialog.edBarTitle","title":"<code>edBarTitle = QtWidgets.QLineEdit()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.ViewSettingsDialog.values","title":"<code>values()</code>","text":"<p>Return current dialog values as a dict.</p> Source code in <code>src/c2f4dt/main_window.py</code> <pre><code>def values(self) -&gt; dict:\n    \"\"\"Return current dialog values as a dict.\"\"\"\n    mode_idx = int(self.cmbBar.currentIndex())\n    mode = {0:\"hidden\", 1:\"horizontal-br\", 2:\"vertical-tr\"}.get(mode_idx, \"vertical-tr\")\n    return {\n        \"bg\": tuple(self._state.get(\"bg\", (30,30,30))),\n        \"grid\": bool(self.chkGrid.isChecked()),\n        \"points_as_spheres\": bool(self.chkPtsSpheres.isChecked()),\n        \"colorbar_mode\": mode,\n        \"colorbar_title\": self.edBarTitle.text().strip(),\n    }\n</code></pre>"},{"location":"api/c2f4dt/main_window/#c2f4dt.main_window.MainWindow.import_cloud_programmatic","title":"<code>import_cloud_programmatic(path, *, axis_preset='Z-up (identity)', color_preference='auto', compute_normals_if_missing=True, map_normals=True)</code>","text":"<p>Import a geometry file without showing the summary dialog.</p> <p>Mirrors <code>_on_import_cloud</code> pipeline with sensible defaults: - axis_preset: one of the presets in the summary dialog - color_preference: 'auto' | 'rgb' | 'colormap' - compute_normals_if_missing: compute rough normals if absent - map_normals: if True, apply axis preset also to normals</p> Source code in <code>src/c2f4dt/main_window.py</code> <pre><code>def import_cloud_programmatic(\n    self,\n    path: str,\n    *,\n    axis_preset: str = \"Z-up (identity)\",\n    color_preference: str = \"auto\",\n    compute_normals_if_missing: bool = True,\n    map_normals: bool = True,\n) -&gt; None:\n    \"\"\"Import a geometry file without showing the summary dialog.\n\n    Mirrors `_on_import_cloud` pipeline with sensible defaults:\n    - axis_preset: one of the presets in the summary dialog\n    - color_preference: 'auto' | 'rgb' | 'colormap'\n    - compute_normals_if_missing: compute rough normals if absent\n    - map_normals: if True, apply axis preset also to normals\n    \"\"\"\n    from .utils.io.importers import import_file\n\n    # Presets consistent with ImportSummaryDialog\n    presets = {\n        \"Z-up (identity)\":  {\"X\": \"+X\", \"Y\": \"+Y\", \"Z\": \"+Z\"},\n        \"Y-up (swap Y/Z)\":  {\"X\": \"+X\", \"Y\": \"+Z\", \"Z\": \"-Y\"},\n        \"X-up (swap X/Z)\":  {\"X\": \"+Z\", \"Y\": \"+Y\", \"Z\": \"-X\"},\n        \"Flip Z\":           {\"X\": \"+X\", \"Y\": \"+Y\", \"Z\": \"-Z\"},\n        \"Flip Y\":           {\"X\": \"+X\", \"Y\": \"-Y\", \"Z\": \"+Z\"},\n        \"Flip X\":           {\"X\": \"-X\", \"Y\": \"+Y\", \"Z\": \"+Z\"},\n    }\n    axis_map = presets.get(axis_preset, presets[\"Z-up (identity)\"])\n\n    try:\n        objects = import_file(path)\n    except Exception as ex:\n        raise RuntimeError(f\"Import error: {ex}\")\n\n    # Helpers (reuse lambdas from _on_import_cloud but kept local here)\n    def _apply_axis_map(arr, axis_map):\n        try:\n            import numpy as _np\n            if arr is None:\n                return None\n            src = _np.asarray(arr, dtype=float)\n            if src.ndim != 2 or src.shape[1] != 3:\n                return arr\n            out = _np.empty_like(src)\n            axes = {\"X\": 0, \"Y\": 1, \"Z\": 2}\n            for tgt_key, expr in axis_map.items():\n                sign = -1.0 if expr.startswith(\"-\") else 1.0\n                src_axis = axes[expr[-1]]\n                out[:, axes[tgt_key]] = sign * src[:, src_axis]\n            return out\n        except Exception:\n            return arr\n\n    def _compute_normals(obj):\n        try:\n            import numpy as _np\n            import pyvista as _pv  # type: ignore\n            if obj.points is None or obj.points.shape[0] == 0:\n                return None\n            pdata = _pv.PolyData(_np.asarray(obj.points))\n            pdata = pdata.compute_normals(\n                consistent=False,\n                auto_orient_normals=False,\n                feature_angle=180.0,\n            )\n            n = getattr(pdata, 'point_normals', None)\n            if n is not None:\n                return _np.asarray(n, dtype=_np.float32)\n        except Exception:\n            return None\n        return None\n\n    # 1) Apply axis mapping / normals ops per object\n    for obj in objects:\n        obj.points = _apply_axis_map(obj.points, axis_map)\n        if map_normals and getattr(obj, 'normals', None) is not None:\n            obj.normals = _apply_axis_map(obj.normals, axis_map)\n        elif compute_normals_if_missing and getattr(obj, 'normals', None) is None:\n            n = _compute_normals(obj)\n            if n is not None:\n                obj.normals = n\n        # Color preference per object (auto: prefer RGB if available)\n        if color_preference == \"auto\":\n            obj.meta['color_preference'] = 'rgb' if obj.colors is not None else 'colormap'\n        else:\n            obj.meta['color_preference'] = color_preference\n\n    # 2) Reuse the final part of the GUI pipeline to add to viewer &amp; tree\n    # Temporarily set viewer color-mode per object, as in _on_import_cloud\n    for obj in objects:\n        prev_mode = getattr(self.viewer3d, '_color_mode', None)\n        try:\n            pref = obj.meta.get('color_preference', 'rgb')\n            if pref == 'colormap':\n                self.viewer3d.set_color_mode('Normal Colormap')\n            else:\n                self.viewer3d.set_color_mode('Normal RGB')\n        except Exception:\n            prev_mode = None\n\n        if obj.kind == \"points\" and obj.points is not None:\n            ds_index = self.viewer3d.add_points(obj.points, obj.colors, getattr(obj, \"normals\", None))\n        elif obj.kind == \"mesh\" and obj.pv_mesh is not None:\n            ds_index = self.viewer3d.add_pyvista_mesh(obj.pv_mesh)\n        else:\n            ds_index = None\n\n        try:\n            self._reapply_overlays_safe()\n        except Exception:\n            pass\n        try:\n            if prev_mode is not None:\n                self.viewer3d.set_color_mode(prev_mode)\n        except Exception:\n            pass\n\n        # \n        # Build the tree entries (same as interactive import)\n        self.treeMCTS.blockSignals(True)\n        root = QtWidgets.QTreeWidgetItem([obj.name])\n        root.setFlags(\n            root.flags()\n            | QtCore.Qt.ItemFlag.ItemIsUserCheckable\n            | QtCore.Qt.ItemFlag.ItemIsAutoTristate\n        )\n        root.setCheckState(0, QtCore.Qt.CheckState.Checked)\n        self.treeMCTS.addTopLevelItem(root)\n\n        if obj.kind == \"points\":\n            it_points = QtWidgets.QTreeWidgetItem([\"Point cloud\"])\n            it_points.setFlags(\n                it_points.flags()\n                | QtCore.Qt.ItemFlag.ItemIsUserCheckable\n                # | QtCore.Qt.ItemFlag.ItemIsAutoTristate\n            )\n            it_points.setCheckState(0, QtCore.Qt.CheckState.Checked)\n            it_points.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"points\", \"ds\": ds_index})\n            root.addChild(it_points)\n\n            if getattr(obj, \"normals\", None) is not None:\n                it_normals = QtWidgets.QTreeWidgetItem([\"Normals\"])\n                it_normals.setFlags(\n                    it_normals.flags() | QtCore.Qt.ItemFlag.ItemIsUserCheckable\n                )\n                it_normals.setCheckState(0, QtCore.Qt.CheckState.Unchecked)\n                it_normals.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"normals\", \"ds\": ds_index})\n                it_points.addChild(it_normals)\n        else:\n            it_mesh = QtWidgets.QTreeWidgetItem([\"Mesh\"])\n            it_mesh.setFlags(it_mesh.flags() | QtCore.Qt.ItemFlag.ItemIsUserCheckable)\n            it_mesh.setCheckState(0, QtCore.Qt.CheckState.Checked)\n            it_mesh.setData(0, QtCore.Qt.ItemDataRole.UserRole, {\"kind\": \"mesh\", \"ds\": ds_index})\n            root.addChild(it_mesh)\n\n        self.treeMCTS.blockSignals(False)\n        # \n        # Update visibility after adding.\n        self._refresh_tree_visibility()\n\n        # Register into MCTS and set current MCT so it's visible in console\n        try:\n            entry = {\n                \"name\": obj.name,\n                \"kind\": obj.kind,\n                \"has_rgb\": obj.colors is not None,\n                \"has_intensity\": getattr(obj, 'intensity', None) is not None,\n                \"has_normals\": getattr(obj, 'normals', None) is not None,\n                \"ds_index\": ds_index if (obj.kind == 'points' and ds_index is not None) else None,\n            }\n            self.mcts[obj.name] = entry\n            self.mct = entry\n            try:\n                self.treeMCTS.setCurrentItem(root)\n            except Exception:\n                pass\n        except Exception:\n            pass\n\n    self.statusBar().showMessage(f\"Imported from {os.path.basename(path)}\", 3000)\n</code></pre>"},{"location":"api/c2f4dt/plugins/","title":"c2f4dt.plugins","text":""},{"location":"api/c2f4dt/plugins/#c2f4dt.plugins","title":"<code>c2f4dt.plugins</code>","text":"<p>Package init.</p>"},{"location":"api/c2f4dt/ui/","title":"c2f4dt.ui","text":""},{"location":"api/c2f4dt/ui/#c2f4dt.ui","title":"<code>c2f4dt.ui</code>","text":"<p>Package init.</p>"},{"location":"api/c2f4dt/utils/","title":"c2f4dt.utils","text":""},{"location":"api/c2f4dt/utils/#c2f4dt.utils","title":"<code>c2f4dt.utils</code>","text":"<p>Package init.</p>"},{"location":"api/c2f4dt/plugins/example_display_button/","title":"c2f4dt.plugins.example_display_button","text":""},{"location":"api/c2f4dt/plugins/example_display_button/#c2f4dt.plugins.example_display_button","title":"<code>c2f4dt.plugins.example_display_button</code>","text":""},{"location":"api/c2f4dt/plugins/manager/","title":"c2f4dt.plugins.manager","text":""},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager","title":"<code>c2f4dt.plugins.manager</code>","text":""},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginManager","title":"<code>PluginManager</code>","text":"<p>Discover and manage plugins from the <code>plugins</code> directory.</p> <p>The manager searches subfolders in <code>c2f4dt/plugins</code> (i.e. the directory where this file lives) unless a different directory is provided.</p> <p>It supports two metadata sources:</p> <ol> <li><code>plugin.yaml</code> with keys {name, order, requires, entry_point}</li> <li><code>plugin.py</code> exposing either:</li> <li><code>PLUGIN</code> compatible with :class:<code>PluginMeta</code> (name, order, requires)</li> <li>and/or a factory <code>load_plugin(parent) -&gt; Any</code></li> </ol> <p>Typical plugin layout::</p> <pre><code>plugins/\n  hello/\n    __init__.py\n    plugin.py          # may define PLUGIN and load_plugin()\n    plugin.yaml        # optional; overrides values from plugin.py (supports name, order, requires, entry_point, version|release)\n</code></pre> <p>The instantiated plugin object is returned by :meth:<code>load_plugins</code>.</p> Source code in <code>src/c2f4dt/plugins/manager.py</code> <pre><code>class PluginManager:\n    \"\"\"Discover and manage plugins from the ``plugins`` directory.\n\n    The manager searches subfolders in ``c2f4dt/plugins`` (i.e. the directory\n    where this file lives) unless a different directory is provided.\n\n    It supports two metadata sources:\n\n    1. ``plugin.yaml`` with keys {name, order, requires, entry_point}\n    2. ``plugin.py`` exposing either:\n       - ``PLUGIN`` compatible with :class:`PluginMeta` (name, order, requires)\n       - and/or a factory ``load_plugin(parent) -&gt; Any``\n\n    Typical plugin layout::\n\n        plugins/\n          hello/\n            __init__.py\n            plugin.py          # may define PLUGIN and load_plugin()\n            plugin.yaml        # optional; overrides values from plugin.py (supports name, order, requires, entry_point, version|release)\n\n    The instantiated plugin object is returned by :meth:`load_plugins`.\n    \"\"\"\n\n    def __init__(self, parent: Any, plugins_dir: Optional[Path | str] = None) -&gt; None:\n        \"\"\"Initialize the manager.\n\n        Args:\n            parent: Host object (e.g., main application) passed to plugins.\n            plugins_dir: Optional absolute path to the plugins root. If not\n                provided, defaults to the directory where this file resides.\n        \"\"\"\n        self.parent = parent\n\n        # Resolve plugins directory: explicit argument wins, otherwise use smart resolver.\n        if plugins_dir:\n            self.plugins_dir = Path(plugins_dir).expanduser().resolve()\n        else:\n            self.plugins_dir = self._resolve_default_plugins_dir()\n\n        logging.debug(\n            \"[PluginManager] Using plugins_dir=%s (exists=%s, is_dir=%s)\",\n            self.plugins_dir,\n            self.plugins_dir.exists(),\n            self.plugins_dir.is_dir(),\n        )\n\n        self._metas: list[PluginMeta] = []\n        self._instances: Dict[str, Any] = {}\n        self._discover()\n\n    def _resolve_default_plugins_dir(self) -&gt; Path:\n        \"\"\"Return the most likely plugins directory.\n\n        Resolution order:\n        1. Environment variable ``C2F4DT_PLUGINS_DIR`` if it points to an existing dir.\n        2. The directory where this file lives (``.../c2f4dt/plugins``).\n        3. Project root ``.../C2F4DT/plugins`` (two levels up from this file).\n        4. Current working directory ``./plugins``.\n        The first *existing* directory is returned; otherwise fallback to (2).\n        \"\"\"\n        here = Path(__file__).resolve().parent\n\n        # 1) Environment override\n        env_dir = os.environ.get(\"C2F4DT_PLUGINS_DIR\")\n        if env_dir:\n            env_path = Path(env_dir).expanduser().resolve()\n            if env_path.is_dir():\n                return env_path\n\n        # 2) This file's folder: c2f4dt/plugins\n        if here.is_dir():\n            return here\n\n        # 3) Project root /plugins (two levels up from this file)\n        project_root_plugins = here.parent.parent.joinpath(\"plugins\").resolve()\n        if project_root_plugins.is_dir():\n            return project_root_plugins\n\n        # 4) CWD /plugins\n        cwd_plugins = Path.cwd().joinpath(\"plugins\").resolve()\n        if cwd_plugins.is_dir():\n            return cwd_plugins\n\n        # Fallback: return where this file resides even if it does not exist (caller will log)\n        return here\n\n    # ---------------------------------------------------------------------\n    # Discovery\n    # ---------------------------------------------------------------------\n    def _discover(self) -&gt; None:\n        \"\"\"Scan the plugins directory and collect metadata.\n\n        This function populates ``self._metas`` by reading either a\n        ``plugin.yaml`` or a ``plugin.py`` file for each subdirectory.\n        \"\"\"\n        if not self.plugins_dir.is_dir():\n            logging.warning(\n                \"Plugin directory does not exist or is not a directory: %s (exists=%s, is_dir=%s)\",\n                self.plugins_dir,\n                self.plugins_dir.exists(),\n                self.plugins_dir.is_dir(),\n            )\n            return\n\n        for entry in sorted(self.plugins_dir.iterdir()):\n            if not entry.is_dir():\n                continue\n            meta = self._load_meta(entry)\n            if meta is None:\n                continue\n\n            # Check runtime requirements (importable modules).\n            if not self._requirements_ok(meta):\n                logging.warning(\"Skipping plugin '%s' due to missing requirements: %s\",\n                                meta.name, \", \".join(meta.requires))\n                continue\n\n            self._metas.append(meta)\n\n        # Sort by declared order (stable sort)\n        self._metas.sort(key=lambda m: m.order)\n\n    def _requirements_ok(self, meta: PluginMeta) -&gt; Tuple[bool, List[str]]:\n        \"\"\"Check python requirements listed in plugin.yaml.\"\"\"\n        missing: List[str] = []\n        for req in meta.requires:\n            try:\n                importlib.import_module(req)\n            except Exception:\n                missing.append(req)\n        return (len(missing) == 0, missing)\n\n    def _meta_by_name(self, name: str) -&gt; Optional[PluginMeta]:\n        for m in self._metas:\n            if m.name == name:\n                return m\n        return None\n\n\n    def _load_meta(self, plugin_dir: Path) -&gt; Optional[PluginMeta]:\n        \"\"\"Load metadata for a single plugin directory.\n\n        The precedence is: ``plugin.yaml`` (if PyYAML is available) then\n        ``plugin.py``'s ``PLUGIN`` object.\n\n        Args:\n            plugin_dir: Absolute path to the plugin directory.\n\n        Returns:\n            A :class:`PluginMeta` or ``None`` if not a valid plugin.\n        \"\"\"\n        meta: Optional[PluginMeta] = None\n\n        yaml_path = plugin_dir / \"plugin.yaml\"\n        if yaml and yaml_path.is_file():\n            try:\n                data = yaml.safe_load(yaml_path.read_text()) or {}\n                name = str(data.get(\"name\") or plugin_dir.name)\n                order = int(data.get(\"order\", 100))\n                requires = tuple(map(str, data.get(\"requires\", ())))\n                entry_point = data.get(\"entry_point\")\n                version = str(data.get(\"version\") or data.get(\"release\") or \"\").strip() or None\n                meta = PluginMeta(name=name, order=order, requires=requires,\n                                  entry_point=entry_point, path=plugin_dir,\n                                  version=version)\n            except Exception as exc:  # robust to malformed YAML\n                logging.error(\"Failed to read %s: %s\", yaml_path, exc)\n\n        if meta is None:\n            py_path = plugin_dir / \"plugin.py\"\n            if py_path.is_file():\n                spec = importlib.util.spec_from_file_location(f\"{plugin_dir.name}.plugin\", py_path)\n                if spec and spec.loader:\n                    mod = importlib.util.module_from_spec(spec)\n                    try:\n                        spec.loader.exec_module(mod)  # type: ignore[misc]\n                    except Exception as exc:\n                        logging.error(\"Failed to import %s: %s\", py_path, exc)\n                        return None\n\n                    # Accept either an actual PluginMeta or a simple namespace\n                    plugin_obj = getattr(mod, \"PLUGIN\", None)\n                    if plugin_obj is not None:\n                        name = getattr(plugin_obj, \"name\", plugin_dir.name)\n                        order = int(getattr(plugin_obj, \"order\", 100))\n                        requires = tuple(getattr(plugin_obj, \"requires\", ()))\n                        version = getattr(plugin_obj, \"version\", None) or getattr(plugin_obj, \"release\", None)\n                        if isinstance(version, str):\n                            version = version.strip() or None\n                        else:\n                            version = None\n                        meta = PluginMeta(name=str(name), order=order,\n                                          requires=tuple(map(str, requires)), path=plugin_dir,\n                                          version=version)\n\n        if meta is not None:\n            # Ensure path is set for later imports\n            meta.path = plugin_dir\n        return meta\n\n    # ---------------------------------------------------------------------\n    # Loading\n    # ---------------------------------------------------------------------\n    def _dependency_status(self, meta: PluginMeta) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Return (ok, missing) lists for the required imports of a plugin.\n\n        Args:\n            meta: Plugin metadata.\n        \"\"\"\n        ok: list[str] = []\n        missing: list[str] = []\n        for req in meta.requires:\n            try:\n                importlib.import_module(req)\n            except Exception:\n                missing.append(req)\n            else:\n                ok.append(req)\n        return ok, missing\n\n    def _import_plugin_package(self, meta: PluginMeta) -&gt; Optional[ModuleType]:\n        \"\"\"Import the plugin as a package/module in a stable manner.\n\n        Strategy:\n        1) If the plugin folder is a reachable package, import it as\n           '&lt;package_root&gt;.&lt;plugin_name&gt;' (e.g., 'c2f4dt.plugins.units').\n        2) Fallback: directly load 'plugin.py' using a spec loader,\n           **registering the module in sys.modules** before executing it,\n           so that decorators like @dataclass can find the module.\n        \"\"\"\n        package_root = \".\".join(__name__.split(\".\")[:-1])  # e.g., 'c2f4dt.plugins'\n        dotted = f\"{package_root}.{meta.name}\"\n\n        # 1) Attempt a \"normal\" import\n        try:\n            return importlib.import_module(dotted)\n        except Exception:\n            pass\n\n        # 2) Fallback: direct import of plugin.py\n        py = meta.path.joinpath(\"plugin.py\") if meta.path else None\n        if py and py.is_file():\n            spec = importlib.util.spec_from_file_location(f\"{meta.name}.plugin\", py)\n            if spec and spec.loader:\n                mod = importlib.util.module_from_spec(spec)\n                # *** CRITICAL: Register the module before executing it ***\n                sys.modules[spec.name] = mod\n                spec.loader.exec_module(mod)  # type: ignore[misc]\n                return mod\n        return None\n\n    def _resolve_entry_point(self, module: ModuleType, entry_point: Optional[str]) -&gt; Optional[Any]:\n        \"\"\"\n        Resolve and return the factory/class pointed to by the entry_point.\n\n        Supported formats:\n        - \"attr\"                 -&gt; getattr(module, \"attr\")\n        - \":attr\"                -&gt; getattr(module, \"attr\")  (explicitly same module)\n        - \"submod:attr\"          -&gt; import module.__name__ + \".submod\" -&gt; getattr(submod, \"attr\")\n        - \"pkg.submod:attr\"      -&gt; absolute import \"pkg.submod\" -&gt; getattr(submod, \"attr\")\n        \"\"\"\n        if not entry_point:\n            # Fallback to a conventional default\n            return getattr(module, \"load_plugin\", None)\n\n        mod_part, colon, attr = entry_point.partition(\":\")\n        if not colon:\n            # Format \"attr\" without a colon\n            return getattr(module, entry_point, None)\n\n        # At this point, we always have \"X:Y\" (even if X can be empty like in \":attr\")\n        if not attr:\n            # No attribute to resolve\n            return None\n\n        target_module = module\n        if mod_part:\n            # If mod_part contains dots, treat it as ABSOLUTE (e.g., \"plugins.units.plugin\")\n            # Otherwise, treat it as RELATIVE to the package of the passed module.\n            try:\n                if \".\" in mod_part:\n                    target_module = importlib.import_module(mod_part)\n                else:\n                    # The module is the base package; import one of its submodules\n                    target_module = importlib.import_module(f\"{module.__name__}.{mod_part}\")\n            except Exception as exc:\n                logging.error(\n                    \"Failed to import entry submodule '%s' for '%s': %s\",\n                    mod_part, getattr(module, \"__name__\", module), exc\n                )\n                return None\n\n        logging.debug(\"Entry point target_module=%s file=%s\", getattr(target_module, \"__name__\", \"?\"), getattr(target_module, \"__file__\", \"?\"))\n        logging.debug(\"Entry point attributes sample=%s\", [n for n in dir(target_module) if n in (\"register\", \"load_plugin\", \"UnitsPlugin\")])\n        obj = getattr(target_module, attr, None)\n        return obj\n\n    def load_plugins(self) -&gt; Dict[str, Any]:\n        \"\"\"Instantiate and return all enabled plugins.\n\n        Returns:\n            Dict mapping plugin name to the instantiated plugin object.\n        \"\"\"\n        instances: Dict[str, Any] = {}\n        for meta in self._metas:\n            module = self._import_plugin_package(meta)\n            if module is None:\n                logging.warning(\"Cannot import plugin module for '%s'\", meta.name)\n                continue\n\n            factory_or_cls = self._resolve_entry_point(module, meta.entry_point)\n            if factory_or_cls is None:\n                logging.warning(\"No entry point found for plugin '%s'\", meta.name)\n                continue\n\n            try:\n                # Support both factory(parent) and class(parent)\n                obj = factory_or_cls(self.parent)\n            except TypeError:\n                # Maybe it's a zero-arg factory/class\n                obj = factory_or_cls()\n            except Exception as exc:\n                logging.error(\"Failed to instantiate plugin '%s': %s\", meta.name, exc)\n                continue\n\n            instances[meta.name] = obj\n        return instances\n\n    # ---------------------------------------------------------------------\n    # Introspection\n    # ---------------------------------------------------------------------\n    def available_plugins(self) -&gt; List[str]:\n        \"\"\"Return the list of discovered plugin names, sorted by order.\"\"\"\n        return [m.name for m in self._metas]\n\n    # ---------------------------\n    # PUBLIC API used by MainWindow\n    # ---------------------------\n    def ui_combo_items(self) -&gt; List[dict]:\n        \"\"\"\n        Elements to populate a combo box:\n         - key: meta.name\n         - label: meta.name\n         - enabled: whether requirements are satisfied\n         - tooltip, color, order\n         - plugin_obj: already created instance (if it exists)\n        \"\"\"\n        items: List[dict] = []\n        for meta in sorted(self._metas, key=lambda m: getattr(m, \"order\", 9999)):\n            _ok, missing = self._dependency_status(meta)  # &lt;-- uses dependency_status\n            ok = (len(missing) == 0)\n            items.append({\n                \"key\": meta.name,\n                \"label\": getattr(meta, \"name\", \"plugin\"),\n                \"enabled\": ok,\n                \"tooltip\": f\"{meta.name} {meta.version or ''}\".strip() + (\"\" if ok else f\" (missing: {', '.join(missing)})\"),\n                \"color\": \"green\" if ok else \"gray\",\n                \"order\": getattr(meta, \"order\", 9999),\n                \"plugin_obj\": self._instances.get(meta.name),\n            })\n        return items\n\n    def get(self, key: str):\n        \"\"\"\n        Retrieve a plugin instance by its key. If the plugin is not already instantiated,\n        it will attempt to load and instantiate it.\n\n        Args:\n            key: The unique name of the plugin.\n\n        Returns:\n            The plugin instance if successful, otherwise None.\n        \"\"\"\n        if key in self._instances:\n            return self._instances[key]\n        meta = self._meta_by_name(key)\n        if meta is None or not self._requirements_ok(meta):\n            return None\n        module = self._import_plugin_package(meta)\n        if module is None:\n            logging.warning(\"Cannot import plugin module for '%s'\", meta.name)\n            return None\n        factory_or_cls = self._resolve_entry_point(module, meta.entry_point)\n        if factory_or_cls is None:\n            logging.warning(\"No entry point found for plugin '%s'\", meta.name)\n            return None\n        try:\n            obj = factory_or_cls(self.parent)\n        except TypeError:\n            obj = factory_or_cls()\n        except Exception as exc:\n            logging.error(\"Failed to instantiate plugin '%s': %s\", meta.name, exc)\n            return None\n        self._instances[key] = obj\n        return obj\n\n    # Alias for compatibility\n    def plugin_by_key(self, key: str):\n        \"\"\"\n        Alias for the `get` method to retrieve a plugin instance by its key.\n        \"\"\"\n        return self.get(key)\n\n    def run(self, key: str, **context) -&gt; bool:\n        \"\"\"\n        Execute a plugin if it exposes one of the following methods:\n        run, exec, execute, show, or __call__.\n\n        Args:\n            key: The unique name of the plugin.\n            **context: Additional context to pass to the plugin's method.\n\n        Returns:\n            True if the plugin was successfully executed, otherwise False.\n        \"\"\"\n        obj = self.get(key)\n        if obj is None:\n            return False\n        for method in (\"run\", \"exec\", \"execute\", \"show\", \"__call__\"):\n            fn = getattr(obj, method, None)\n            if callable(fn):\n                try:\n                    fn(**context)\n                except TypeError:\n                    try:\n                        fn(self.parent)\n                    except Exception:\n                        fn()\n                return True\n        return False\n\n    # ---------------------------\n    # INTERNAL HELPERS for the instance\n    # ---------------------------\n    def _instantiate_from_meta(self, meta: PluginMeta):\n        \"\"\"\n        Import the plugin package, resolve the entry point in the imported module\n        (using _resolve_entry_point(module, entry_point)), and instantiate the object.\n\n        Args:\n            meta: The metadata of the plugin to instantiate.\n\n        Returns:\n            The instantiated plugin object, or None if instantiation fails.\n        \"\"\"\n        # Ensure the plugin folder is importable\n        if meta.path:\n            p = str(meta.path.resolve())\n            if p not in sys.path:\n                sys.path.insert(0, p)\n\n        module = self._import_plugin_package(meta)\n        if module is None:\n            logging.warning(\"Cannot import plugin module for '%s'\", meta.name)\n            return None\n\n        # Use the _resolve_entry_point method to find the factory/class\n        factory_or_cls = self._resolve_entry_point(module, meta.entry_point)\n        if factory_or_cls is None:\n            logging.warning(\"No entry point found for plugin '%s'\", meta.name)\n            return None\n\n        # Robust instantiation: first try factory(parent), then classes with various signatures\n        try:\n            return factory_or_cls(self.parent)\n        except TypeError:\n            # Try some common signatures\n            try:\n                return factory_or_cls(parent=self.parent, manager=self)\n            except TypeError:\n                try:\n                    return factory_or_cls(self.parent, self)\n                except TypeError:\n                    try:\n                        return factory_or_cls(parent=self.parent)\n                    except TypeError:\n                        try:\n                            return factory_or_cls(manager=self)\n                        except TypeError:\n                            try:\n                                return factory_or_cls()\n                            except Exception as exc:\n                                logging.error(\"Failed to instantiate plugin '%s': %s\", meta.name, exc)\n                                return None\n        except Exception as exc:\n            logging.error(\"Failed to instantiate plugin '%s': %s\", meta.name, exc)\n            return None\n</code></pre>"},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginManager.parent","title":"<code>parent = parent</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginManager.plugins_dir","title":"<code>plugins_dir = Path(plugins_dir).expanduser().resolve()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginManager.available_plugins","title":"<code>available_plugins()</code>","text":"<p>Return the list of discovered plugin names, sorted by order.</p> Source code in <code>src/c2f4dt/plugins/manager.py</code> <pre><code>def available_plugins(self) -&gt; List[str]:\n    \"\"\"Return the list of discovered plugin names, sorted by order.\"\"\"\n    return [m.name for m in self._metas]\n</code></pre>"},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginManager.get","title":"<code>get(key)</code>","text":"<p>Retrieve a plugin instance by its key. If the plugin is not already instantiated, it will attempt to load and instantiate it.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The unique name of the plugin.</p> required <p>Returns:</p> Type Description <p>The plugin instance if successful, otherwise None.</p> Source code in <code>src/c2f4dt/plugins/manager.py</code> <pre><code>def get(self, key: str):\n    \"\"\"\n    Retrieve a plugin instance by its key. If the plugin is not already instantiated,\n    it will attempt to load and instantiate it.\n\n    Args:\n        key: The unique name of the plugin.\n\n    Returns:\n        The plugin instance if successful, otherwise None.\n    \"\"\"\n    if key in self._instances:\n        return self._instances[key]\n    meta = self._meta_by_name(key)\n    if meta is None or not self._requirements_ok(meta):\n        return None\n    module = self._import_plugin_package(meta)\n    if module is None:\n        logging.warning(\"Cannot import plugin module for '%s'\", meta.name)\n        return None\n    factory_or_cls = self._resolve_entry_point(module, meta.entry_point)\n    if factory_or_cls is None:\n        logging.warning(\"No entry point found for plugin '%s'\", meta.name)\n        return None\n    try:\n        obj = factory_or_cls(self.parent)\n    except TypeError:\n        obj = factory_or_cls()\n    except Exception as exc:\n        logging.error(\"Failed to instantiate plugin '%s': %s\", meta.name, exc)\n        return None\n    self._instances[key] = obj\n    return obj\n</code></pre>"},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginManager.load_plugins","title":"<code>load_plugins()</code>","text":"<p>Instantiate and return all enabled plugins.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict mapping plugin name to the instantiated plugin object.</p> Source code in <code>src/c2f4dt/plugins/manager.py</code> <pre><code>def load_plugins(self) -&gt; Dict[str, Any]:\n    \"\"\"Instantiate and return all enabled plugins.\n\n    Returns:\n        Dict mapping plugin name to the instantiated plugin object.\n    \"\"\"\n    instances: Dict[str, Any] = {}\n    for meta in self._metas:\n        module = self._import_plugin_package(meta)\n        if module is None:\n            logging.warning(\"Cannot import plugin module for '%s'\", meta.name)\n            continue\n\n        factory_or_cls = self._resolve_entry_point(module, meta.entry_point)\n        if factory_or_cls is None:\n            logging.warning(\"No entry point found for plugin '%s'\", meta.name)\n            continue\n\n        try:\n            # Support both factory(parent) and class(parent)\n            obj = factory_or_cls(self.parent)\n        except TypeError:\n            # Maybe it's a zero-arg factory/class\n            obj = factory_or_cls()\n        except Exception as exc:\n            logging.error(\"Failed to instantiate plugin '%s': %s\", meta.name, exc)\n            continue\n\n        instances[meta.name] = obj\n    return instances\n</code></pre>"},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginManager.plugin_by_key","title":"<code>plugin_by_key(key)</code>","text":"<p>Alias for the <code>get</code> method to retrieve a plugin instance by its key.</p> Source code in <code>src/c2f4dt/plugins/manager.py</code> <pre><code>def plugin_by_key(self, key: str):\n    \"\"\"\n    Alias for the `get` method to retrieve a plugin instance by its key.\n    \"\"\"\n    return self.get(key)\n</code></pre>"},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginManager.run","title":"<code>run(key, **context)</code>","text":"<p>Execute a plugin if it exposes one of the following methods: run, exec, execute, show, or call.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The unique name of the plugin.</p> required <code>**context</code> <p>Additional context to pass to the plugin's method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the plugin was successfully executed, otherwise False.</p> Source code in <code>src/c2f4dt/plugins/manager.py</code> <pre><code>def run(self, key: str, **context) -&gt; bool:\n    \"\"\"\n    Execute a plugin if it exposes one of the following methods:\n    run, exec, execute, show, or __call__.\n\n    Args:\n        key: The unique name of the plugin.\n        **context: Additional context to pass to the plugin's method.\n\n    Returns:\n        True if the plugin was successfully executed, otherwise False.\n    \"\"\"\n    obj = self.get(key)\n    if obj is None:\n        return False\n    for method in (\"run\", \"exec\", \"execute\", \"show\", \"__call__\"):\n        fn = getattr(obj, method, None)\n        if callable(fn):\n            try:\n                fn(**context)\n            except TypeError:\n                try:\n                    fn(self.parent)\n                except Exception:\n                    fn()\n            return True\n    return False\n</code></pre>"},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginManager.ui_combo_items","title":"<code>ui_combo_items()</code>","text":"Elements to populate a combo box <ul> <li>key: meta.name</li> <li>label: meta.name</li> <li>enabled: whether requirements are satisfied</li> <li>tooltip, color, order</li> <li>plugin_obj: already created instance (if it exists)</li> </ul> Source code in <code>src/c2f4dt/plugins/manager.py</code> <pre><code>def ui_combo_items(self) -&gt; List[dict]:\n    \"\"\"\n    Elements to populate a combo box:\n     - key: meta.name\n     - label: meta.name\n     - enabled: whether requirements are satisfied\n     - tooltip, color, order\n     - plugin_obj: already created instance (if it exists)\n    \"\"\"\n    items: List[dict] = []\n    for meta in sorted(self._metas, key=lambda m: getattr(m, \"order\", 9999)):\n        _ok, missing = self._dependency_status(meta)  # &lt;-- uses dependency_status\n        ok = (len(missing) == 0)\n        items.append({\n            \"key\": meta.name,\n            \"label\": getattr(meta, \"name\", \"plugin\"),\n            \"enabled\": ok,\n            \"tooltip\": f\"{meta.name} {meta.version or ''}\".strip() + (\"\" if ok else f\" (missing: {', '.join(missing)})\"),\n            \"color\": \"green\" if ok else \"gray\",\n            \"order\": getattr(meta, \"order\", 9999),\n            \"plugin_obj\": self._instances.get(meta.name),\n        })\n    return items\n</code></pre>"},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginMeta","title":"<code>PluginMeta</code>  <code>dataclass</code>","text":"<p>Metadata for a plugin.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Public name of the plugin (also used as folder name).</p> <code>version</code> <code>Optional[str]</code> <p>Optional semantic version (e.g., \"0.1.0\") used in UI labels.</p> <code>order</code> <code>int</code> <p>Load order priority (lower loads first). Defaults to 100.</p> <code>requires</code> <code>Tuple[str, ...]</code> <p>Tuple of python import names that must be importable.</p> <code>entry_point</code> <code>Optional[str]</code> <p>Dotted entry point in the form \"module:attr\". If not provided, a callable named <code>load_plugin</code> inside the plugin package/module will be used when available.</p> <code>path</code> <code>Optional[Path]</code> <p>Absolute path to the plugin directory on disk.</p> Source code in <code>src/c2f4dt/plugins/manager.py</code> <pre><code>@dataclass\nclass PluginMeta:\n    \"\"\"Metadata for a plugin.\n\n    Attributes:\n        name: Public name of the plugin (also used as folder name).\n        version: Optional semantic version (e.g., \"0.1.0\") used in UI labels.\n        order: Load order priority (lower loads first). Defaults to 100.\n        requires: Tuple of python import names that must be importable.\n        entry_point: Dotted entry point in the form \"module:attr\". If not\n            provided, a callable named ``load_plugin`` inside the plugin\n            package/module will be used when available.\n        path: Absolute path to the plugin directory on disk.\n    \"\"\"\n\n    name: str\n    version: Optional[str] = None\n    order: int = 100\n    requires: Tuple[str, ...] = ()\n    entry_point: Optional[str] = None\n    path: Optional[Path] = None\n</code></pre>"},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginMeta.entry_point","title":"<code>entry_point = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginMeta.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginMeta.order","title":"<code>order = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginMeta.path","title":"<code>path = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginMeta.requires","title":"<code>requires = ()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/manager/#c2f4dt.plugins.manager.PluginMeta.version","title":"<code>version = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/","title":"c2f4dt.plugins.transform_rt","text":""},{"location":"api/c2f4dt/plugins/transform_rt/#c2f4dt.plugins.transform_rt","title":"<code>c2f4dt.plugins.transform_rt</code>","text":""},{"location":"api/c2f4dt/plugins/units/","title":"c2f4dt.plugins.units","text":""},{"location":"api/c2f4dt/plugins/units/#c2f4dt.plugins.units","title":"<code>c2f4dt.plugins.units</code>","text":""},{"location":"api/c2f4dt/plugins/vtk_import/","title":"c2f4dt.plugins.vtk_import","text":""},{"location":"api/c2f4dt/plugins/vtk_import/#c2f4dt.plugins.vtk_import","title":"<code>c2f4dt.plugins.vtk_import</code>","text":""},{"location":"api/c2f4dt/plugins/example_display_button/plugin/","title":"c2f4dt.plugins.example_display_button.plugin","text":""},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin","title":"<code>c2f4dt.plugins.example_display_button.plugin</code>","text":"<p>Example plugin: adds a panel with a button inside the scrollDISPLAY (DisplayPanel).</p>"},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin--how-integration-with-your-pluginmanager-works","title":"HOW INTEGRATION WITH YOUR PluginManager WORKS","text":"<ul> <li> <p>Your PluginManager:     1) Scans the \"plugins/\" folder looking for subfolders.     2) For each folder, reads \"plugin.yaml\" (if present) and determines:          - name, version, order, requires, entry_point = \"module:attribute\".     3) Imports the package \"plugins.\" (thanks to the plugins folder in the file system).     4) Resolves the entry_point: imports the submodule (here \"plugin\") and retrieves the attribute (here \"register\").     5) Calls the factory \"register(window)\" which must return the plugin instance. <li> <p>This file provides:</p> <ul> <li>a <code>DisplayButtonPlugin</code> class (QObject) that receives the MainWindow and modifies the UI.</li> <li>a <code>register(window)</code> function used as the entry-point by the manager.</li> </ul> </li>"},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin--where-the-button-ends-up","title":"WHERE THE BUTTON ENDS UP","text":"<ul> <li>Your UI has:         MainWindow.scrollDISPLAY  -&gt; QScrollArea             \u2514\u2500 widget()            -&gt; DisplayPanel (custom QWidget with an internal layout)</li> <li>We DO NOT touch the QScrollArea directly; we go to its content (DisplayPanel)     and add our <code>QGroupBox</code> with a button.</li> </ul>"},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin--simple-best-practices-for-your-plugins","title":"SIMPLE BEST PRACTICES FOR YOUR PLUGINS","text":"<ul> <li>Do not block the UI thread: if you perform long tasks, use QThread/worker (as you normally would).</li> <li>Avoid assuming overly specific layout details; use <code>layout().addWidget(...)</code> at the end.</li> <li>Provide an <code>actions()</code> (or <code>get_actions()</code>) method to make commands appear in the Plugins menu.</li> <li>If you add elements to the scene or panel, consider a <code>teardown()</code> method to clean up (optional).</li> </ul>"},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin.DisplayButtonPlugin","title":"<code>DisplayButtonPlugin</code>","text":"<p>               Bases: <code>QObject</code></p> Minimal plugin that <p>1) Inserts a panel into the DisplayPanel with a \"Hello from Plugin\" button. 2) Exposes an action in the &amp;Plugins menu (\"Say Hello\") that displays a message.</p> <p>The constructor receives the MainWindow (window) from the PluginManager.</p> Source code in <code>src/c2f4dt/plugins/example_display_button/plugin.py</code> <pre><code>class DisplayButtonPlugin(QtCore.QObject):\n    \"\"\"\n    Minimal plugin that:\n      1) Inserts a panel into the DisplayPanel with a \"Hello from Plugin\" button.\n      2) Exposes an action in the &amp;Plugins menu (\"Say Hello\") that displays a message.\n\n    The constructor receives the MainWindow (window) from the PluginManager.\n    \"\"\"\n\n    def __init__(self, window: QtWidgets.QMainWindow):\n        super().__init__(window)\n        self.window = window  # reference to the host MainWindow\n        self._panel_box: Optional[QtWidgets.QGroupBox] = None  # our group box in the panel\n\n        # Try to add the panel immediately. If the DisplayPanel is not ready yet,\n        # you can defer with a singleShot(0, ...) or connect to a \"ready\" signal.\n        self._inject_panel_box()\n\n        # (optional) Create a QAction and add it to the Tools or Plugins menu.\n        # Alternatively, implement actions()/get_actions() (see below).\n        try:\n            mb = window.menuBar()\n            m_plugins = None\n            for a in mb.actions():\n                if a.text().replace(\"&amp;\", \"\") == \"Plugins\":\n                    m_plugins = a.menu()\n                    break\n            if m_plugins is None:\n                m_plugins = mb.addMenu(\"&amp;Plugins\")\n            act = QtGui.QAction(\"Say Hello (example_display_button)\", self)\n            act.triggered.connect(self.say_hello)\n            m_plugins.addAction(act)\n        except Exception:\n            # if it fails (menu missing), it's not critical: the manager will use actions()\n            pass\n\n    # -----------------------\n    # UI injection helpers\n    # -----------------------\n    def _display_panel(self) -&gt; Optional[QtWidgets.QWidget]:\n        \"\"\"\n        Returns the DisplayPanel widget (content of the QScrollArea scrollDISPLAY).\n        \"\"\"\n        try:\n            panel = getattr(self.window, \"displayPanel\", None)\n            if isinstance(panel, QtWidgets.QWidget):\n                return panel\n        except Exception:\n            pass\n        # fallback: try to retrieve from the scroll area\n        try:\n            scroll = getattr(self.window, \"scrollDISPLAY\", None)\n            if isinstance(scroll, QtWidgets.QScrollArea):\n                return scroll.widget()\n        except Exception:\n            pass\n        return None\n\n    def _inject_panel_box(self) -&gt; None:\n        \"\"\"\n        Creates a QGroupBox with a button and adds it to the end of the DisplayPanel layout.\n        \"\"\"\n        panel = self._display_panel()\n        if panel is None:\n            # DisplayPanel not ready? retry after the current event\n            QtCore.QTimer.singleShot(0, self._inject_panel_box)\n            return\n\n        lay = panel.layout()\n        if lay is None:\n            # if the panel has no layout (unlikely), create a vertical one\n            lay = QtWidgets.QVBoxLayout(panel)\n            panel.setLayout(lay)\n\n        # Build our group box\n        box = QtWidgets.QGroupBox(\"Example plugin panel\")\n        v = QtWidgets.QVBoxLayout(box)\n\n        # Descriptive label\n        lbl = QtWidgets.QLabel(\n            \"This panel was added by a plugin.\\n\"\n            \"You can use it as a starting point to create your own controls.\"\n        )\n        lbl.setWordWrap(True)\n        v.addWidget(lbl)\n\n        # Example button\n        btn = QtWidgets.QPushButton(\"Hello from Plugin\")\n        btn.setObjectName(\"btnHelloFromPlugin\")\n        btn.clicked.connect(self._on_click)\n        v.addWidget(btn)\n\n        # (Optional) additional UI: checkbox, slider, etc.\n        chk = QtWidgets.QCheckBox(\"Also show a message in the console\")\n        chk.setObjectName(\"chkPluginConsoleEcho\")\n        chk.setChecked(True)\n        v.addWidget(chk)\n\n        # Store references if needed\n        self._panel_box = box\n        self._btn = btn\n        self._chk_echo = chk\n\n        # Add the group box to the end of the panel\n        lay.addWidget(box)\n\n    # -----------------------\n    # Slots / Actions\n    # -----------------------\n    @QtCore.Slot()\n    def _on_click(self) -&gt; None:\n        \"\"\"\n        Slot for the button in the panel: shows a message box and optionally writes to the console.\n        \"\"\"\n        QtWidgets.QMessageBox.information(self.window, \"Example Plugin\", \"Hello \ud83d\udc4b from example_display_button!\")\n        # Echo to the console (if present and allowed by the checkbox)\n        try:\n            if getattr(self, \"_chk_echo\", None) and self._chk_echo.isChecked():\n                console = getattr(self.window, \"console\", None)\n                if console is not None and hasattr(console, \"appendPlainText\"):\n                    console.appendPlainText(\"# example_display_button: hello clicked\")\n        except Exception:\n            pass\n\n    @QtCore.Slot()\n    def say_hello(self) -&gt; None:\n        \"\"\"\n        Menu action: identical to the button action, but callable from the Plugins menu.\n        \"\"\"\n        self._on_click()\n\n    # -----------------------\n    # API that your MainWindow already supports\n    # -----------------------\n    def actions(self):\n        \"\"\"\n        Returns a list of structured actions that the MainWindow attaches to the Plugins menu.\n        See MainWindow._rebuild_plugins_menu/_invoke_plugin_action.\n        \"\"\"\n        return [\n            {\n                \"label\": \"Say Hello\",\n                \"tooltip\": \"Displays a courtesy message\",\n                \"slot\": self.say_hello,  # direct callable\n            },\n            {\n                \"label\": \"Focus Hello Button\",\n                \"tooltip\": \"Brings focus to the button in the DisplayPanel\",\n                \"slot\": self.focus_button,\n            },\n        ]\n\n    def focus_button(self):\n        \"\"\"Brings focus to the button created by the plugin (if it exists).\"\"\"\n        try:\n            if getattr(self, \"_btn\", None) is not None:\n                self._btn.setFocus()\n                # visual feedback\n                self._btn.animateClick(150)\n        except Exception:\n            pass\n\n    # (Optional) Method that your systems can call as a \"default run\"\n    def run(self, *_, **__):\n        \"\"\"\n        Default entry-point if you launch the plugin from the combo without actions:\n        focuses the button so it's immediately visible where it was added.\n        \"\"\"\n        self.focus_button()\n\n    # (Optional) if you want to clean up UI/actors when the plugin is destroyed\n    def teardown(self):\n        \"\"\"\n        Removes the box from the DisplayPanel (best-effort).\n        You can call this manually if you foresee plugin unload/refresh.\n        \"\"\"\n        try:\n            if self._panel_box is not None:\n                parent = self._panel_box.parent()\n                self._panel_box.setParent(None)\n                self._panel_box.deleteLater()\n                # if needed, clean up other references\n                self._panel_box = None\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin.DisplayButtonPlugin.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin.DisplayButtonPlugin.actions","title":"<code>actions()</code>","text":"<p>Returns a list of structured actions that the MainWindow attaches to the Plugins menu. See MainWindow._rebuild_plugins_menu/_invoke_plugin_action.</p> Source code in <code>src/c2f4dt/plugins/example_display_button/plugin.py</code> <pre><code>def actions(self):\n    \"\"\"\n    Returns a list of structured actions that the MainWindow attaches to the Plugins menu.\n    See MainWindow._rebuild_plugins_menu/_invoke_plugin_action.\n    \"\"\"\n    return [\n        {\n            \"label\": \"Say Hello\",\n            \"tooltip\": \"Displays a courtesy message\",\n            \"slot\": self.say_hello,  # direct callable\n        },\n        {\n            \"label\": \"Focus Hello Button\",\n            \"tooltip\": \"Brings focus to the button in the DisplayPanel\",\n            \"slot\": self.focus_button,\n        },\n    ]\n</code></pre>"},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin.DisplayButtonPlugin.focus_button","title":"<code>focus_button()</code>","text":"<p>Brings focus to the button created by the plugin (if it exists).</p> Source code in <code>src/c2f4dt/plugins/example_display_button/plugin.py</code> <pre><code>def focus_button(self):\n    \"\"\"Brings focus to the button created by the plugin (if it exists).\"\"\"\n    try:\n        if getattr(self, \"_btn\", None) is not None:\n            self._btn.setFocus()\n            # visual feedback\n            self._btn.animateClick(150)\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin.DisplayButtonPlugin.run","title":"<code>run(*_, **__)</code>","text":"<p>Default entry-point if you launch the plugin from the combo without actions: focuses the button so it's immediately visible where it was added.</p> Source code in <code>src/c2f4dt/plugins/example_display_button/plugin.py</code> <pre><code>def run(self, *_, **__):\n    \"\"\"\n    Default entry-point if you launch the plugin from the combo without actions:\n    focuses the button so it's immediately visible where it was added.\n    \"\"\"\n    self.focus_button()\n</code></pre>"},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin.DisplayButtonPlugin.say_hello","title":"<code>say_hello()</code>","text":"<p>Menu action: identical to the button action, but callable from the Plugins menu.</p> Source code in <code>src/c2f4dt/plugins/example_display_button/plugin.py</code> <pre><code>@QtCore.Slot()\ndef say_hello(self) -&gt; None:\n    \"\"\"\n    Menu action: identical to the button action, but callable from the Plugins menu.\n    \"\"\"\n    self._on_click()\n</code></pre>"},{"location":"api/c2f4dt/plugins/example_display_button/plugin/#c2f4dt.plugins.example_display_button.plugin.DisplayButtonPlugin.teardown","title":"<code>teardown()</code>","text":"<p>Removes the box from the DisplayPanel (best-effort). You can call this manually if you foresee plugin unload/refresh.</p> Source code in <code>src/c2f4dt/plugins/example_display_button/plugin.py</code> <pre><code>def teardown(self):\n    \"\"\"\n    Removes the box from the DisplayPanel (best-effort).\n    You can call this manually if you foresee plugin unload/refresh.\n    \"\"\"\n    try:\n        if self._panel_box is not None:\n            parent = self._panel_box.parent()\n            self._panel_box.setParent(None)\n            self._panel_box.deleteLater()\n            # if needed, clean up other references\n            self._panel_box = None\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/","title":"c2f4dt.plugins.transform_rt.plugin","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin","title":"<code>c2f4dt.plugins.transform_rt.plugin</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TargetEntry","title":"<code>TargetEntry</code>  <code>dataclass</code>","text":"Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>@dataclass\nclass TargetEntry:\n    key: str          # dataset index as string or logical key\n    label: str        # shown in combo\n    rec: dict         # original record for direct access\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TargetEntry.key","title":"<code>key</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TargetEntry.label","title":"<code>label</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TargetEntry.rec","title":"<code>rec</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformDialog","title":"<code>TransformDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog to transform datasets and load a .conf placement file.</p> Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>class TransformDialog(QtWidgets.QDialog):\n    \"\"\"Dialog to transform datasets and load a .conf placement file.\"\"\"\n\n    def __init__(self, window):\n        super().__init__(window)\n        self.window = window\n        self.viewer = window.viewer3d\n        self.setWindowTitle(\"Rotation / Translation\")\n        self.setModal(False)\n\n        self.targets: List[TargetEntry] = self._collect_targets()\n        self._build_ui()\n        self._fill_targets()\n\n    # ---- data collect ----\n    def _collect_targets(self) -&gt; List[TargetEntry]:\n        out: List[TargetEntry] = []\n        dsets = getattr(self.viewer, \"_datasets\", [])\n        for i, rec in enumerate(dsets):\n            # Build a readable label including filename if available\n            base = os.path.basename(rec.get(\"source_path\") or f\"dataset_{i}\")\n            kind = rec.get(\"kind\", \"?\")\n            label = f\"[{i}] {base}  ({kind})\"\n            out.append(TargetEntry(str(i), label, rec))\n        return out\n\n    def _notify_tree_added(self, parent_index: int | None, rec_new: dict, label: str) -&gt; None:\n        \"\"\"Best-effort: notify the host to add/update the tree for a new dataset.\n\n        We try a few host methods in order. If none is present, we fall back to\n        forcing a full tree refresh.\n        \"\"\"\n        w = self.window\n\n        # Prefer explicit \"add child\" signatures if available\n        for name in (\"treeAddChild\", \"_tree_add_child\", \"tree_add_child\"):\n            fn = getattr(w, name, None)\n            if callable(fn):\n                try:\n                    fn(parent_index, rec_new, label)\n                    return\n                except Exception:\n                    pass\n\n        # Try a generic \"add dataset\"\n        for name in (\"treeAddDataset\", \"_tree_add_dataset\", \"tree_add_dataset\"):\n            fn = getattr(w, name, None)\n            if callable(fn):\n                try:\n                    fn(rec_new, parent_index)\n                    return\n                except Exception:\n                    pass\n\n        # Fall back to full rebuild/refresh\n        for name in (\"_rebuild_tree_from_datasets\", \"rebuild_tree_from_datasets\", \"_refresh_tree_visibility\"):\n            fn = getattr(w, name, None)\n            if callable(fn):\n                try:\n                    fn()\n                    return\n                except Exception:\n                    pass\n\n        # Last resort: silent\n        try:\n            w._append_message(\"[Transform] Added duplicated dataset; tree update fallback used.\")\n        except Exception:\n            pass\n\n    # ---- UI ----\n    def _build_ui(self):\n        \"\"\"Build dialog UI.\n\n        Rows:\n          1) Dataset selector\n          2) Buttons: Load .conf  |  Reset Transformation\n          3) Translation group\n          4) Rotations row: Euler (left)  +  Quaternion (right)\n          5) Action buttons on two rows:\n             - Row A: Show transformation   |   Apply (overwrite)\n             - Row B: Duplicate cloud\n        \"\"\"\n        layout = QtWidgets.QVBoxLayout(self)\n\n        # --- Row 1: dataset selector ---\n        row_target = QtWidgets.QHBoxLayout()\n        row_target.addWidget(QtWidgets.QLabel(\"Dataset\"))\n        self.cmbTarget = QtWidgets.QComboBox()\n        row_target.addWidget(self.cmbTarget, 1)\n        layout.addLayout(row_target)\n\n        # --- Row 2: .conf + reset ---\n        row_conf = QtWidgets.QHBoxLayout()\n        self.btnLoadConf = QtWidgets.QPushButton(\"Load .conf\u2026\")\n        self.btnReset = QtWidgets.QPushButton(\"Reset transformation\")\n        self.btnLoadConf.setToolTip(\"Load a placement .conf file and apply transforms by filename\")\n        self.btnReset.setToolTip(\"Clear any temporary (UserMatrix) transform on the selected dataset actor\")\n        row_conf.addWidget(self.btnLoadConf)\n        row_conf.addStretch(1)\n        row_conf.addWidget(self.btnReset)\n        layout.addLayout(row_conf)\n\n        # --- Row 3: translation ---\n        grpT = QtWidgets.QGroupBox(\"Translation\")\n        formT = QtWidgets.QFormLayout(grpT)\n        self.spinTx = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinTx)\n        self.spinTy = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinTy)\n        self.spinTz = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinTz)\n        formT.addRow(\"Tx\", self.spinTx)\n        formT.addRow(\"Ty\", self.spinTy)\n        formT.addRow(\"Tz\", self.spinTz)\n        layout.addWidget(grpT)\n\n        # --- Row 3.5: scale (anisotropic) ---\n        grpS = QtWidgets.QGroupBox(\"Scale (Sx, Sy, Sz)\")\n        formS = QtWidgets.QFormLayout(grpS)\n        self.spinSx = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinSx, 1e-6, 1e6, 0.001); self.spinSx.setValue(1.0)\n        self.spinSy = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinSy, 1e-6, 1e6, 0.001); self.spinSy.setValue(1.0)\n        self.spinSz = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinSz, 1e-6, 1e6, 0.001); self.spinSz.setValue(1.0)\n        formS.addRow(\"Sx\", self.spinSx)\n        formS.addRow(\"Sy\", self.spinSy)\n        formS.addRow(\"Sz\", self.spinSz)\n        layout.addWidget(grpS)\n\n        # --- Row 3.6: pivot (scale/rotate around this point) ---\n        grpP = QtWidgets.QGroupBox(\"Pivot (Px, Py, Pz)\")\n        formP = QtWidgets.QFormLayout(grpP)\n        self.spinPx = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinPx, -1e6, 1e6, 0.01); self.spinPx.setValue(0.0)\n        self.spinPy = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinPy, -1e6, 1e6, 0.01); self.spinPy.setValue(0.0)\n        self.spinPz = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinPz, -1e6, 1e6, 0.01); self.spinPz.setValue(0.0)\n        formP.addRow(\"Px\", self.spinPx)\n        formP.addRow(\"Py\", self.spinPy)\n        formP.addRow(\"Pz\", self.spinPz)\n        layout.addWidget(grpP)\n\n        # --- Row 4: rotations (Euler + Quaternion) side-by-side ---\n        row_rot = QtWidgets.QHBoxLayout()\n\n        grpR = QtWidgets.QGroupBox(\"Rotation (Euler, deg, XYZ)\")\n        formR = QtWidgets.QFormLayout(grpR)\n        self.spinRx = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinRx, -360, 360, 0.1)\n        self.spinRy = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinRy, -360, 360, 0.1)\n        self.spinRz = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinRz, -360, 360, 0.1)\n        formR.addRow(\"Rx\", self.spinRx)\n        formR.addRow(\"Ry\", self.spinRy)\n        formR.addRow(\"Rz\", self.spinRz)\n        row_rot.addWidget(grpR, 1)\n\n        grpQ = QtWidgets.QGroupBox(\"Rotation (Quaternion x, y, z, w)\")\n        formQ = QtWidgets.QFormLayout(grpQ)\n        self.spinQx = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinQx, -1e6, 1e6, 1e-6)\n        self.spinQy = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinQy, -1e6, 1e6, 1e-6)\n        self.spinQz = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinQz, -1e6, 1e6, 1e-6)\n        self.spinQw = QtWidgets.QDoubleSpinBox(); self._cfg_spin(self.spinQw, -1e6, 1e6, 1e-6); self.spinQw.setValue(1.0)\n        formQ.addRow(\"Qx\", self.spinQx)\n        formQ.addRow(\"Qy\", self.spinQy)\n        formQ.addRow(\"Qz\", self.spinQz)\n        formQ.addRow(\"Qw\", self.spinQw)\n        row_rot.addWidget(grpQ, 1)\n\n        layout.addLayout(row_rot)\n\n        # --- Row 5: action buttons on two rows ---\n        # Row A: Show | Apply\n        rowA = QtWidgets.QHBoxLayout()\n        self.btnShow = QtWidgets.QPushButton(\"Show transformation\")\n        self.btnApply = QtWidgets.QPushButton(\"Apply (overwrite)\")\n        self.btnShow.setToolTip(\"Temporarily show the transform using the actor UserMatrix (non-destructive).\")\n        self.btnApply.setToolTip(\"Bake the transform into the dataset geometry and clear the temporary matrix.\")\n        rowA.addWidget(self.btnShow)\n        rowA.addStretch(1)\n        rowA.addWidget(self.btnApply)\n\n        # Row B: Duplicate\n        rowB = QtWidgets.QHBoxLayout()\n        self.btnDuplicate = QtWidgets.QPushButton(\"Duplicate cloud\")\n        self.btnDuplicate.setToolTip(\"Create a new dataset with the transformed geometry (original untouched).\")\n        rowB.addStretch(1)\n        rowB.addWidget(self.btnDuplicate)\n\n        layout.addLayout(rowA)\n        layout.addLayout(rowB)\n\n        # --- Connections ---\n        # Live sync: when Euler changes, update quaternion\n        for sp in (self.spinRx, self.spinRy, self.spinRz):\n            sp.valueChanged.connect(self._sync_quat_from_euler)\n\n        self.btnReset.clicked.connect(self._on_reset_transform)\n        self.btnLoadConf.clicked.connect(self._on_load_conf)\n        self.btnShow.clicked.connect(self._on_show_only)\n        self.btnApply.clicked.connect(self._on_apply_baked)\n        self.btnDuplicate.clicked.connect(self._on_duplicate)\n\n        # Width for side panel friendliness\n        self.setMinimumWidth(380)\n        self.resize(420, self.sizeHint().height())\n\n    def _cfg_spin(self, sp: QtWidgets.QDoubleSpinBox, mn=-1e6, mx=1e6, step=0.01):\n        sp.setRange(mn, mx)\n        sp.setDecimals(6)\n        sp.setSingleStep(step)\n\n    def _fill_targets(self):\n        self.cmbTarget.clear()\n        for t in self.targets:\n            self.cmbTarget.addItem(t.label, t.key)\n\n    # ---- actions ----\n    def _sync_quat_from_euler(self):\n        \"\"\"Recompute quaternion from current Euler and update the 4 spin boxes.\n        We block signals to avoid feedback loops.\"\"\"\n        qx, qy, qz, qw = euler_deg_to_quat(\n            self.spinRx.value(), self.spinRy.value(), self.spinRz.value(), \"XYZ\"\n        )\n        for sp, val in ((self.spinQx, qx), (self.spinQy, qy), (self.spinQz, qz), (self.spinQw, qw)):\n            sp.blockSignals(True)\n            sp.setValue(val)\n            sp.blockSignals(False)\n\n    def _current_params(self):\n        \"\"\"Return current (T, Q, S, P) tuples from the UI.\"\"\"\n        T = (self.spinTx.value(), self.spinTy.value(), self.spinTz.value())\n        Q = (self.spinQx.value(), self.spinQy.value(), self.spinQz.value(), self.spinQw.value())\n        S = (self.spinSx.value(), self.spinSy.value(), self.spinSz.value())\n        P = (self.spinPx.value(), self.spinPy.value(), self.spinPz.value())\n        return T, Q, S, P\n\n    def _actor_for_current(self):\n        idx_str = self.cmbTarget.currentData()\n        if idx_str is None:\n            return None, None\n        try:\n            ds = int(idx_str)\n        except Exception:\n            return None, None\n        rec = self._get_record(ds)\n        if rec is None:\n            return None, None\n        act = _get_record_actor(rec)\n        return rec, act\n\n    def _on_show_only(self):\n        \"\"\"Apply the transform as a temporary UserMatrix on the actor only (non-destructive).\"\"\"\n        rec, act = self._actor_for_current()\n        if act is None:\n            return\n        T, Q, S, P = self._current_params()\n        M = compose_trs_scale_pivot(*T, *Q, *S, *P)\n        with _ProgressHelper(self.window, \"Previewing transform\u2026\", total=2) as pg:\n            apply_actor_user_matrix(act, M); pg.step()\n            self._refresh(); pg.step()\n\n    def _on_apply_baked(self):\n        \"\"\"Bake the transform into the dataset geometry and clear the temporary matrix.\"\"\"\n        rec, act = self._actor_for_current()\n        if rec is None:\n            return\n        T, Q, S, P = self._current_params()\n        M = compose_trs_scale_pivot(*T, *Q, *S, *P)\n\n        with _ProgressHelper(self.window, \"Applying transform\u2026\", total=3) as pg:\n            ok = self._bake_transform_into_record(rec, M); pg.step()\n            clear_actor_user_matrix(act); pg.step()\n            self._refresh(); pg.step()\n\n        try:\n            self.window._append_message(\"[Transform] Apply (overwrite): \" + (\"OK\" if ok else \"FAILED\"))\n        except Exception:\n            pass\n\n    def _on_duplicate(self):\n        \"\"\"Create a new dataset with transformed geometry, keep original untouched.\"\"\"\n        rec, _act = self._actor_for_current()\n        if rec is None:\n            return\n        T, Q, S, P = self._current_params()\n        M = compose_trs_scale_pivot(*T, *Q, *S, *P)\n\n        with _ProgressHelper(self.window, \"Duplicating dataset\u2026\", total=2) as pg:\n            ok = self._duplicate_record_transformed(rec, M); pg.step()\n            self._refresh(); pg.step()\n\n        if not ok:\n            QtWidgets.QMessageBox.warning(self, \"Duplicate cloud\", \"Could not duplicate the dataset with current viewer API.\")\n        else:\n            try:\n                self.window._append_message(\"[Transform] Duplicate cloud: OK\")\n            except Exception:\n                pass\n    # ---- geometry ops ----\n\n    def _apply_affine_to_points(self, pts_np, M4):\n        \"\"\"Return transformed Nx3 points applying 4x4 matrix.\"\"\"\n        try:\n            import numpy as _np\n            M = _np.asarray(M4, dtype=float)\n            P = _np.asarray(pts_np, dtype=float)\n            if P.ndim != 2 or P.shape[1] != 3:\n                return None\n            Ph = _np.c_[P, _np.ones((P.shape[0], 1))]\n            P2 = (Ph @ M.T)[:, :3]\n            return P2\n        except Exception:\n            return None\n\n    def _bake_transform_into_record(self, rec: dict, M4) -&gt; bool:\n        \"\"\"Modify the underlying dataset geometry in-place.\n        Works for both points-polydata and mesh (unstructured/surface).\"\"\"\n        try:\n            import pyvista as pv\n        except Exception:\n            return False\n        # Points dataset\n        if rec.get(\"kind\") == \"points\":\n            pd = rec.get(\"full_pdata\") or rec.get(\"pdata\")\n            if pd is None:\n                return False\n            P2 = self._apply_affine_to_points(pd.points, M4)\n            if P2 is None:\n                return False\n            pd.points = P2\n            if rec.get(\"pdata\") is not pd:\n                try:\n                    rec[\"pdata\"].points = P2\n                except Exception:\n                    pass\n            act = rec.get(\"actor_points\")\n            if act is not None:\n                try:\n                    mapper = getattr(act, \"GetMapper\", lambda: None)()\n                    if mapper is not None and hasattr(mapper, \"SetInputData\"):\n                        mapper.SetInputData(pd)\n                except Exception:\n                    pass\n            return True\n\n        # Mesh dataset\n        if rec.get(\"kind\") == \"mesh\":\n            mesh = rec.get(\"mesh\")\n            if mesh is None:\n                return False\n            P2 = self._apply_affine_to_points(mesh.points, M4)\n            if P2 is None:\n                return False\n            mesh.points = P2\n            act = rec.get(\"actor_mesh\")\n            if act is not None:\n                try:\n                    mapper = getattr(act, \"GetMapper\", lambda: None)()\n                    if mapper is not None and hasattr(mapper, \"SetInputData\"):\n                        mapper.SetInputData(mesh)\n                except Exception:\n                    pass\n            return True\n\n        return False\n\n    def _append_new_points_dataset(self, poly, label: str, parent_ds: int | None) -&gt; bool:\n        \"\"\"Best-effort: append a new points dataset to the viewer and tree.\n\n        We also try to register a parent/child relation by storing 'parent'\n        on the new record when possible, so that the MainWindow can render a\n        branch in the tree (if it supports it).\n        \"\"\"\n        v = self.viewer\n\n        # First, try explicit viewer APIs if present (optional)\n        for name in (\"add_points_dataset\", \"add_points_polydata\", \"add_polydata\"):\n            fn = getattr(v, name, None)\n            if callable(fn):\n                try:\n                    fn(poly, label=label)\n                except TypeError:\n                    # Fallback to single-arg signatures\n                    try:\n                        fn(poly)\n                    except Exception:\n                        pass\n                break\n\n        # Always keep a local record for consistency with the app's registry\n        try:\n            actor = v.plotter.add_mesh(\n                poly,\n                render_points_as_spheres=getattr(v, \"_points_as_spheres\", False),\n                point_size=3,\n                name=label,\n            )\n        except Exception:\n            actor = None\n\n        rec_new = {\n            \"kind\": \"points\",\n            \"full_pdata\": poly,\n            \"pdata\": poly,\n            \"actor_points\": actor,\n            \"source_path\": None,         # new derived geometry, no original file\n            \"name\": label,               # human label used by the tree when available\n            \"visible\": True,\n            \"point_size\": 3,\n            \"view_percent\": 100,\n            \"color_mode\": \"Normal Colormap\",\n            \"cmap\": \"viridis\",\n            \"points_as_spheres\": getattr(v, \"_points_as_spheres\", False),\n            \"parent\": int(parent_ds) if parent_ds is not None else None,\n        }\n        getattr(v, \"_datasets\", []).append(rec_new)\n\n        # Tell the UI tree to add a child under parent_ds (best effort)\n        try:\n            self._notify_tree_added(parent_ds, rec_new, label)\n        except Exception:\n            pass\n\n        # Refresh view\n        try:\n            self.window.viewer3d.refresh()\n        except Exception:\n            pass\n        return True\n\n    def _append_new_mesh_dataset(self, mesh, label: str, parent_ds: int | None) -&gt; bool:\n        \"\"\"Best-effort: append a new mesh dataset to the viewer and tree, tracking parent.\"\"\"\n        v = self.viewer\n\n        for name in (\"add_mesh_dataset\", \"add_mesh_polydata\", \"add_unstructured\"):\n            fn = getattr(v, name, None)\n            if callable(fn):\n                try:\n                    fn(mesh, label=label)\n                except TypeError:\n                    try:\n                        fn(mesh)\n                    except Exception:\n                        pass\n                break\n\n        try:\n            actor = v.plotter.add_mesh(mesh, name=label, show_edges=False, opacity=1.0)\n        except Exception:\n            actor = None\n\n        rec_new = {\n            \"kind\": \"mesh\",\n            \"mesh\": mesh,\n            \"actor_mesh\": actor,\n            \"source_path\": None,\n            \"name\": label,\n            \"visible\": True,\n            \"representation\": \"surface\",\n            \"opacity\": 100,\n            \"solid_color\": (1.0, 1.0, 1.0),\n            \"parent\": int(parent_ds) if parent_ds is not None else None,\n        }\n        getattr(v, \"_datasets\", []).append(rec_new)\n\n        try:\n            self._notify_tree_added(parent_ds, rec_new, label)\n        except Exception:\n            pass\n\n        try:\n            self.window.viewer3d.refresh()\n        except Exception:\n            pass\n        return True\n\n    def _duplicate_record_transformed(self, rec: dict, M4) -&gt; bool:\n        \"\"\"Create a new dataset as a transformed copy.\"\"\"\n        try:\n            import numpy as _np\n        except Exception:\n            return False\n\n        # Determine parent dataset index for tree relationship (if possible)\n        parent_ds: int | None = None\n        try:\n            dsets = getattr(self.viewer, \"_datasets\", [])\n            parent_ds = dsets.index(rec)\n        except Exception:\n            parent_ds = None\n\n        base_name = os.path.basename(rec.get(\"source_path\") or rec.get(\"name\") or \"dataset\")\n        # Build a concise suffix as requested: _RT (Rotation/Translation)\n        label = f\"{base_name}_RT\"\n\n        if rec.get(\"kind\") == \"points\":\n            src = rec.get(\"full_pdata\") or rec.get(\"pdata\")\n            if src is None:\n                return False\n            dst = src.copy(deep=True)\n            pts2 = self._apply_affine_to_points(dst.points, M4)\n            if pts2 is None:\n                return False\n            dst.points = pts2\n            return self._append_new_points_dataset(dst, label, parent_ds)\n\n        if rec.get(\"kind\") == \"mesh\":\n            src = rec.get(\"mesh\")\n            if src is None:\n                return False\n            dst = src.copy(deep=True)\n            pts2 = self._apply_affine_to_points(dst.points, M4)\n            if pts2 is None:\n                return False\n            dst.points = pts2\n            return self._append_new_mesh_dataset(dst, label, parent_ds)\n\n        return False\n\n    def _on_reset_transform(self):\n        idx_str = self.cmbTarget.currentData()\n        if idx_str is None:\n            return\n        try:\n            ds = int(idx_str)\n        except Exception:\n            return\n        rec = self._get_record(ds)\n        if rec is None:\n            return\n        act = _get_record_actor(rec)\n        clear_actor_user_matrix(act)\n        self._refresh()\n\n    def _on_load_conf(self):\n        # .conf lines:\n        # camera cx cy cz  qx qy qz qw\n        # bmesh filename.ply tx ty tz  qx qy qz qw\n        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, \"Open placement .conf\", \"\", \"Conf (*.conf *.txt);;All (*)\")\n        if not path:\n            return\n        try:\n            with open(path, \"r\") as f:\n                lines = [ln.strip() for ln in f if ln.strip() and not ln.strip().startswith(\"#\")]\n        except Exception as exc:\n            QtWidgets.QMessageBox.warning(self, \"Load .conf\", f\"Failed to read file:\\n{exc}\")\n            return\n\n        applied = 0\n        with _ProgressHelper(self.window, f\"Applying {os.path.basename(path)}\u2026\", total=max(1, len(lines))) as pg:\n            for ln in lines:\n                tokens = ln.split()\n                if not tokens:\n                    pg.step(); continue\n                kind = tokens[0].lower()\n                if kind == \"camera\":\n                    if len(tokens) &gt;= 8:\n                        cx, cy, cz = map(float, tokens[1:4])\n                        qx, qy, qz, qw = map(float, tokens[4:8])\n                        self._apply_camera((cx, cy, cz), (qx, qy, qz, qw))\n                elif kind in (\"bmesh\", \"mesh\", \"points\"):\n                    if len(tokens) &gt;= 9:\n                        fname = tokens[1]\n                        tx, ty, tz = map(float, tokens[2:5])\n                        qx, qy, qz, qw = map(float, tokens[5:9])\n                        if self._apply_by_filename(fname, (tx, ty, tz), (qx, qy, qz, qw)):\n                            applied += 1\n                pg.step()\n\n        self._refresh()\n        QtWidgets.QMessageBox.information(self, \"Load .conf\", f\"Applied transforms to {applied} dataset(s).\")\n\n    # ---- helpers ----\n\n    def _get_record(self, ds_index: int) -&gt; Optional[dict]:\n        dsets = getattr(self.viewer, \"_datasets\", [])\n        if 0 &lt;= ds_index &lt; len(dsets):\n            return dsets[ds_index]\n        return None\n\n    def _apply_to_dataset_index(self, ds_index: int, T: Tuple[float,float,float], Q: Tuple[float,float,float,float]) -&gt; None:\n        rec = self._get_record(ds_index)\n        if rec is None:\n            return\n        act = _get_record_actor(rec)\n        if act is None:\n            return\n        M = compose_trs(T[0], T[1], T[2], Q[0], Q[1], Q[2], Q[3])\n        apply_actor_user_matrix(act, M)\n        self._refresh()\n\n    def _apply_by_filename(self, filename: str, T: Tuple[float,float,float], Q: Tuple[float,float,float,float]) -&gt; bool:\n        \"\"\"Match by basename against rec['source_path'] or fallback to label.\"\"\"\n        base = os.path.basename(filename)\n        dsets = getattr(self.viewer, \"_datasets\", [])\n        hit = False\n        for i, rec in enumerate(dsets):\n            sp = rec.get(\"source_path\")\n            ok = False\n            if sp:\n                ok = (os.path.basename(sp) == base)\n            else:\n                # fallback: try label key\n                ok = (base in (os.path.basename(sp or f\"dataset_{i}\")))\n            if not ok:\n                continue\n            act = _get_record_actor(rec)\n            if act is None:\n                continue\n            M = compose_trs(T[0], T[1], T[2], Q[0], Q[1], Q[2], Q[3])\n            apply_actor_user_matrix(act, M)\n            hit = True\n        return hit\n\n    def _apply_camera(self, pos: Tuple[float,float,float], q: Tuple[float,float,float,float]) -&gt; None:\n        \"\"\"Apply camera position+orientation if available from .conf.\"\"\"\n        try:\n            # Convert quaternion to view-up and view-direction\n            # We rotate basis vectors by R(q): forward = R*[0,0,-1], up = R*[0,1,0]\n            M = quat_to_mat4(*q)\n            fwd = ( -M[0][2], -M[1][2], -M[2][2] )\n            up  = (  M[0][1],  M[1][1],  M[2][1] )\n            cam = self.viewer.plotter.camera\n            cam.position = pos\n            cam.focal_point = (pos[0] + fwd[0], pos[1] + fwd[1], pos[2] + fwd[2])\n            cam.up = up\n        except Exception:\n            pass\n\n    def _refresh(self):\n        try:\n            self.viewer.plotter.update()\n            self.viewer.refresh()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformDialog.targets","title":"<code>targets = self._collect_targets()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformDialog.viewer","title":"<code>viewer = window.viewer3d</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformDialog.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformRTPlugin","title":"<code>TransformRTPlugin</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Wire menu entry and dialog into the host MainWindow.</p> Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>class TransformRTPlugin(QtCore.QObject):\n    \"\"\"Wire menu entry and dialog into the host MainWindow.\"\"\"\n    def __init__(self, window):\n        super().__init__(window)\n        self.window = window\n        self.dialog: Optional[TransformDialog] = None\n\n        self.action = QtGui.QAction(QtGui.QIcon(), \"Rotation/Translation\u2026\", self)\n        self.action.setShortcut(QtGui.QKeySequence(\"Ctrl+T\"))\n        self.action.triggered.connect(lambda _checked=False: self.open_dialog())\n\n        # Add to Tools menu (create if missing)\n        try:\n            mb = window.menuBar()\n            m_tools = None\n            for act in mb.actions():\n                if act.text().replace(\"&amp;\", \"\") == \"Tools\":\n                    m_tools = act.menu()\n                    break\n            if m_tools is None:\n                m_tools = mb.addMenu(\"&amp;Tools\")\n            m_tools.addAction(self.action)\n        except Exception:\n            pass\n\n    @QtCore.Slot()\n    def open_dialog(self):\n        if self.dialog is None:\n            self.dialog = TransformDialog(self.window)\n        # Refresh target list each time (datasets may have changed)\n        self.dialog.targets = self.dialog._collect_targets()\n        self.dialog._fill_targets()\n        try:\n            self.dialog._sync_quat_from_euler()\n        except Exception:\n            pass\n        self.dialog.show()\n        self.dialog.raise_()\n        self.dialog.activateWindow()\n\n    # Allow PluginManager.run(\"transform_rt\")\n    def run(self, *_, **__):\n        self.open_dialog()\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformRTPlugin.action","title":"<code>action = QtGui.QAction(QtGui.QIcon(), 'Rotation/Translation\u2026', self)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformRTPlugin.dialog","title":"<code>dialog = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformRTPlugin.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformRTPlugin.open_dialog","title":"<code>open_dialog()</code>","text":"Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>@QtCore.Slot()\ndef open_dialog(self):\n    if self.dialog is None:\n        self.dialog = TransformDialog(self.window)\n    # Refresh target list each time (datasets may have changed)\n    self.dialog.targets = self.dialog._collect_targets()\n    self.dialog._fill_targets()\n    try:\n        self.dialog._sync_quat_from_euler()\n    except Exception:\n        pass\n    self.dialog.show()\n    self.dialog.raise_()\n    self.dialog.activateWindow()\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.TransformRTPlugin.run","title":"<code>run(*_, **__)</code>","text":"Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>def run(self, *_, **__):\n    self.open_dialog()\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.apply_actor_user_matrix","title":"<code>apply_actor_user_matrix(actor, M)</code>","text":"<p>Set an actor UserMatrix to apply TRS without altering the dataset.</p> Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>def apply_actor_user_matrix(actor, M: List[List[float]]) -&gt; None:\n    \"\"\"Set an actor UserMatrix to apply TRS without altering the dataset.\"\"\"\n    if actor is None:\n        return\n    mat = to_vtk_matrix4x4(M)\n    if mat is None:\n        return\n    try:\n        actor.SetUserMatrix(mat)\n    except Exception:\n        # Some wrappers expose .user_matrix\n        try:\n            actor.user_matrix = mat\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.clear_actor_user_matrix","title":"<code>clear_actor_user_matrix(actor)</code>","text":"<p>Remove any user matrix (reset transform).</p> Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>def clear_actor_user_matrix(actor) -&gt; None:\n    \"\"\"Remove any user matrix (reset transform).\"\"\"\n    if actor is None:\n        return\n    try:\n        actor.SetUserMatrix(None)\n    except Exception:\n        try:\n            actor.user_matrix = None\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.compose_trs_scale_pivot","title":"<code>compose_trs_scale_pivot(tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, px, py, pz)</code>","text":"<p>Build a 4x4 matrix for: Translate * Tpivot * Rotate * Scale * T(-pivot).</p> Order rationale <ul> <li>Scale happens in local object space first</li> <li>Rotate around the same pivot</li> <li>Then translate in world</li> </ul> Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>def compose_trs_scale_pivot(\n    tx: float, ty: float, tz: float,\n    qx: float, qy: float, qz: float, qw: float,\n    sx: float, sy: float, sz: float,\n    px: float, py: float, pz: float,\n) -&gt; list[list[float]]:\n    \"\"\"\n    Build a 4x4 matrix for: Translate * Tpivot * Rotate * Scale * T(-pivot).\n\n    Order rationale:\n      - Scale happens in local object space first\n      - Rotate around the same pivot\n      - Then translate in world\n    \"\"\"\n    # Rotation (4x4)\n    R = quat_to_mat4(qx, qy, qz, qw)\n\n    # Scale (4x4)\n    S = [\n        [float(sx), 0.0,       0.0,       0.0],\n        [0.0,       float(sy), 0.0,       0.0],\n        [0.0,       0.0,       float(sz), 0.0],\n        [0.0,       0.0,       0.0,       1.0],\n    ]\n\n    # Translation matrices for pivot and its inverse\n    T_p = [\n        [1.0, 0.0, 0.0, float(px)],\n        [0.0, 1.0, 0.0, float(py)],\n        [0.0, 0.0, 1.0, float(pz)],\n        [0.0, 0.0, 0.0, 1.0],\n    ]\n    T_n = [\n        [1.0, 0.0, 0.0, -float(px)],\n        [0.0, 1.0, 0.0, -float(py)],\n        [0.0, 0.0, 1.0, -float(pz)],\n        [0.0, 0.0, 0.0, 1.0],\n    ]\n\n    # World translation\n    T = [\n        [1.0, 0.0, 0.0, float(tx)],\n        [0.0, 1.0, 0.0, float(ty)],\n        [0.0, 0.0, 1.0, float(tz)],\n        [0.0, 0.0, 0.0, 1.0],\n    ]\n\n    # Compose: T * Tpivot * R * S * T(-pivot)\n    M = mat4_mul(T_p, S)\n    M = mat4_mul(R, M)\n    M = mat4_mul(T, mat4_mul(T_p, mat4_mul(R, mat4_mul(S, T_n))))  # clarity version\n    # The previous line re-expands to emphasize order; keep as-is for readability.\n    return M\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.euler_deg_to_quat","title":"<code>euler_deg_to_quat(rx_deg, ry_deg, rz_deg, order='XYZ')</code>","text":"<p>Convert Euler angles in degrees to quaternion (x, y, z, w). Uses intrinsic rotations and order 'XYZ' by default (tweak if needed).</p> Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>def euler_deg_to_quat(rx_deg: float, ry_deg: float, rz_deg: float, order: str = \"XYZ\") -&gt; Tuple[float, float, float, float]:\n    \"\"\"Convert Euler angles in degrees to quaternion (x, y, z, w).\n    Uses intrinsic rotations and order 'XYZ' by default (tweak if needed).\"\"\"\n    rx = math.radians(rx_deg)\n    ry = math.radians(ry_deg)\n    rz = math.radians(rz_deg)\n\n    # Basic XYZ -&gt; quaternion composition\n    # q = qx(rx) * qy(ry) * qz(rz)\n    def qx(a): return (math.sin(a/2), 0.0, 0.0, math.cos(a/2))\n    def qy(a): return (0.0, math.sin(a/2), 0.0, math.cos(a/2))\n    def qz(a): return (0.0, 0.0, math.sin(a/2), math.cos(a/2))\n\n    def qmul(q1, q2):\n        x1,y1,z1,w1 = q1\n        x2,y2,z2,w2 = q2\n        return (\n            w1*x2 + x1*w2 + y1*z2 - z1*y2,\n            w1*y2 - x1*z2 + y1*w2 + z1*x2,\n            w1*z2 + x1*y2 - y1*x2 + z1*w2,\n            w1*w2 - x1*x2 - y1*y2 - z1*z2\n        )\n\n    seq = []\n    for c,a in zip(order.upper(), (rx, ry, rz)):\n        if c == \"X\": seq.append(qx(a))\n        elif c == \"Y\": seq.append(qy(a))\n        else: seq.append(qz(a))\n\n    q = seq[0]\n    q = qmul(q, seq[1])\n    q = qmul(q, seq[2])\n    return q  # (x, y, z, w)\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.mat4_mul","title":"<code>mat4_mul(A, B)</code>","text":"<p>4x4 matrix multiply: return A @ B.</p> Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>def mat4_mul(A, B):\n    \"\"\"4x4 matrix multiply: return A @ B.\"\"\"\n    return [\n        [\n            A[r][0]*B[0][c] + A[r][1]*B[1][c] + A[r][2]*B[2][c] + A[r][3]*B[3][c]\n            for c in range(4)\n        ]\n        for r in range(4)\n    ]\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.quat_to_mat4","title":"<code>quat_to_mat4(qx, qy, qz, qw)</code>","text":"<p>Convert quaternion (x, y, z, w) to a 3x3 rotation matrix embedded in 4x4.</p> Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>def quat_to_mat4(qx: float, qy: float, qz: float, qw: float) -&gt; List[List[float]]:\n    \"\"\"Convert quaternion (x, y, z, w) to a 3x3 rotation matrix embedded in 4x4.\"\"\"\n    # Normalize quaternion for safety\n    norm = math.sqrt(qx*qx + qy*qy + qz*qz + qw*qw)\n    if norm == 0:\n        qx, qy, qz, qw = 0.0, 0.0, 0.0, 1.0\n    else:\n        qx, qy, qz, qw = qx/norm, qy/norm, qz/norm, qw/norm\n\n    xx, yy, zz = qx*qx, qy*qy, qz*qz\n    xy, xz, yz = qx*qy, qx*qz, qy*qz\n    wx, wy, wz = qw*qx, qw*qy, qw*qz\n\n    m00 = 1.0 - 2.0*(yy + zz)\n    m01 = 2.0*(xy - wz)\n    m02 = 2.0*(xz + wy)\n\n    m10 = 2.0*(xy + wz)\n    m11 = 1.0 - 2.0*(xx + zz)\n    m12 = 2.0*(yz - wx)\n\n    m20 = 2.0*(xz - wy)\n    m21 = 2.0*(yz + wx)\n    m22 = 1.0 - 2.0*(xx + yy)\n\n    return [\n        [m00, m01, m02, 0.0],\n        [m10, m11, m12, 0.0],\n        [m20, m21, m22, 0.0],\n        [0.0,  0.0,  0.0,  1.0],\n    ]\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.register","title":"<code>register(window)</code>","text":"Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>def register(window):\n    return TransformRTPlugin(window)\n</code></pre>"},{"location":"api/c2f4dt/plugins/transform_rt/plugin/#c2f4dt.plugins.transform_rt.plugin.to_vtk_matrix4x4","title":"<code>to_vtk_matrix4x4(M)</code>","text":"<p>Create a vtkMatrix4x4 from a python 4x4 list.</p> Source code in <code>src/c2f4dt/plugins/transform_rt/plugin.py</code> <pre><code>def to_vtk_matrix4x4(M: List[List[float]]):\n    \"\"\"Create a vtkMatrix4x4 from a python 4x4 list.\"\"\"\n    try:\n        import vtk\n    except Exception:\n        return None\n    mat = vtk.vtkMatrix4x4()\n    for r in range(4):\n        for c in range(4):\n            mat.SetElement(r, c, float(M[r][c]))\n    return mat\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/","title":"c2f4dt.plugins.units.plugin","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin","title":"<code>c2f4dt.plugins.units.plugin</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.FORCE","title":"<code>FORCE = {'N': 1.0, 'kN': 1000.0, 'MN': 1000000.0, 'lbf': 4.4482216153}</code>  <code>module-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.LEN","title":"<code>LEN = {'m': 1.0, 'cm': 0.01, 'mm': 0.001, '\u00b5m': 1e-06, 'in': 0.0254, 'ft': 0.3048}</code>  <code>module-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.MASS","title":"<code>MASS = {'kg': 1.0, 'g': 0.001, 't': 1000.0, 'lb': 0.45359237}</code>  <code>module-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.PRESSURE","title":"<code>PRESSURE = {'Pa': 1.0, 'kPa': 1000.0, 'MPa': 1000000.0, 'GPa': 1000000000.0, 'bar': 100000.0, 'psi': 6894.757293168}</code>  <code>module-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.TEMP","title":"<code>TEMP = {'\u00b0C': ('C',), 'K': ('K',), '\u00b0F': ('F',)}</code>  <code>module-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.TIME","title":"<code>TIME = {'s': 1.0, 'ms': 0.001, 'min': 60.0, 'h': 3600.0}</code>  <code>module-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsDialog","title":"<code>UnitsDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Dialog to select units and perform quick conversions.</p> Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>class UnitsDialog(QtWidgets.QDialog):\n    \"\"\"Dialog to select units and perform quick conversions.\"\"\"\n    sigUnitsChanged = QtCore.Signal(object)  # emits UnitsState\n\n    def __init__(self, parent=None, initial: Optional[UnitsState] = None):\n        super().__init__(parent)\n        self.setWindowTitle(\"Units &amp; Scale\")\n        self._state = initial or UnitsState()\n        self._build_ui()\n        self._apply_state(self._state)\n\n    def _build_ui(self) -&gt; None:\n        form = QtWidgets.QFormLayout(self)\n\n        # Base units combos\n        self.cmbLen = QtWidgets.QComboBox(); self.cmbLen.addItems(list(LEN.keys()))\n        self.cmbMass = QtWidgets.QComboBox(); self.cmbMass.addItems(list(MASS.keys()))\n        self.cmbTime = QtWidgets.QComboBox(); self.cmbTime.addItems(list(TIME.keys()))\n        self.cmbForce = QtWidgets.QComboBox(); self.cmbForce.addItems(list(FORCE.keys()))\n        self.cmbTemp = QtWidgets.QComboBox(); self.cmbTemp.addItems(list(TEMP.keys()))\n\n        # Derived editable (pressure), the rest informative\n        self.cmbPressure = QtWidgets.QComboBox(); self.cmbPressure.addItems(list(PRESSURE.keys()))\n        self.lblDensity = QtWidgets.QLabel(\"kg/m\u00b3\")\n        self.lblEnergy = QtWidgets.QLabel(\"J\")\n\n        form.addRow(\"Length\", self.cmbLen)\n        form.addRow(\"Mass\", self.cmbMass)\n        form.addRow(\"Time\", self.cmbTime)\n        form.addRow(\"Force\", self.cmbForce)\n        form.addRow(\"Temperature\", self.cmbTemp)\n        form.addRow(QtWidgets.QLabel(\"&lt;b&gt;Derived&lt;/b&gt;\"))\n        form.addRow(\"Pressure\", self.cmbPressure)\n        form.addRow(\"Density\", self.lblDensity)\n        form.addRow(\"Energy\", self.lblEnergy)\n        # Overlay text size control\n        self.spinOverlayFont = QtWidgets.QSpinBox()\n        self.spinOverlayFont.setRange(8, 36)\n        self.spinOverlayFont.setValue(10)\n        form.addRow(\"Overlay font\", self.spinOverlayFont)\n\n        # Quick converter\n        box = QtWidgets.QGroupBox(\"Quick convert\")\n        h = QtWidgets.QHBoxLayout(box)\n        self.spinValue = QtWidgets.QDoubleSpinBox(); self.spinValue.setRange(-1e12, 1e12); self.spinValue.setDecimals(6); self.spinValue.setValue(1.0)\n        self.cmbFrom = QtWidgets.QComboBox(); self.cmbTo = QtWidgets.QComboBox()\n        self.lblResult = QtWidgets.QLineEdit(); self.lblResult.setReadOnly(True)\n        # default to length\n        self.cmbFrom.addItems(list(LEN.keys()))\n        self.cmbTo.addItems(list(LEN.keys()))\n        h.addWidget(self.spinValue); h.addWidget(self.cmbFrom); h.addWidget(QtWidgets.QLabel(\"\u2192\")); h.addWidget(self.cmbTo); h.addWidget(self.lblResult, 1)\n        form.addRow(box)\n\n        # Buttons\n        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel)\n        form.addRow(btns)\n\n        # Signals\n        for cmb in (self.cmbLen, self.cmbMass, self.cmbTime, self.cmbForce, self.cmbTemp, self.cmbPressure):\n            cmb.currentTextChanged.connect(self._on_units_changed)\n        for w in (self.spinValue, self.cmbFrom, self.cmbTo):\n            if hasattr(w, \"valueChanged\"):\n                w.valueChanged.connect(self._on_convert)\n            else:\n                w.currentTextChanged.connect(self._on_convert)\n        btns.accepted.connect(self.accept)\n        btns.rejected.connect(self.reject)\n\n    def _apply_state(self, st: UnitsState) -&gt; None:\n        self.cmbLen.setCurrentText(st.length)\n        self.cmbMass.setCurrentText(st.mass)\n        self.cmbTime.setCurrentText(st.time)\n        self.cmbForce.setCurrentText(st.force)\n        self.cmbTemp.setCurrentText(st.temperature)\n        st.suggest_derived()\n        self.cmbPressure.setCurrentText(st.pressure)\n        self.lblDensity.setText(\"kg/m\u00b3\")  # informative only\n        self.lblEnergy.setText(\"J\")\n        # apply overlay font size\n        try:\n            self.spinOverlayFont.setValue(int(getattr(st, \"overlay_font_size\", 10)))\n        except Exception:\n            self.spinOverlayFont.setValue(10)\n        self._on_convert()\n\n    def _on_units_changed(self) -&gt; None:\n        st = UnitsState(\n            length=self.cmbLen.currentText(),\n            mass=self.cmbMass.currentText(),\n            time=self.cmbTime.currentText(),\n            force=self.cmbForce.currentText(),\n            temperature=self.cmbTemp.currentText(),\n            pressure=self.cmbPressure.currentText(),\n            overlay_font_size=int(self.spinOverlayFont.value()),\n        )\n        st.suggest_derived()\n        self._state = st\n        self.sigUnitsChanged.emit(st)\n        self._on_convert()\n\n    def _on_convert(self) -&gt; None:\n        v = self.spinValue.value()\n        u_from = self.cmbFrom.currentText()\n        u_to = self.cmbTo.currentText()\n\n        # try linear (length/force/pressure)\n        try:\n            dic = None\n            for table in (LEN, FORCE, PRESSURE):\n                if u_from in table and u_to in table:\n                    dic = table; break\n            if dic:\n                out = convert_linear(v, dic, u_from, u_to)\n                self.lblResult.setText(f\"{out:.6g}\")\n                return\n        except Exception:\n            pass\n        # temperature?\n        if u_from in TEMP and u_to in TEMP:\n            try:\n                out = convert_temperature(v, u_from, u_to)\n                self.lblResult.setText(f\"{out:.6g}\")\n                return\n            except Exception:\n                pass\n        self.lblResult.setText(\"\u2014\")\n\n    def state(self) -&gt; UnitsState:\n        return self._state\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsDialog.sigUnitsChanged","title":"<code>sigUnitsChanged = QtCore.Signal(object)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsDialog.state","title":"<code>state()</code>","text":"Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>def state(self) -&gt; UnitsState:\n    return self._state\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsOverlay","title":"<code>UnitsOverlay</code>","text":"<p>Manages a fixed, screen-anchored units text overlay (bottom-right).</p> Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>class UnitsOverlay:\n    \"\"\"Manages a fixed, screen-anchored units text overlay (bottom-right).\"\"\"\n    def __init__(self, viewer3d):\n        self.viewer = viewer3d\n        self._text_id = None  # handle/name used by the plotter/host\n\n    def show_text(self, units: UnitsState) -&gt; None:\n        \"\"\"Show/update the units text in the bottom-right corner.\n\n        Respects the font size stored in the UnitsState (overlay_font_size).\n        \"\"\"\n        txt = (\n            f\"Units: L={units.length}, F={units.force}, \"\n            f\"p={units.pressure}, T={units.temperature}\"\n        )\n        font_sz = int(getattr(units, \"overlay_font_size\", 10))\n        try:\n            # Prefer a dedicated overlay API if the host provides it\n            method = getattr(self.viewer, \"add_overlay_text\", None)\n            if callable(method):\n                if self._text_id is None:\n                    self._text_id = method(\"units_overlay\", txt, pos=\"lower_right\", font_size=font_sz)\n                else:\n                    # If host supports updating with font size, pass it; otherwise just update text\n                    update = getattr(self.viewer, \"update_overlay_text\", None)\n                    if callable(update):\n                        try:\n                            update(\"units_overlay\", txt, font_size=font_sz)\n                        except TypeError:\n                            update(\"units_overlay\", txt)\n            else:\n                # Fallback: plotter.add_text at lower_right with given font size\n                if self._text_id is None:\n                    self._text_id = self.viewer.plotter.add_text(\n                        txt, position=\"lower_right\", font_size=font_sz, name=\"units_overlay_text\"\n                    )\n                else:\n                    try:\n                        self.viewer.plotter.remove_actor(\"units_overlay_text\")\n                    except Exception:\n                        pass\n                    self._text_id = self.viewer.plotter.add_text(\n                        txt, position=\"lower_right\", font_size=font_sz, name=\"units_overlay_text\"\n                    )\n            self.viewer.refresh()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsOverlay.viewer","title":"<code>viewer = viewer3d</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsOverlay.show_text","title":"<code>show_text(units)</code>","text":"<p>Show/update the units text in the bottom-right corner.</p> <p>Respects the font size stored in the UnitsState (overlay_font_size).</p> Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>def show_text(self, units: UnitsState) -&gt; None:\n    \"\"\"Show/update the units text in the bottom-right corner.\n\n    Respects the font size stored in the UnitsState (overlay_font_size).\n    \"\"\"\n    txt = (\n        f\"Units: L={units.length}, F={units.force}, \"\n        f\"p={units.pressure}, T={units.temperature}\"\n    )\n    font_sz = int(getattr(units, \"overlay_font_size\", 10))\n    try:\n        # Prefer a dedicated overlay API if the host provides it\n        method = getattr(self.viewer, \"add_overlay_text\", None)\n        if callable(method):\n            if self._text_id is None:\n                self._text_id = method(\"units_overlay\", txt, pos=\"lower_right\", font_size=font_sz)\n            else:\n                # If host supports updating with font size, pass it; otherwise just update text\n                update = getattr(self.viewer, \"update_overlay_text\", None)\n                if callable(update):\n                    try:\n                        update(\"units_overlay\", txt, font_size=font_sz)\n                    except TypeError:\n                        update(\"units_overlay\", txt)\n        else:\n            # Fallback: plotter.add_text at lower_right with given font size\n            if self._text_id is None:\n                self._text_id = self.viewer.plotter.add_text(\n                    txt, position=\"lower_right\", font_size=font_sz, name=\"units_overlay_text\"\n                )\n            else:\n                try:\n                    self.viewer.plotter.remove_actor(\"units_overlay_text\")\n                except Exception:\n                    pass\n                self._text_id = self.viewer.plotter.add_text(\n                    txt, position=\"lower_right\", font_size=font_sz, name=\"units_overlay_text\"\n                )\n        self.viewer.refresh()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsPlugin","title":"<code>UnitsPlugin</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Wires menu entry, dialog, and overlay into the host MainWindow.</p> Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>class UnitsPlugin(QtCore.QObject):\n    \"\"\"Wires menu entry, dialog, and overlay into the host MainWindow.\"\"\"\n    def __init__(self, window):\n        super().__init__(window)\n        self.window = window\n        self.state = UnitsState()\n        self.overlay = UnitsOverlay(window.viewer3d)\n        self.overlay.show_text(self.state)\n\n        # QAction in Tools menu (or Plugins)\n        self.action = QtGui.QAction(QtGui.QIcon(), \"Units &amp; Scale\u2026\", self)\n        # \u2b07\ufe0f evita che Qt passi l'argomento 'checked' al metodo\n        self.action.triggered.connect(lambda _checked=False: self.open_dialog())\n\n        # try to add under Tools\n        try:\n            mb = window.menuBar()\n            m_tools = None\n            for a in mb.actions():\n                if a.text().replace(\"&amp;\", \"\") == \"Tools\":\n                    m_tools = a.menu(); break\n            if m_tools is None:\n                m_tools = mb.addMenu(\"&amp;Tools\")\n            m_tools.addAction(self.action)\n        except Exception:\n            pass\n\n    # Accetta anche il bool opzionale\n    @QtCore.Slot(bool)\n    def open_dialog(self, checked: bool = False):\n        dlg = UnitsDialog(self.window, initial=self.state)\n        dlg.sigUnitsChanged.connect(self._on_units_changed_live)  # live preview\n        if dlg.exec() == QtWidgets.QDialog.Accepted:\n            self.state = dlg.state()\n            # (eventuale persistenza)\n        # refresh finale in entrambi i casi\n        self.overlay.show_text(self.state)\n\n    def _on_units_changed_live(self, st: UnitsState):\n        self.state = st\n        self.overlay.show_text(st)\n\n    # \u2b07\ufe0f cos\u00ec il PluginManager pu\u00f2 \u201ceseguire\u201d il plugin\n    def run(self, *args, **kwargs):\n        return self.open_dialog(False)\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsPlugin.action","title":"<code>action = QtGui.QAction(QtGui.QIcon(), 'Units &amp; Scale\u2026', self)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsPlugin.overlay","title":"<code>overlay = UnitsOverlay(window.viewer3d)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsPlugin.state","title":"<code>state = UnitsState()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsPlugin.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsPlugin.open_dialog","title":"<code>open_dialog(checked=False)</code>","text":"Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>@QtCore.Slot(bool)\ndef open_dialog(self, checked: bool = False):\n    dlg = UnitsDialog(self.window, initial=self.state)\n    dlg.sigUnitsChanged.connect(self._on_units_changed_live)  # live preview\n    if dlg.exec() == QtWidgets.QDialog.Accepted:\n        self.state = dlg.state()\n        # (eventuale persistenza)\n    # refresh finale in entrambi i casi\n    self.overlay.show_text(self.state)\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsPlugin.run","title":"<code>run(*args, **kwargs)</code>","text":"Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>def run(self, *args, **kwargs):\n    return self.open_dialog(False)\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState","title":"<code>UnitsState</code>  <code>dataclass</code>","text":"Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>@dataclass\nclass UnitsState:\n    length: str = \"m\"\n    mass: str = \"kg\"\n    time: str = \"s\"\n    force: str = \"N\"\n    temperature: str = \"\u00b0C\"\n    pressure: str = \"Pa\"   # derived, user-overridable\n    density: str = \"kg/m\u00b3\" # derived, informative\n    energy: str = \"J\"      # derived, informative\n    overlay_font_size: int = 10  # overlay text size (points)\n\n    def suggest_derived(self) -&gt; None:\n        \"\"\"Set sensible defaults for derived quantities based on base units.\"\"\"\n        # pressure suggestion from force/length\n        # keep user's explicit choice if already set to something consistent\n        default_pressure = \"Pa\"\n        if self.force in (\"kN\", \"MN\") and self.length in (\"m\",):\n            default_pressure = \"MPa\"  # common in mech\n        elif self.force in (\"N\",) and self.length in (\"m\",):\n            default_pressure = \"Pa\"\n        elif self.length in (\"mm\", \"cm\"):\n            default_pressure = \"MPa\"  # still convenient\n        self.pressure = self.pressure or default_pressure\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.density","title":"<code>density = 'kg/m\u00b3'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.energy","title":"<code>energy = 'J'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.force","title":"<code>force = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.length","title":"<code>length = 'm'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.mass","title":"<code>mass = 'kg'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.overlay_font_size","title":"<code>overlay_font_size = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.pressure","title":"<code>pressure = 'Pa'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.temperature","title":"<code>temperature = '\u00b0C'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.time","title":"<code>time = 's'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.UnitsState.suggest_derived","title":"<code>suggest_derived()</code>","text":"<p>Set sensible defaults for derived quantities based on base units.</p> Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>def suggest_derived(self) -&gt; None:\n    \"\"\"Set sensible defaults for derived quantities based on base units.\"\"\"\n    # pressure suggestion from force/length\n    # keep user's explicit choice if already set to something consistent\n    default_pressure = \"Pa\"\n    if self.force in (\"kN\", \"MN\") and self.length in (\"m\",):\n        default_pressure = \"MPa\"  # common in mech\n    elif self.force in (\"N\",) and self.length in (\"m\",):\n        default_pressure = \"Pa\"\n    elif self.length in (\"mm\", \"cm\"):\n        default_pressure = \"MPa\"  # still convenient\n    self.pressure = self.pressure or default_pressure\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.convert_linear","title":"<code>convert_linear(value, u_from, from_unit, to_unit)</code>","text":"<p>Generic linear factor conversion (e.g., length, force, pressure).</p> Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>def convert_linear(value: float, u_from: Dict[str, float], from_unit: str, to_unit: str) -&gt; float:\n    \"\"\"Generic linear factor conversion (e.g., length, force, pressure).\"\"\"\n    f = u_from[from_unit]\n    t = u_from[to_unit]\n    return value * (f / t)\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.convert_temperature","title":"<code>convert_temperature(value, from_unit, to_unit)</code>","text":"<p>Handle \u00b0C/\u00b0F/K non-linear conversions.</p> Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>def convert_temperature(value: float, from_unit: str, to_unit: str) -&gt; float:\n    \"\"\"Handle \u00b0C/\u00b0F/K non-linear conversions.\"\"\"\n    if from_unit == to_unit:\n        return float(value)\n    # to Kelvin\n    if from_unit == \"K\":\n        k = float(value)\n    elif from_unit == \"\u00b0C\":\n        k = float(value) + 273.15\n    elif from_unit == \"\u00b0F\":\n        k = (float(value) - 32.0) * 5.0/9.0 + 273.15\n    else:\n        raise ValueError(\"Unknown temperature unit\")\n    # from Kelvin\n    if to_unit == \"K\":\n        return k\n    if to_unit == \"\u00b0C\":\n        return k - 273.15\n    if to_unit == \"\u00b0F\":\n        return (k - 273.15) * 9.0/5.0 + 32.0\n    raise ValueError(\"Unknown temperature unit\")\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.load_plugin","title":"<code>load_plugin(parent)</code>","text":"Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>def load_plugin(parent):\n    return UnitsPlugin(parent)\n</code></pre>"},{"location":"api/c2f4dt/plugins/units/plugin/#c2f4dt.plugins.units.plugin.register","title":"<code>register(parent)</code>","text":"Source code in <code>src/c2f4dt/plugins/units/plugin.py</code> <pre><code>def register(parent):\n    return UnitsPlugin(parent)\n</code></pre>"},{"location":"api/c2f4dt/plugins/vtk_import/plugin/","title":"c2f4dt.plugins.vtk_import.plugin","text":""},{"location":"api/c2f4dt/plugins/vtk_import/plugin/#c2f4dt.plugins.vtk_import.plugin","title":"<code>c2f4dt.plugins.vtk_import.plugin</code>","text":"<p>VTK Import &amp; Display plugin for C2F4DT.</p>"},{"location":"api/c2f4dt/plugins/vtk_import/plugin/#c2f4dt.plugins.vtk_import.plugin--what-the-plugin-does","title":"WHAT THE PLUGIN DOES","text":"<ul> <li>Adds a menu entry: File \u25b8 Import VTK\u2026 (with shortcut)</li> <li>Imports a single VTK/VTU/VTP/VTM/VTS/VTR/VTI/OBJ/STL file</li> <li>If MultiBlock: keeps a single actor (as preferred)</li> <li>If the reader exposes <code>time_values</code>: adds a simple time-slider in the box</li> <li>Creates a \u201cVTK Display\u201d box in the scrollDISPLAY with ParaView-style controls:<ul> <li>Representation: Points / Wireframe / Surface / Surface with Edges / Volume (if applicable)</li> <li>Color by: Solid Color / arrays (PointData/CellData), for vectors Mag/ X / Y / Z</li> <li>LUT + invert, Rescale to Data, Scalar Bar On/Off</li> <li>Opacity, Point Size, Line Width</li> <li>Edge visibility + Edge color</li> <li>Basic lighting (toggle)</li> </ul> </li> <li>Applies changes live to the \u201ccurrent\u201d dataset (selected in treeMCTS)</li> <li>Saves the <code>source_path</code> + essential choices in mcts (extendable towards a \u201cstyle file\u201d)</li> </ul>"},{"location":"api/c2f4dt/plugins/vtk_import/plugin/#c2f4dt.plugins.vtk_import.plugin--how-to-adapt-it","title":"HOW TO ADAPT IT","text":"<ul> <li>See the <code>_apply_*</code> methods to map the UI controls to your Viewer3D APIs</li> <li>If an API is unavailable, the <code>TODO</code> points indicate where to add the fallback</li> </ul>"},{"location":"api/c2f4dt/plugins/vtk_import/plugin/#c2f4dt.plugins.vtk_import.plugin.VTKImportPlugin","title":"<code>VTKImportPlugin</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Plugin \u201cVTK Import &amp; Display\u201d.</p> Structure <ul> <li>Menu action + shortcut for import</li> <li>Display control box, applied to the current dataset</li> <li>Best effort detection of time-series via PyVista reader</li> </ul> Source code in <code>src/c2f4dt/plugins/vtk_import/plugin.py</code> <pre><code>class VTKImportPlugin(QtCore.QObject):\n    \"\"\"\n    Plugin \u201cVTK Import &amp; Display\u201d.\n\n    Structure:\n      - Menu action + shortcut for import\n      - Display control box, applied to the current dataset\n      - Best effort detection of time-series via PyVista reader\n    \"\"\"\n    def __init__(self, window):\n        super().__init__(window)\n        self.window = window\n\n        # UI state (for current dataset - updates on each selection in the tree)\n        self._current_ds: Optional[int] = None\n        self._time_values: Optional[List[float]] = None\n        self._time_idx: int = 0\n\n        # ----- Menu &amp; shortcuts --------------------------------------\n        self._action_import = QtGui.QAction(QtGui.QIcon(), \"Import VTK\u2026\", self)\n        # Shortcut: \u2318\u21e7I (mac) / Ctrl+Shift+I (others)\n        self._action_import.setShortcut(QtGui.QKeySequence(\"Ctrl+Shift+I\"))\n        # Note: Qt automatically adjusts shortcuts on macOS to use Cmd based on the platform shortcut context\n        self._action_import.triggered.connect(self.open_dialog)\n\n        # Aggiungi in File\n        try:\n            mb = window.menuBar()\n            for a in mb.actions():\n                if a.text().replace(\"&amp;\", \"\") == \"File\":\n                    a.menu().addAction(self._action_import)\n                    break\n        except Exception:\n            pass\n\n        # ----- Box UI in DisplayPanel ---------------------------------\n        self._panel = self._build_display_box()\n        _add_to_display_panel(window, \"VTK Display\", self._panel)\n\n        # Keep the controls synchronized with the selected dataset\n        self.window.treeMCTS.itemSelectionChanged.connect(self._on_tree_selection_changed)\n        try:\n            window.treeMCTS.itemSelectionChanged.connect(self._on_tree_selection_changed)\n        except Exception:\n            pass\n\n    # -----------------------------------------------------------------\n    # DIALOG DI IMPORT\n    # -----------------------------------------------------------------\n    @QtCore.Slot()\n    def open_dialog(self):\n        \"\"\"\n        Dialog to select a SINGLE file and import it using PyVista.\n        Handles MultiBlock \u2192 SINGLE actor.\n        Detects (if present) a time-series and exposes a slider.\n        \"\"\"\n        dlg = QtWidgets.QFileDialog(self.window, \"Import VTK\")\n        dlg.setFileMode(QtWidgets.QFileDialog.ExistingFile)\n        dlg.setNameFilters([\n            \"All supported (*.vtk *.vtp *.vtu *.vtr *.vts *.vtm *.vti *.obj *.stl)\",\n            \"VTK legacy (*.vtk)\",\n            \"VTK XML PolyData (*.vtp)\",\n            \"VTK XML UnstructuredGrid (*.vtu)\",\n            \"VTK XML RectilinearGrid (*.vtr)\",\n            \"VTK XML StructuredGrid (*.vts)\",\n            \"VTK XML MultiBlock (*.vtm)\",\n            \"VTK ImageData (*.vti)\",\n            \"Meshes (*.obj *.stl)\",\n            \"All files (*)\",\n        ])\n        if not dlg.exec():\n            return\n        paths = dlg.selectedFiles()\n        if not paths:\n            return\n        path = paths[0]\n\n        try:\n            reader = pv.get_reader(path)\n        except Exception as ex:\n            self._msg(f\"[VTK] Reader error: {ex}\", error=True)\n            return\n\n        # Try to detect time values\n        self._time_values = None\n        try:\n            tvals = getattr(reader, \"time_values\", None)\n            if tvals is not None and len(tvals) &gt; 0:\n                self._time_values = list(tvals)\n                reader.set_active_time_value(self._time_values[0])\n        except Exception:\n            self._time_values = None\n\n        try:\n            data = reader.read()\n        except Exception as ex:\n            self._msg(f\"[VTK] Read error: {ex}\", error=True)\n            return\n\n        # MultiBlock \u2192 unico attore\n        dataset_to_add = data\n        try:\n            if isinstance(data, pv.MultiBlock):\n                # If you really want *a single actor*, you can render the MultiBlock directly\n                # (PyVista internally handles the blocks with a single composite mapper/actor).\n                dataset_to_add = data\n        except Exception:\n            pass\n\n        # Add to viewer\n        try:\n            ds_index = self._add_dataset_to_viewer(dataset_to_add, path)\n        except Exception as ex:\n            self._msg(f\"[VTK] Viewer add failed: {ex}\", error=True)\n            return\n\n        # Fit camera\n        try:\n            self.window.viewer3d.view_fit()\n        except Exception:\n            pass\n\n        # Select the new dataset in the tree\n        try:\n            self._select_tree_item_for_ds(ds_index)\n        except Exception:\n            pass\n\n        # Show/update time slider if needed\n        self._sync_time_slider_visibility()\n\n        # Update Inspector\n        try:\n            self.window._refresh_inspector_tree()\n        except Exception:\n            pass\n\n        self._msg(f\"[VTK] Imported: {os.path.basename(path)}\")\n\n    def _add_dataset_to_viewer(self, data, path: str) -&gt; int:\n        \"\"\"\n        Aggiunge il dataset PyVista al Viewer3D e registra in mcts.\n        Ritorna l'indice di dataset (ds_index).\n        \"\"\"\n        name = os.path.splitext(os.path.basename(path))[0]\n\n        # Prefer dedicated APIs if available\n        ds_index = None\n        try:\n            if hasattr(self.window.viewer3d, \"add_pyvista_mesh\"):\n                ds_index = self.window.viewer3d.add_pyvista_mesh(data)\n            else:\n                # Generic fallback (used if add_pyvista_mesh is not available)\n                actor = self.window.viewer3d.plotter.add_mesh(data, name=name)\n                # Manual registration in viewer3d._datasets if necessary\n                # Assuming the official API does not handle this automatically\n                if not hasattr(self.window.viewer3d, \"_datasets\"):\n                    self.window.viewer3d._datasets = []\n                ds_index = len(self.window.viewer3d._datasets)\n                self.window.viewer3d._datasets.append({\"mesh\": data, \"actor\": actor})\n                raise RuntimeError(\"Viewer3D.add_pyvista_mesh not available; used fallback registration.\")\n        except Exception as ex:\n            raise\n\n        # Register in mcts (new instance always at the end of the list)\n        entry = {\n            \"name\": name,\n            \"kind\": \"mesh\",            # PolyData / Grid / MultiBlock \u2192 keep as \"mesh\"\n            \"ds_index\": ds_index,\n            \"source_path\": path,       # automatic reopening\n            # default initial style\n            \"representation\": \"Surface\",\n            \"opacity\": 100,\n            \"color_mode\": \"Solid Color\",\n            \"solid_color\": (255, 255, 255),\n            \"colormap\": \"Viridis\",\n            \"scalar_bar\": False,\n            \"edge_visibility\": False,\n            \"edge_color\": (0, 0, 0),\n            \"point_size\": 3,\n            \"line_width\": 1,\n            \"lighting\": True,\n        }\n        self.window.mcts[name] = entry\n        self.window.mct = entry  # becomes \"current\"\n\n        # Create tree node if needed (reuse MainWindow pipeline if available)\n        try:\n            # If the official MainWindow import already builds the tree, you might skip this part.\n            # Here we construct a minimal node as an example:\n            self.window.treeMCTS.blockSignals(True)\n            root = QtWidgets.QTreeWidgetItem([name])\n            root.setFlags(root.flags() | QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsAutoTristate)\n            root.setCheckState(0, QtCore.Qt.Checked)\n            # metadata sul nodo root\n            root.setData(0, QtCore.Qt.UserRole, {\"kind\": \"mesh\", \"ds\": ds_index})\n            # Aggiungi albero \u201cMesh\u201d\n            it_mesh = QtWidgets.QTreeWidgetItem([\"Mesh\"])\n            it_mesh.setFlags(it_mesh.flags() | QtCore.Qt.ItemIsUserCheckable)\n            it_mesh.setCheckState(0, QtCore.Qt.Checked)\n            it_mesh.setData(0, QtCore.Qt.UserRole, {\"kind\": \"mesh\", \"ds\": ds_index})\n            root.addChild(it_mesh)\n\n            self.window.treeMCTS.addTopLevelItem(root)\n            self.window.treeMCTS.blockSignals(False)\n        except Exception:\n            pass\n\n        return ds_index\n\n    # -----------------------------------------------------------------\n    # BOX CONTROLS (ParaView, LIVE application)\n    # -----------------------------------------------------------------\n    def _build_display_box(self) -&gt; QtWidgets.QWidget:\n        w = QtWidgets.QWidget()\n        w.setMaximumWidth(300)\n        w.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)\n        lay = QtWidgets.QFormLayout(w)\n        lay.setFieldGrowthPolicy(QtWidgets.QFormLayout.AllNonFixedFieldsGrow)\n        lay.setHorizontalSpacing(6)\n        lay.setVerticalSpacing(6)\n        lay.setContentsMargins(6, 6, 6, 6)\n\n        # Representation\n        self.cmbRep = QtWidgets.QComboBox()\n        self.cmbRep.addItems([\"Points\", \"Wireframe\", \"Surface\", \"Surface with Edges\", \"Volume\"])\n        self.cmbRep.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.cmbRep.currentTextChanged.connect(self._on_rep_changed)\n        lay.addRow(\"Representation\", self.cmbRep)\n\n        # Color By\n        self.cmbColorBy = QtWidgets.QComboBox()\n        self.cmbColorBy.setMinimumWidth(120)\n        self.cmbColorBy.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.cmbColorBy.currentTextChanged.connect(self._on_color_by_changed)\n        lay.addRow(\"Color by\", self.cmbColorBy)\n\n        # Vector component\n        self.cmbVectorMode = QtWidgets.QComboBox()\n        self.cmbVectorMode.addItems([\"Magnitude\", \"X\", \"Y\", \"Z\"])\n        self.cmbVectorMode.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.cmbVectorMode.currentTextChanged.connect(self._on_color_by_changed)\n        lay.addRow(\"Vector component\", self.cmbVectorMode)\n\n        # LUT\n        self.cmbLUT = QtWidgets.QComboBox()\n        self.cmbLUT.addItems([\"Viridis\", \"Plasma\", \"CoolWarm\", \"Gray\", \"Jet\"])\n        self.cmbLUT.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.cmbLUT.currentTextChanged.connect(self._on_color_by_changed)\n        lay.addRow(\"LUT\", self.cmbLUT)\n\n        # Invert LUT\n        self.chkInvertLUT = QtWidgets.QCheckBox(\"Invert\")\n        self.chkInvertLUT.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.chkInvertLUT.toggled.connect(self._on_color_by_changed)\n        lay.addRow(\"\", self.chkInvertLUT)\n\n        # Solid Color button\n        self.btnSolid = _solid_color_button()\n        self.btnSolid.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.btnSolid.clicked.connect(self._on_pick_solid_color)\n        lay.addRow(self.btnSolid)\n\n        # Scalar range with min/max and buttons\n        rngw = QtWidgets.QWidget()\n        rngw.setMaximumWidth(260)\n        rngw.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        rngLay = QtWidgets.QVBoxLayout(rngw)\n        rngLay.setContentsMargins(0,0,0,0)\n        rngLay.setSpacing(4)\n        frm = QtWidgets.QFormLayout()\n        frm.setContentsMargins(0,0,0,0)\n        frm.setSpacing(4)\n        self.editMin = QtWidgets.QLineEdit()\n        self.editMin.setPlaceholderText(\"min\")\n        self.editMin.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.editMax = QtWidgets.QLineEdit()\n        self.editMax.setPlaceholderText(\"max\")\n        self.editMax.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        frm.addRow(\"Min\", self.editMin)\n        frm.addRow(\"Max\", self.editMax)\n        rngLay.addLayout(frm)\n        btnRow = QtWidgets.QHBoxLayout()\n        btnRow.setSpacing(4)\n        self.btnAuto = QtWidgets.QPushButton(\"Auto\")\n        self.btnAuto.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.btnAuto.clicked.connect(self._on_range_auto)\n        self.btnRescale = QtWidgets.QPushButton(\"Rescale\")\n        self.btnRescale.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.btnRescale.clicked.connect(self._on_rescale_to_data)\n        btnRow.addWidget(self.btnAuto)\n        btnRow.addWidget(self.btnRescale)\n        rngLay.addLayout(btnRow)\n        lay.addRow(\"Scalar range\", rngw)\n\n        # Scalar bar\n        self.chkScalarBar = QtWidgets.QCheckBox(\"Show scalar bar\")\n        self.chkScalarBar.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.chkScalarBar.toggled.connect(self._on_scalar_bar_toggle)\n        lay.addRow(self.chkScalarBar)\n\n        # Opacity slider\n        self.sldOpacity = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.sldOpacity.setRange(0, 100)\n        self.sldOpacity.setValue(100)\n        self.sldOpacity.setMaximumWidth(260)\n        self.sldOpacity.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.sldOpacity.valueChanged.connect(self._on_opacity_changed)\n        lay.addRow(\"Opacity\", self.sldOpacity)\n\n        # Point size slider\n        self.sldPointSize = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.sldPointSize.setRange(1, 15)\n        self.sldPointSize.setValue(3)\n        self.sldPointSize.setMaximumWidth(260)\n        self.sldPointSize.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.sldPointSize.valueChanged.connect(self._on_point_size_changed)\n        lay.addRow(\"Point size\", self.sldPointSize)\n\n        # Line width slider\n        self.sldLineWidth = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.sldLineWidth.setRange(1, 10)\n        self.sldLineWidth.setValue(1)\n        self.sldLineWidth.setMaximumWidth(260)\n        self.sldLineWidth.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.sldLineWidth.valueChanged.connect(self._on_line_width_changed)\n        lay.addRow(\"Line width\", self.sldLineWidth)\n\n        # Edges visible\n        self.chkEdges = QtWidgets.QCheckBox(\"Edges visible\")\n        self.chkEdges.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.chkEdges.toggled.connect(self._on_edges_toggle)\n        lay.addRow(self.chkEdges)\n\n        # Edge color button\n        self.btnEdgeColor = QtWidgets.QPushButton(\"Edge color\u2026\")\n        self.btnEdgeColor.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.btnEdgeColor.clicked.connect(self._on_pick_edge_color)\n        lay.addRow(self.btnEdgeColor)\n\n        # Lighting\n        self.chkLighting = QtWidgets.QCheckBox(\"Lighting\")\n        self.chkLighting.setChecked(True)\n        self.chkLighting.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.chkLighting.toggled.connect(self._on_lighting_toggle)\n        lay.addRow(self.chkLighting)\n\n        # Time-series group\n        self.grpTime = QtWidgets.QGroupBox(\"Time\")\n        self.grpTime.setMaximumWidth(300)\n        time_lay = QtWidgets.QVBoxLayout(self.grpTime)\n        self.sldTime = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.sldTime.setRange(0, 0)\n        self.sldTime.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.sldTime.valueChanged.connect(self._on_time_changed)\n        self.lblTime = QtWidgets.QLabel(\"\u2014\")\n        self.lblTime.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n        self.lblTime.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        time_lay.addWidget(self.sldTime)\n        time_lay.addWidget(self.lblTime)\n        self.grpTime.setVisible(False)\n        lay.addRow(self.grpTime)\n\n        # Reset button\n        self.btnReset = QtWidgets.QPushButton(\"Reset defaults\")\n        self.btnReset.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        self.btnReset.clicked.connect(self._on_reset_defaults)\n        lay.addRow(self.btnReset)\n\n        return w\n\n    # -----------------------------------------------------------------\n    # SYNC UI with current dataset / MCT entry\n    # -----------------------------------------------------------------\n    def _on_tree_selection_changed(self):\n        ds = self._current_dataset_index()\n        self._current_ds = ds\n        self._rebuild_colorby_combo()\n        # carica stato dal mct (se presente)\n        entry = self._current_mct()\n        if entry:\n            self._load_ui_from_entry(entry)\n\n    def _current_dataset_index(self) -&gt; Optional[int]:\n        try:\n            return self.window._current_dataset_index()\n        except Exception:\n            return None\n\n    def _current_mct(self) -&gt; Optional[dict]:\n        try:\n            ds = self._current_dataset_index()\n            for e in self.window.mcts.values():\n                if e.get(\"ds_index\") == ds:\n                    return e\n            return self.window.mct if self.window.mct.get(\"ds_index\") == ds else None\n        except Exception:\n            return None\n\n    def _select_tree_item_for_ds(self, ds_index: int) -&gt; None:\n        \"\"\"Try to select the root item in the tree with ds=ds_index.\"\"\"\n        t = self.window.treeMCTS\n        for i in range(t.topLevelItemCount()):\n            root = t.topLevelItem(i)\n            data = root.data(0, QtCore.Qt.UserRole)\n            if isinstance(data, dict) and data.get(\"ds\") == ds_index:\n                t.setCurrentItem(root)\n                break\n\n    def _sync_time_slider_visibility(self) -&gt; None:\n        has_time = bool(self._time_values) and len(self._time_values) &gt; 1\n        self.grpTime.setVisible(has_time)\n        if has_time:\n            self.sldTime.blockSignals(True)\n            self.sldTime.setRange(0, len(self._time_values) - 1)\n            self.sldTime.setValue(0)\n            self.sldTime.blockSignals(False)\n            self.lblTime.setText(f\"t = {self._time_values[0]:.6g}\")\n\n    # -----------------------------------------------------------------\n    # UI EVENTS \u2192 APPLY\n    # -----------------------------------------------------------------\n    def _on_rep_changed(self, mode: str):\n        ds = self._current_dataset_index()\n        if ds is None: return\n        # Mappatura semplice\n        self._apply_representation(ds, mode)\n        self._save_to_mct(\"representation\", mode)\n\n    def _on_color_by_changed(self):\n        ds = self._current_dataset_index()\n        if ds is None: return\n        label = self.cmbColorBy.currentText()\n        vec_mode = self.cmbVectorMode.currentText()\n        lut = self.cmbLUT.currentText()\n        invert = self.chkInvertLUT.isChecked()\n        self._apply_coloring(ds, label, vec_mode, lut, invert)\n\n        self._save_to_mct(\"color_mode\", label)\n        self._save_to_mct(\"colormap\", lut)\n        self._save_to_mct(\"invert_lut\", bool(invert))\n        self._save_to_mct(\"vector_mode\", vec_mode)\n\n    def _on_pick_solid_color(self):\n        col = QtWidgets.QColorDialog.getColor(parent=self.window, title=\"Solid Color\")\n        if not col.isValid(): return\n        ds = self._current_dataset_index()\n        if ds is None: return\n        self._apply_solid_color(ds, (col.red(), col.green(), col.blue()))\n        self._save_to_mct(\"color_mode\", \"Solid Color\")\n        self._save_to_mct(\"solid_color\", (col.red(), col.green(), col.blue()))\n        # Force combo box to \"Solid Color\"\n        self.cmbColorBy.blockSignals(True)\n        self.cmbColorBy.setCurrentText(\"Solid Color\")\n        self.cmbColorBy.blockSignals(False)\n\n    def _on_range_auto(self):\n        self.editMin.clear(); self.editMax.clear()\n        self._on_color_by_changed()  # re-apply with auto-range\n\n    def _on_rescale_to_data(self):\n        # Re-apply colormap asking the viewer to use data range\n        self._on_color_by_changed()\n\n    def _on_scalar_bar_toggle(self, on: bool):\n        ds = self._current_dataset_index()\n        if ds is None: return\n        self._apply_scalar_bar(ds, on)\n        self._save_to_mct(\"scalar_bar\", bool(on))\n\n    def _on_opacity_changed(self, val: int):\n        ds = self._current_dataset_index()\n        if ds is None: return\n        self._apply_opacity(ds, val)\n        self._save_to_mct(\"opacity\", int(val))\n\n    def _on_point_size_changed(self, val: int):\n        ds = self._current_dataset_index()\n        if ds is None: return\n        self._apply_point_size(ds, val)\n        self._save_to_mct(\"point_size\", int(val))\n\n    def _on_line_width_changed(self, val: int):\n        ds = self._current_dataset_index()\n        if ds is None: return\n        self._apply_line_width(ds, val)\n        self._save_to_mct(\"line_width\", int(val))\n\n    def _on_edges_toggle(self, on: bool):\n        ds = self._current_dataset_index()\n        if ds is None: return\n        self._apply_edges(ds, bool(on))\n        self._save_to_mct(\"edge_visibility\", bool(on))\n\n    def _on_pick_edge_color(self):\n        col = QtWidgets.QColorDialog.getColor(parent=self.window, title=\"Edge Color\")\n        if not col.isValid(): return\n        ds = self._current_dataset_index()\n        if ds is None: return\n        self._apply_edge_color(ds, (col.red(), col.green(), col.blue()))\n        self._save_to_mct(\"edge_color\", (col.red(), col.green(), col.blue()))\n\n    def _on_lighting_toggle(self, on: bool):\n        ds = self._current_dataset_index()\n        if ds is None: return\n        self._apply_lighting(ds, bool(on))\n        self._save_to_mct(\"lighting\", bool(on))\n\n    def _on_time_changed(self, idx: int):\n        if not self._time_values: return\n        self._time_idx = int(idx)\n        t = self._time_values[self._time_idx]\n        self.lblTime.setText(f\"t = {t:.6g}\")\n        # Rileggi il dataset al tempo selezionato\n        # NOTE: servirebbe conservare il reader in self; per semplicit\u00e0 omesso.\n        # TODO: estendere per ricaricare dal reader e aggiornare l'attore.\n\n    def _on_reset_defaults(self):\n        # Reset UI\n        self.cmbRep.setCurrentText(\"Surface\")\n        self.cmbColorBy.setCurrentText(\"Solid Color\")\n        self.cmbVectorMode.setCurrentText(\"Magnitude\")\n        self.cmbLUT.setCurrentText(\"Viridis\")\n        self.chkInvertLUT.setChecked(False)\n        self.chkScalarBar.setChecked(False)\n        self.sldOpacity.setValue(100)\n        self.sldPointSize.setValue(3)\n        self.sldLineWidth.setValue(1)\n        self.chkEdges.setChecked(False)\n        self.chkLighting.setChecked(True)\n        # Applica allo stato corrente\n        self._on_rep_changed(\"Surface\")\n        self._on_color_by_changed()\n        self._on_scalar_bar_toggle(False)\n        self._on_opacity_changed(100)\n        self._on_point_size_changed(3)\n        self._on_line_width_changed(1)\n        self._on_edges_toggle(False)\n        self._on_lighting_toggle(True)\n\n    # -----------------------------------------------------------------\n    # APPLY (adapter using the viewer's API if available, else fallback)\n    # -----------------------------------------------------------------\n    def _apply_representation(self, ds: int, mode: str):\n        \"\"\"\n        Map of representations:\n        - Points, Wireframe, Surface, Surface with Edges, Volume\n        \"\"\"\n        # Se il tuo Viewer3D espone un metodo diretto:\n        fn = getattr(self.window.viewer3d, \"set_mesh_representation\", None)\n        if callable(fn):\n            fn(ds, mode)\n            return\n        # Fallback: re-render via PyVista\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            representation=mode,\n            manual_range=self._manual_range_or_none(),\n            color_mode=e.get(\"color_mode\", \"Solid Color\"),\n            lut=e.get(\"colormap\", \"Viridis\"),\n            invert=self.chkInvertLUT.isChecked(),\n            scalar_bar=self.chkScalarBar.isChecked(),\n            edge_visibility=self.chkEdges.isChecked(),\n            edge_color=e.get(\"edge_color\", (0, 0, 0)),\n            opacity=self.sldOpacity.value(),\n            point_size=self.sldPointSize.value(),\n            line_width=self.sldLineWidth.value(),\n            lighting=self.chkLighting.isChecked(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    def _apply_solid_color(self, ds: int, rgb: Tuple[int, int, int]):\n        fn = getattr(self.window.viewer3d, \"set_dataset_color\", None)\n        if callable(fn):\n            fn(ds, *rgb)\n            return\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            color_mode=\"Solid Color\",\n            solid_color=rgb,\n            representation=e.get(\"representation\", \"Surface\"),\n            lut=e.get(\"colormap\", \"Viridis\"),\n            invert=self.chkInvertLUT.isChecked(),\n            scalar_bar=self.chkScalarBar.isChecked(),\n            edge_visibility=self.chkEdges.isChecked(),\n            edge_color=e.get(\"edge_color\", (0, 0, 0)),\n            opacity=self.sldOpacity.value(),\n            point_size=self.sldPointSize.value(),\n            line_width=self.sldLineWidth.value(),\n            lighting=self.chkLighting.isChecked(),\n            manual_range=self._manual_range_or_none(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    def _apply_coloring(self, ds: int, label: str, vec_mode: str, lut: str, invert: bool):\n        \"\"\"\n        label = \"Solid Color\" oppure \"PointData/&lt;array&gt;\" o \"CellData/&lt;array&gt;\"\n        vec_mode = Magnitude / X / Y / Z\n        \"\"\"\n        # Caso Solid Color \u2192 forza colore uniforme\n        if label == \"Solid Color\":\n            self._apply_solid_color(ds, self._current_mct().get(\"solid_color\", (255, 255, 255)))\n            # Se il viewer ha un \u201ccolor mode\u201d, impostalo\n            try:\n                self.window.viewer3d.set_color_mode(\"Solid Color\", ds)\n            except Exception:\n                pass\n            return\n\n        # Parsing \u201cPointData/NAME\u201d o \u201cCellData/NAME\u201d\n        assoc = \"POINT\"\n        array_name = label\n        if label.startswith(\"PointData/\"):\n            assoc = \"POINT\"\n            array_name = label.split(\"/\", 1)[1]\n        elif label.startswith(\"CellData/\"):\n            assoc = \"CELL\"\n            array_name = label.split(\"/\", 1)[1]\n\n        # Viewer API personalizzata (se esiste):\n        # Immaginiamo una API del tipo: set_scalar_coloring(ds, array_name, assoc, component, lut, invert, range)\n        fn = getattr(self.window.viewer3d, \"set_scalar_coloring\", None)\n        rng = self._manual_range_or_none()\n        component = {\"Magnitude\": None, \"X\": 0, \"Y\": 1, \"Z\": 2}.get(vec_mode, None)\n        if callable(fn):\n            fn(ds, array_name, assoc, component, lut, bool(invert), rng)\n            return\n\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            color_mode=label,\n            lut=lut,\n            invert=bool(invert),\n            representation=e.get(\"representation\", \"Surface\"),\n            scalar_bar=self.chkScalarBar.isChecked(),\n            edge_visibility=self.chkEdges.isChecked(),\n            edge_color=e.get(\"edge_color\", (0, 0, 0)),\n            opacity=self.sldOpacity.value(),\n            point_size=self.sldPointSize.value(),\n            line_width=self.sldLineWidth.value(),\n            lighting=self.chkLighting.isChecked(),\n            manual_range=self._manual_range_or_none(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    def _manual_range_or_none(self) -&gt; Optional[Tuple[float, float]]:\n        try:\n            smin = self.editMin.text().strip()\n            smax = self.editMax.text().strip()\n            if not smin or not smax:\n                return None\n            return (float(smin), float(smax))\n        except Exception:\n            return None\n\n    def _apply_scalar_bar(self, ds: int, show: bool):\n        fn = getattr(self.window.viewer3d, \"set_scalar_bar_visible\", None)\n        if callable(fn):\n            fn(ds, bool(show))\n            return\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            scalar_bar=bool(show),\n            representation=e.get(\"representation\", \"Surface\"),\n            color_mode=e.get(\"color_mode\", \"Solid Color\"),\n            lut=e.get(\"colormap\", \"Viridis\"),\n            invert=self.chkInvertLUT.isChecked(),\n            edge_visibility=self.chkEdges.isChecked(),\n            edge_color=e.get(\"edge_color\", (0, 0, 0)),\n            opacity=self.sldOpacity.value(),\n            point_size=self.sldPointSize.value(),\n            line_width=self.sldLineWidth.value(),\n            lighting=self.chkLighting.isChecked(),\n            manual_range=self._manual_range_or_none(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    def _apply_opacity(self, ds: int, val: int):\n        fn = getattr(self.window.viewer3d, \"set_mesh_opacity\", None)\n        if callable(fn):\n            fn(ds, int(val))\n            return\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            opacity=int(val),\n            representation=e.get(\"representation\", \"Surface\"),\n            color_mode=e.get(\"color_mode\", \"Solid Color\"),\n            lut=e.get(\"colormap\", \"Viridis\"),\n            invert=self.chkInvertLUT.isChecked(),\n            scalar_bar=self.chkScalarBar.isChecked(),\n            edge_visibility=self.chkEdges.isChecked(),\n            edge_color=e.get(\"edge_color\", (0, 0, 0)),\n            point_size=self.sldPointSize.value(),\n            line_width=self.sldLineWidth.value(),\n            lighting=self.chkLighting.isChecked(),\n            manual_range=self._manual_range_or_none(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    def _apply_point_size(self, ds: int, val: int):\n        fn = getattr(self.window.viewer3d, \"set_point_size\", None)\n        if callable(fn):\n            fn(int(val), ds)\n            return\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            point_size=int(val),\n            representation=e.get(\"representation\", \"Surface\"),\n            color_mode=e.get(\"color_mode\", \"Solid Color\"),\n            lut=e.get(\"colormap\", \"Viridis\"),\n            invert=self.chkInvertLUT.isChecked(),\n            scalar_bar=self.chkScalarBar.isChecked(),\n            edge_visibility=self.chkEdges.isChecked(),\n            edge_color=e.get(\"edge_color\", (0, 0, 0)),\n            opacity=self.sldOpacity.value(),\n            line_width=self.sldLineWidth.value(),\n            lighting=self.chkLighting.isChecked(),\n            manual_range=self._manual_range_or_none(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    def _apply_line_width(self, ds: int, val: int):\n        fn = getattr(self.window.viewer3d, \"set_line_width\", None)\n        if callable(fn):\n            fn(ds, int(val))\n            return\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            line_width=int(val),\n            representation=e.get(\"representation\", \"Surface\"),\n            color_mode=e.get(\"color_mode\", \"Solid Color\"),\n            lut=e.get(\"colormap\", \"Viridis\"),\n            invert=self.chkInvertLUT.isChecked(),\n            scalar_bar=self.chkScalarBar.isChecked(),\n            edge_visibility=self.chkEdges.isChecked(),\n            edge_color=e.get(\"edge_color\", (0, 0, 0)),\n            opacity=self.sldOpacity.value(),\n            point_size=self.sldPointSize.value(),\n            lighting=self.chkLighting.isChecked(),\n            manual_range=self._manual_range_or_none(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    def _apply_edges(self, ds: int, on: bool):\n        fn = getattr(self.window.viewer3d, \"set_edge_visibility\", None)\n        if callable(fn):\n            fn(ds, bool(on))\n            return\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            edge_visibility=bool(on),\n            representation=e.get(\"representation\", \"Surface\"),\n            color_mode=e.get(\"color_mode\", \"Solid Color\"),\n            lut=e.get(\"colormap\", \"Viridis\"),\n            invert=self.chkInvertLUT.isChecked(),\n            scalar_bar=self.chkScalarBar.isChecked(),\n            edge_color=e.get(\"edge_color\", (0, 0, 0)),\n            opacity=self.sldOpacity.value(),\n            point_size=self.sldPointSize.value(),\n            line_width=self.sldLineWidth.value(),\n            lighting=self.chkLighting.isChecked(),\n            manual_range=self._manual_range_or_none(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    def _apply_edge_color(self, ds: int, rgb: Tuple[int, int, int]):\n        fn = getattr(self.window.viewer3d, \"set_edge_color\", None)\n        if callable(fn):\n            fn(ds, *rgb)\n            return\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            edge_color=rgb,\n            representation=e.get(\"representation\", \"Surface\"),\n            color_mode=e.get(\"color_mode\", \"Solid Color\"),\n            lut=e.get(\"colormap\", \"Viridis\"),\n            invert=self.chkInvertLUT.isChecked(),\n            scalar_bar=self.chkScalarBar.isChecked(),\n            edge_visibility=self.chkEdges.isChecked(),\n            opacity=self.sldOpacity.value(),\n            point_size=self.sldPointSize.value(),\n            line_width=self.sldLineWidth.value(),\n            lighting=self.chkLighting.isChecked(),\n            manual_range=self._manual_range_or_none(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    def _apply_lighting(self, ds: int, on: bool):\n        fn = getattr(self.window.viewer3d, \"set_lighting_enabled\", None)\n        if callable(fn):\n            fn(ds, bool(on))\n            return\n        e = self._current_mct() or {}\n        _fallback_render(\n            self.window, e, ds,\n            lighting=bool(on),\n            representation=e.get(\"representation\", \"Surface\"),\n            color_mode=e.get(\"color_mode\", \"Solid Color\"),\n            lut=e.get(\"colormap\", \"Viridis\"),\n            invert=self.chkInvertLUT.isChecked(),\n            scalar_bar=self.chkScalarBar.isChecked(),\n            edge_visibility=self.chkEdges.isChecked(),\n            edge_color=e.get(\"edge_color\", (0, 0, 0)),\n            opacity=self.sldOpacity.value(),\n            point_size=self.sldPointSize.value(),\n            line_width=self.sldLineWidth.value(),\n            manual_range=self._manual_range_or_none(),\n            vector_mode=self.cmbVectorMode.currentText(),\n        )\n\n    # -----------------------------------------------------------------\n    # COMBO BOX \"Color by\" REBUILD\n    # -----------------------------------------------------------------\n    def _rebuild_colorby_combo(self):\n        \"\"\"Reads arrays from the current PolyData/mesh and populates the \u201cColor by\u201d combo box.\"\"\"\n        self.cmbColorBy.blockSignals(True)\n        self.cmbColorBy.clear()\n        self.cmbColorBy.addItem(\"Solid Color\")\n        ds = self._current_dataset_index()\n        if ds is None:\n            self.cmbColorBy.blockSignals(False)\n            return\n\n        # if possible, retrieve arrays from the original dataset\n        arrays_pt, arrays_cell = [], []\n        try:\n            recs = getattr(self.window.viewer3d, \"_datasets\", [])\n            rec = recs[ds]\n            # Prefer original dataset for listing arrays (more complete), fall back to surface\n            pdata = rec.get(\"mesh_orig\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n            surf = rec.get(\"mesh_surface\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n            target = pdata or surf\n            if isinstance(target, pv.MultiBlock):\n                try:\n                    target = target[0]\n                except Exception:\n                    target = None\n                rec[\"mesh\"] = target\n            if target is not None:\n                # PointData\n                try:\n                    for name in list(target.point_data.keys()):\n                        if str(name).startswith(\"vtkOriginal\"):\n                            continue\n                        arrays_pt.append(str(name))\n                except Exception:\n                    pass\n                # CellData\n                try:\n                    for name in list(target.cell_data.keys()):\n                        if str(name).startswith(\"vtkOriginal\"):\n                            continue\n                        arrays_cell.append(str(name))\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n        if arrays_pt:\n            for n in arrays_pt:\n                self.cmbColorBy.addItem(f\"PointData/{n}\")\n        if arrays_cell:\n            for n in arrays_cell:\n                self.cmbColorBy.addItem(f\"CellData/{n}\")\n\n        self.cmbColorBy.blockSignals(False)\n\n    def _load_ui_from_entry(self, e: dict) -&gt; None:\n        \"\"\"Load (best effort) controls from persisted values in the mct entry.\"\"\"\n        try: self.cmbRep.setCurrentText(e.get(\"representation\", \"Surface\"))\n        except Exception: pass\n        try: self.cmbColorBy.setCurrentText(e.get(\"color_mode\", \"Solid Color\"))\n        except Exception: pass\n        try: self.cmbLUT.setCurrentText(e.get(\"colormap\", \"Viridis\"))\n        except Exception: pass\n        try: self.chkScalarBar.setChecked(bool(e.get(\"scalar_bar\", False)))\n        except Exception: pass\n        try: self.sldOpacity.setValue(int(e.get(\"opacity\", 100)))\n        except Exception: pass\n        try: self.sldPointSize.setValue(int(e.get(\"point_size\", 3)))\n        except Exception: pass\n        try: self.sldLineWidth.setValue(int(e.get(\"line_width\", 1)))\n        except Exception: pass\n        try: self.chkEdges.setChecked(bool(e.get(\"edge_visibility\", False)))\n        except Exception: pass\n        try: self.chkLighting.setChecked(bool(e.get(\"lighting\", True)))\n        except Exception: pass\n\n    def _save_to_mct(self, key: str, val):\n        e = self._current_mct()\n        if e is not None:\n            e[key] = val\n\n    # -----------------------------------------------------------------\n    # LOGGING/UTILITY\n    # -----------------------------------------------------------------\n    def _msg(self, text: str, error: bool = False):\n        # Write to status bar + message panel (if available)\n        try:\n            self.window.statusBar().showMessage(text, 5000)\n        except Exception:\n            pass\n        try:\n            self.window.txtMessages.appendPlainText(text)\n        except Exception:\n            pass\n        if error:\n            print(text)\n</code></pre>"},{"location":"api/c2f4dt/plugins/vtk_import/plugin/#c2f4dt.plugins.vtk_import.plugin.VTKImportPlugin.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/plugins/vtk_import/plugin/#c2f4dt.plugins.vtk_import.plugin.VTKImportPlugin.open_dialog","title":"<code>open_dialog()</code>","text":"<p>Dialog to select a SINGLE file and import it using PyVista. Handles MultiBlock \u2192 SINGLE actor. Detects (if present) a time-series and exposes a slider.</p> Source code in <code>src/c2f4dt/plugins/vtk_import/plugin.py</code> <pre><code>@QtCore.Slot()\ndef open_dialog(self):\n    \"\"\"\n    Dialog to select a SINGLE file and import it using PyVista.\n    Handles MultiBlock \u2192 SINGLE actor.\n    Detects (if present) a time-series and exposes a slider.\n    \"\"\"\n    dlg = QtWidgets.QFileDialog(self.window, \"Import VTK\")\n    dlg.setFileMode(QtWidgets.QFileDialog.ExistingFile)\n    dlg.setNameFilters([\n        \"All supported (*.vtk *.vtp *.vtu *.vtr *.vts *.vtm *.vti *.obj *.stl)\",\n        \"VTK legacy (*.vtk)\",\n        \"VTK XML PolyData (*.vtp)\",\n        \"VTK XML UnstructuredGrid (*.vtu)\",\n        \"VTK XML RectilinearGrid (*.vtr)\",\n        \"VTK XML StructuredGrid (*.vts)\",\n        \"VTK XML MultiBlock (*.vtm)\",\n        \"VTK ImageData (*.vti)\",\n        \"Meshes (*.obj *.stl)\",\n        \"All files (*)\",\n    ])\n    if not dlg.exec():\n        return\n    paths = dlg.selectedFiles()\n    if not paths:\n        return\n    path = paths[0]\n\n    try:\n        reader = pv.get_reader(path)\n    except Exception as ex:\n        self._msg(f\"[VTK] Reader error: {ex}\", error=True)\n        return\n\n    # Try to detect time values\n    self._time_values = None\n    try:\n        tvals = getattr(reader, \"time_values\", None)\n        if tvals is not None and len(tvals) &gt; 0:\n            self._time_values = list(tvals)\n            reader.set_active_time_value(self._time_values[0])\n    except Exception:\n        self._time_values = None\n\n    try:\n        data = reader.read()\n    except Exception as ex:\n        self._msg(f\"[VTK] Read error: {ex}\", error=True)\n        return\n\n    # MultiBlock \u2192 unico attore\n    dataset_to_add = data\n    try:\n        if isinstance(data, pv.MultiBlock):\n            # If you really want *a single actor*, you can render the MultiBlock directly\n            # (PyVista internally handles the blocks with a single composite mapper/actor).\n            dataset_to_add = data\n    except Exception:\n        pass\n\n    # Add to viewer\n    try:\n        ds_index = self._add_dataset_to_viewer(dataset_to_add, path)\n    except Exception as ex:\n        self._msg(f\"[VTK] Viewer add failed: {ex}\", error=True)\n        return\n\n    # Fit camera\n    try:\n        self.window.viewer3d.view_fit()\n    except Exception:\n        pass\n\n    # Select the new dataset in the tree\n    try:\n        self._select_tree_item_for_ds(ds_index)\n    except Exception:\n        pass\n\n    # Show/update time slider if needed\n    self._sync_time_slider_visibility()\n\n    # Update Inspector\n    try:\n        self.window._refresh_inspector_tree()\n    except Exception:\n        pass\n\n    self._msg(f\"[VTK] Imported: {os.path.basename(path)}\")\n</code></pre>"},{"location":"api/c2f4dt/plugins/vtk_import/plugin/#c2f4dt.plugins.vtk_import.plugin.register","title":"<code>register(window)</code>","text":"<p>Factory entry-point required by <code>entry_point: \"plugin:register\"</code>. Returns the plugin instance.</p> Source code in <code>src/c2f4dt/plugins/vtk_import/plugin.py</code> <pre><code>def register(window) -&gt; object:\n    \"\"\"\n    Factory entry-point required by `entry_point: \"plugin:register\"`.\n    Returns the plugin instance.\n    \"\"\"\n    return VTKImportPlugin(window)\n</code></pre>"},{"location":"api/c2f4dt/ui/console/","title":"c2f4dt.ui.console","text":""},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console","title":"<code>c2f4dt.ui.console</code>","text":""},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console.ConsoleWidget","title":"<code>ConsoleWidget</code>","text":"<p>               Bases: <code>QPlainTextEdit</code></p> <p>A simple Abaqus-like interactive Python console with TAB autocomplete.</p>"},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console.ConsoleWidget--features","title":"Features","text":"<ul> <li>Single widget, terminal-like: input appears inline with a <code>&gt;&gt;&gt;</code> prompt.</li> <li>Multi-line paste/edit supported; continuation prompts use <code>...</code>.</li> <li>History navigation with Up/Down on the current prompt.</li> <li>TAB shows autocomplete suggestions; if a single match, completes inline.</li> <li>Executes code in a controlled namespace provided by <code>context_provider</code>.</li> </ul>"},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console.ConsoleWidget--notes","title":"Notes","text":"<p>This widget protects previous output: editing is only allowed after the current prompt position. The console uses <code>codeop</code> to detect whether the current buffer is a complete Python block or needs continuation.</p> Source code in <code>src/c2f4dt/ui/console.py</code> <pre><code>class ConsoleWidget(QtWidgets.QPlainTextEdit):\n    \"\"\"A simple Abaqus-like interactive Python console with TAB autocomplete.\n\n    Features\n    --------\n    - Single widget, terminal-like: input appears inline with a ``&gt;&gt;&gt;`` prompt.\n    - Multi-line paste/edit supported; continuation prompts use ``...``.\n    - History navigation with Up/Down on the current prompt.\n    - TAB shows autocomplete suggestions; if a single match, completes inline.\n    - Executes code in a controlled namespace provided by ``context_provider``.\n\n    Notes\n    -----\n    This widget protects previous output: editing is only allowed after the\n    current prompt position. The console uses ``codeop`` to detect whether the\n    current buffer is a complete Python block or needs continuation.\n    \"\"\"\n\n    sigExecuted = QtCore.Signal(str)\n\n    def __init__(self, context_provider: Callable[[], Dict[str, object]], parent: Optional[QtWidgets.QWidget] = None) -&gt; None:\n        super().__init__(parent)\n        self._context_provider = context_provider\n\n        # Visuals: monospace, no line wrap, focus at end\n        font = QtGui.QFontDatabase.systemFont(QtGui.QFontDatabase.FixedFont)\n        font.setPointSize(font.pointSize() + 1)\n        self.setFont(font)\n        self.setLineWrapMode(QtWidgets.QPlainTextEdit.NoWrap)\n        self.setUndoRedoEnabled(False)\n\n        # Prompts &amp; state\n        self._ps1 = \"&gt;&gt;&gt; \"\n        self._ps2 = \"... \"\n        self._compiler = codeop.CommandCompiler()\n        self._buffer_lines: List[str] = []  # current multi-line input buffer\n        self._history: List[str] = []\n        self._hist_idx: int = -1\n        self._prompt_pos: int = 0  # document position of current prompt start\n\n        self._write(\"C2F4DT Python Console. Type Python and press Enter. TAB for suggestions.\\n\")\n        self._insert_prompt(primary=True)\n\n        # Persistent execution namespace (survives between commands)\n        self._ns: Dict[str, object] = {}\n        self._refresh_namespace()\n\n        # Accept drag&amp;drop/paste of multi-line text\n        self.setAcceptDrops(True)\n        self.installEventFilter(self)\n\n        # Syntax highlighting\n        self._highlighter = PythonHighlighter(self.document())\n\n        # Popup completer (TAB)\n        self._completer = QtWidgets.QCompleter([], self)\n        self._completer.setCaseSensitivity(QtCore.Qt.CaseInsensitive)\n        self._completer.setFilterMode(QtCore.Qt.MatchStartsWith)\n        self._completer.setCompletionMode(QtWidgets.QCompleter.PopupCompletion)\n        self._completer.setWidget(self)\n        self._completer.activated.connect(self._apply_completion)\n\n        # Precompiled regex for completion contexts (name/attr/item)\n        self._rx_item = re.compile(r\"([\\w\\.]+)\\[(?:'|\\\")(?:([\\w\\-.]*))?$\")\n        self._rx_attr = re.compile(r\"([\\w\\.]+)\\.([\\w\\-.]*)$\")\n        self._rx_name = re.compile(r\"([A-Za-z_][A-Za-z0-9_]*)$\")\n\n    # ------------------------------------------------------------------\n    # Core helpers\n    # ------------------------------------------------------------------\n    def _write(self, text: str) -&gt; None:\n        cursor = self.textCursor()\n        cursor.movePosition(QtGui.QTextCursor.End)\n        cursor.insertText(text)\n        self.setTextCursor(cursor)\n        self.ensureCursorVisible()\n\n    def _insert_prompt(self, primary: bool) -&gt; None:\n        prompt = self._ps1 if primary else self._ps2\n        self._write(prompt)\n        self._prompt_pos = self.textCursor().position()\n\n    def _current_input_text(self) -&gt; str:\n        \"\"\"Return text from current prompt to end of document.\"\"\"\n        doc = self.document()\n        return doc.toPlainText()[self._prompt_pos:]\n\n    def _set_current_input_text(self, text: str) -&gt; None:\n        cursor = self.textCursor()\n        cursor.setPosition(self._prompt_pos)\n        cursor.movePosition(QtGui.QTextCursor.End, QtGui.QTextCursor.KeepAnchor)\n        cursor.removeSelectedText()\n        cursor.insertText(text)\n        self.setTextCursor(cursor)\n\n    def _refresh_namespace(self) -&gt; None:\n        \"\"\"Seed/refresh the persistent namespace with the latest context.\n\n        Keeps previously defined symbols (variables/functions created in console).\n        \"\"\"\n        try:\n            ctx = self._context_provider() or {}\n        except Exception:\n            ctx = {}\n        # Ensure builtins present for eval/exec\n        self._ns.setdefault(\"__builtins__\", __builtins__)\n        # Update with dynamic context (window, mct, mcts, etc.)\n        self._ns.update(ctx)\n\n    # ------------------------------------------------------------------\n    # Event handling\n    # ------------------------------------------------------------------\n    def eventFilter(self, obj, event):\n        # Prevent mouse from placing cursor before prompt\n        if event.type() == QtCore.QEvent.MouseButtonPress:\n            pos = event.position() if hasattr(event, \"position\") else event.pos()\n            return False  # allow default, we'll clamp in keyPressEvent\n        return super().eventFilter(obj, event)\n\n    def keyPressEvent(self, event: QtGui.QKeyEvent) -&gt; None:\n        key = event.key()\n        mod = event.modifiers()\n\n        # Ensure cursor never goes before current prompt\n        if key in (QtCore.Qt.Key_Home,):\n            # Move to after prompt on Home\n            cur = self.textCursor()\n            cur.setPosition(self._prompt_pos)\n            self.setTextCursor(cur)\n            return\n\n        if key in (QtCore.Qt.Key_Backspace,):\n            if self.textCursor().position() &lt;= self._prompt_pos:\n                return  # block backspace before prompt\n\n        # History navigation (only if caret at end line region)\n        if key in (QtCore.Qt.Key_Up, QtCore.Qt.Key_Down):\n            cur = self.textCursor()\n            if cur.position() &gt;= self._prompt_pos:\n                if key == QtCore.Qt.Key_Up:\n                    self._history_prev()\n                else:\n                    self._history_next()\n                return\n\n        # Autocomplete on TAB\n        if key == QtCore.Qt.Key_Tab:\n            self._autocomplete()\n            return\n\n        # Execute on Enter/Return\n        if key in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter) and not (mod &amp; QtCore.Qt.ShiftModifier):\n            self._on_enter()\n            return\n\n        # Allow explicit newline with Shift+Enter\n        if key in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter) and (mod &amp; QtCore.Qt.ShiftModifier):\n            super().keyPressEvent(event)\n            return\n\n        # Block editing before prompt: if cursor is before prompt, jump to end\n        if self.textCursor().position() &lt; self._prompt_pos:\n            cur = self.textCursor()\n            cur.setPosition(self.document().characterCount() - 1)\n            self.setTextCursor(cur)\n\n        # If completer popup is visible, let it handle navigation keys\n        if hasattr(self, \"_completer\") and self._completer.popup() and self._completer.popup().isVisible():\n            if key in (QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return, QtCore.Qt.Key_Escape,\n                    QtCore.Qt.Key_Tab, QtCore.Qt.Key_Backtab,\n                    QtCore.Qt.Key_Up, QtCore.Qt.Key_Down,\n                    QtCore.Qt.Key_PageUp, QtCore.Qt.Key_PageDown):\n                event.ignore()\n                return\n\n        super().keyPressEvent(event)\n\n\n    # ------------------------ Autocomplete helpers ------------------------\n    def _current_line_text(self) -&gt; str:\n        doc = self.document().toPlainText()\n        return doc[self._prompt_pos:]\n\n    def _completion_context(self) -&gt; dict:\n        \"\"\"Analyze current buffer; return kind/prefix/replacement anchor.\"\"\"\n        cursor = self.textCursor()\n        abs_pos = cursor.position()\n        upto = self.document().toPlainText()[self._prompt_pos:abs_pos]\n\n        # 1) Dict/item access: foo['pre   or   foo[\"pre\n        m = self._rx_item.search(upto)\n        if m:\n            base = m.group(1)\n            prefix = m.group(2) or \"\"\n            replace_from = abs_pos - len(prefix)\n            return {\"kind\": \"item\", \"base_expr\": base, \"prefix\": prefix, \"replace_from\": replace_from}\n\n        # 2) Attribute access: obj.pre\n        m = self._rx_attr.search(upto)\n        if m:\n            base = m.group(1)\n            prefix = m.group(2) or \"\"\n            replace_from = abs_pos - len(prefix)\n            return {\"kind\": \"attr\", \"base_expr\": base, \"prefix\": prefix, \"replace_from\": replace_from}\n\n        # 3) Plain name\n        m = self._rx_name.search(upto)\n        if m:\n            prefix = m.group(1)\n            replace_from = abs_pos - len(prefix)\n            return {\"kind\": \"name\", \"base_expr\": None, \"prefix\": prefix, \"replace_from\": replace_from}\n\n        return {\"kind\": \"name\", \"base_expr\": None, \"prefix\": \"\", \"replace_from\": abs_pos}\n\n    def _apply_completion_at(self, completion: str, replace_from: int) -&gt; None:\n        cur = self.textCursor()\n        cur.setPosition(replace_from)\n        cur.movePosition(QtGui.QTextCursor.End, QtGui.QTextCursor.KeepAnchor)\n        cur.removeSelectedText()\n        cur.insertText(completion)\n        self.setTextCursor(cur)\n\n    def _apply_completion(self, text: str) -&gt; None:\n        rf = getattr(self._completer, 'replace_from', None)\n        if rf is None:\n            rf = self.textCursor().position()\n        self._apply_completion_at(text, rf)\n\n    # ------------------------------------------------------------------\n    # History &amp; autocomplete\n    # ------------------------------------------------------------------\n    def _history_prev(self) -&gt; None:\n        if not self._history:\n            return\n        self._hist_idx = max(0, self._hist_idx - 1) if self._hist_idx &gt;= 0 else len(self._history) - 1\n        self._set_current_input_text(self._history[self._hist_idx])\n\n    def _history_next(self) -&gt; None:\n        if not self._history:\n            return\n        if self._hist_idx &lt; len(self._history) - 1:\n            self._hist_idx += 1\n            self._set_current_input_text(self._history[self._hist_idx])\n        else:\n            self._hist_idx = len(self._history)\n            self._set_current_input_text(\"\")\n\n    def _autocomplete(self) -&gt; None:\n        \"\"\"Autocomplete using popup; supports name/attr/dict-key.\"\"\"\n        ctx_info = self._completion_context()\n        prefix = ctx_info[\"prefix\"]\n        replace_from = ctx_info[\"replace_from\"]\n        kind = ctx_info[\"kind\"]\n\n        candidates: List[str] = []\n        try:\n            if kind == \"name\":\n                names = sorted(set(list(self._ns.keys()) + dir(__builtins__)))\n                candidates = [n for n in names if n.startswith(prefix)] if prefix else names\n            else:\n                base_expr = ctx_info[\"base_expr\"]\n                try:\n                    base_obj = eval(base_expr, self._ns, self._ns)\n                except Exception:\n                    return\n                if kind == \"attr\":\n                    attrs = dir(base_obj)\n                    if prefix and not prefix.startswith('_'):\n                        attrs = [a for a in attrs if not a.startswith('_')]\n                    candidates = [a for a in attrs if a.startswith(prefix)] if prefix else attrs\n                elif kind == \"item\":\n                    keys = []\n                    try:\n                        keys = list(base_obj.keys())  # may raise if not dict-like\n                    except Exception:\n                        keys = dir(base_obj)\n                    keys = [k for k in keys if isinstance(k, str)]\n                    candidates = [k for k in keys if k.startswith(prefix)] if prefix else keys\n        except Exception:\n            candidates = []\n\n        if not candidates:\n            return\n\n        if len(candidates) == 1:\n            self._apply_completion_at(candidates[0], replace_from)\n            return\n\n        model = QtCore.QStringListModel(sorted(candidates), self._completer)\n        self._completer.setModel(model)\n        self._completer.replace_from = replace_from  # type: ignore[attr-defined]\n        cr = self.cursorRect()\n        cr.setWidth(300)\n        self._completer.complete(cr)\n\n    # ------------------------------------------------------------------\n    # Execution\n    # ------------------------------------------------------------------\n    def _on_enter(self) -&gt; None:\n        \"\"\"Handle Enter: accept current line into buffer; execute when complete.\"\"\"\n        # Echo a newline\n        self._write(\"\\n\")\n\n        # Grab current input (may be multi-line already)\n        line = self._current_input_text()\n        self._buffer_lines.append(line)\n        src = \"\\n\".join(self._buffer_lines)\n\n        # Determine if the code block is complete\n        try:\n            code_obj = self._compiler(src)\n        except (OverflowError, SyntaxError, ValueError):\n            code_obj = True  # Force execution to raise actual syntax error\n\n        if code_obj is None:\n            # Need more input -&gt; print continuation prompt\n            self._insert_prompt(primary=False)\n            return\n\n        code_to_run = src\n\n        stripped = code_to_run.strip()\n        if stripped.startswith('%'):\n            self._refresh_namespace()\n            import os, glob\n            parts = stripped.split(maxsplit=1)\n            cmd = parts[0]\n            arg = parts[1] if len(parts) &gt; 1 else ''\n            if cmd == '%run':\n                window = self._ns.get('window')\n                if window is not None and hasattr(window, '_exec_script_file'):\n                    try:\n                        window._exec_script_file(arg.strip())\n                        self._write(f\"[ran] {arg.strip()}\\n\")\n                    except Exception as ex:\n                        self._write(f\"Error in %run: {ex}\\n\")\n                else:\n                    self._write(\"Error: window runner not available\\n\")\n            elif cmd == '%pwd':\n                self._write(os.getcwd() + \"\\n\")\n            elif cmd == '%cd':\n                try:\n                    os.chdir(arg.strip() or os.path.expanduser('~'))\n                except Exception as ex:\n                    self._write(f\"cd: {ex}\\n\")\n            elif cmd == '%ls':\n                pat = arg.strip() or '*'\n                try:\n                    for name in sorted(glob.glob(pat)):\n                        self._write(name + \"\\n\")\n                except Exception as ex:\n                    self._write(f\"ls: {ex}\\n\")\n            elif cmd == '%clear':\n                self.clear()\n            else:\n                self._write(f\"Unknown magic: {cmd}\\n\")\n            self._buffer_lines.clear()\n            self._insert_prompt(primary=True)\n            return\n\n        # (Removed redundant %run handler block)\n\n        # We have a complete block: execute\n        self._history.append(code_to_run)\n        self._hist_idx = len(self._history)\n        self._buffer_lines.clear()\n\n        # Refresh dynamic objects (window, mct/mcts, etc.) into the persistent namespace\n        self._refresh_namespace()\n        try:\n            # Try eval first for simple expressions, using the same dict for globals/locals\n            result = None\n            try:\n                result = eval(code_to_run, self._ns, self._ns)  # nosec: local dev console\n            except SyntaxError:\n                exec(code_to_run, self._ns, self._ns)  # nosec: local dev console\n                result = None\n            if result is not None:\n                self._write(repr(result) + \"\\n\")\n            self.sigExecuted.emit(code_to_run)\n        except Exception as ex:  # noqa: BLE001\n            self._write(f\"Error: {ex}\\n\")\n\n        cur = self.textCursor()\n        cur.movePosition(QtGui.QTextCursor.End)\n        self.setTextCursor(cur)\n\n        # New primary prompt\n        self._insert_prompt(primary=True)\n</code></pre>"},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console.ConsoleWidget.sigExecuted","title":"<code>sigExecuted = QtCore.Signal(str)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console.ConsoleWidget.eventFilter","title":"<code>eventFilter(obj, event)</code>","text":"Source code in <code>src/c2f4dt/ui/console.py</code> <pre><code>def eventFilter(self, obj, event):\n    # Prevent mouse from placing cursor before prompt\n    if event.type() == QtCore.QEvent.MouseButtonPress:\n        pos = event.position() if hasattr(event, \"position\") else event.pos()\n        return False  # allow default, we'll clamp in keyPressEvent\n    return super().eventFilter(obj, event)\n</code></pre>"},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console.ConsoleWidget.keyPressEvent","title":"<code>keyPressEvent(event)</code>","text":"Source code in <code>src/c2f4dt/ui/console.py</code> <pre><code>def keyPressEvent(self, event: QtGui.QKeyEvent) -&gt; None:\n    key = event.key()\n    mod = event.modifiers()\n\n    # Ensure cursor never goes before current prompt\n    if key in (QtCore.Qt.Key_Home,):\n        # Move to after prompt on Home\n        cur = self.textCursor()\n        cur.setPosition(self._prompt_pos)\n        self.setTextCursor(cur)\n        return\n\n    if key in (QtCore.Qt.Key_Backspace,):\n        if self.textCursor().position() &lt;= self._prompt_pos:\n            return  # block backspace before prompt\n\n    # History navigation (only if caret at end line region)\n    if key in (QtCore.Qt.Key_Up, QtCore.Qt.Key_Down):\n        cur = self.textCursor()\n        if cur.position() &gt;= self._prompt_pos:\n            if key == QtCore.Qt.Key_Up:\n                self._history_prev()\n            else:\n                self._history_next()\n            return\n\n    # Autocomplete on TAB\n    if key == QtCore.Qt.Key_Tab:\n        self._autocomplete()\n        return\n\n    # Execute on Enter/Return\n    if key in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter) and not (mod &amp; QtCore.Qt.ShiftModifier):\n        self._on_enter()\n        return\n\n    # Allow explicit newline with Shift+Enter\n    if key in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter) and (mod &amp; QtCore.Qt.ShiftModifier):\n        super().keyPressEvent(event)\n        return\n\n    # Block editing before prompt: if cursor is before prompt, jump to end\n    if self.textCursor().position() &lt; self._prompt_pos:\n        cur = self.textCursor()\n        cur.setPosition(self.document().characterCount() - 1)\n        self.setTextCursor(cur)\n\n    # If completer popup is visible, let it handle navigation keys\n    if hasattr(self, \"_completer\") and self._completer.popup() and self._completer.popup().isVisible():\n        if key in (QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return, QtCore.Qt.Key_Escape,\n                QtCore.Qt.Key_Tab, QtCore.Qt.Key_Backtab,\n                QtCore.Qt.Key_Up, QtCore.Qt.Key_Down,\n                QtCore.Qt.Key_PageUp, QtCore.Qt.Key_PageDown):\n            event.ignore()\n            return\n\n    super().keyPressEvent(event)\n</code></pre>"},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console.PythonHighlighter","title":"<code>PythonHighlighter</code>","text":"<p>               Bases: <code>QSyntaxHighlighter</code></p> <p>Very lightweight Python syntax highlighter for the console.</p> Source code in <code>src/c2f4dt/ui/console.py</code> <pre><code>class PythonHighlighter(QSyntaxHighlighter):\n    \"\"\"Very lightweight Python syntax highlighter for the console.\"\"\"\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.rules = []\n\n        def fmt(color_hex: str, bold: bool = False) -&gt; QTextCharFormat:\n            f = QTextCharFormat()\n            f.setForeground(QColor(color_hex))\n            if bold:\n                f.setFontWeight(QtGui.QFont.Bold)\n            return f\n\n        # Keywords\n        kw_fmt = fmt(\"#C586C0\", bold=True)\n        keywords = [\n            'False','class','finally','is','return','None','continue','for','lambda','try',\n            'True','def','from','nonlocal','while','and','del','global','not','with',\n            'as','elif','if','or','yield','assert','else','import','pass','break','except','in','raise'\n        ]\n        for kw in keywords:\n            self.rules.append((QtCore.QRegularExpression(r\"\\b\" + kw + r\"\\b\"), kw_fmt))\n\n        # Strings\n        str_fmt = fmt(\"#CE9178\")\n        self.rules.append((QtCore.QRegularExpression(r\"'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"), str_fmt))\n        self.rules.append((QtCore.QRegularExpression(r'\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'), str_fmt))\n\n        # Comments\n        com_fmt = fmt(\"#6A9955\")\n        self.rules.append((QtCore.QRegularExpression(r\"#.*$\"), com_fmt))\n\n    def highlightBlock(self, text: str) -&gt; None:\n        for rx, form in self.rules:\n            it = rx.globalMatch(text)\n            while it.hasNext():\n                m = it.next()\n                self.setFormat(m.capturedStart(), m.capturedLength(), form)\n</code></pre>"},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console.PythonHighlighter.rules","title":"<code>rules = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/console/#c2f4dt.ui.console.PythonHighlighter.highlightBlock","title":"<code>highlightBlock(text)</code>","text":"Source code in <code>src/c2f4dt/ui/console.py</code> <pre><code>def highlightBlock(self, text: str) -&gt; None:\n    for rx, form in self.rules:\n        it = rx.globalMatch(text)\n        while it.hasNext():\n            m = it.next()\n            self.setFormat(m.capturedStart(), m.capturedLength(), form)\n</code></pre>"},{"location":"api/c2f4dt/ui/display_panel/","title":"c2f4dt.ui.display_panel","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel","title":"<code>c2f4dt.ui.display_panel</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel","title":"<code>DisplayPanel</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>Property panel for dataset visualization.</p> Signals <p>sigPointSizeChanged: Emitted when point size changes. sigPointBudgetChanged: Emitted when point budget (%) changes. sigColorModeChanged: Emitted when color mode changes. sigSolidColorChanged: Emitted when solid color changes. sigColormapChanged: Emitted when colormap changes. sigMeshRepresentationChanged: Emitted when mesh representation changes. sigMeshOpacityChanged: Emitted when mesh opacity changes.</p> Source code in <code>src/c2f4dt/ui/display_panel.py</code> <pre><code>class DisplayPanel(QtWidgets.QWidget):\n    \"\"\"Property panel for dataset visualization.\n\n    Signals:\n        sigPointSizeChanged: Emitted when point size changes.\n        sigPointBudgetChanged: Emitted when point budget (%) changes.\n        sigColorModeChanged: Emitted when color mode changes.\n        sigSolidColorChanged: Emitted when solid color changes.\n        sigColormapChanged: Emitted when colormap changes.\n        sigMeshRepresentationChanged: Emitted when mesh representation changes.\n        sigMeshOpacityChanged: Emitted when mesh opacity changes.\n\n        # Normals (compute) signals\n        sigComputeNormals: Emitted when compute normals is requested.\n        sigFastNormalsChanged: Emitted when fast normals checkbox changes.\n        sigNormalsStyleChanged: Emitted when normals display style changes.\n        sigNormalsColorChanged: Emitted when normals uniform color changes.\n        sigNormalsPercentChanged/sigNormalsScaleChanged: Emitted when fraction/scale of shown normals changes.\n    \"\"\"\n\n    # Signals\n    sigPointSizeChanged = QtCore.Signal(int)\n    sigPointBudgetChanged = QtCore.Signal(int)\n    sigColorModeChanged = QtCore.Signal(str)\n    sigSolidColorChanged = QtCore.Signal(QtGui.QColor)\n    sigColormapChanged = QtCore.Signal(str)\n    sigMeshRepresentationChanged = QtCore.Signal(str)\n    sigMeshOpacityChanged = QtCore.Signal(int)\n\n    # Normals (display) signals\n    sigNormalsStyleChanged = QtCore.Signal(str)       # 'Uniform' | 'Axis RGB' | 'RGB Components'\n    sigNormalsColorChanged = QtCore.Signal(QtGui.QColor)\n    sigNormalsPercentChanged = QtCore.Signal(int)     # 1..100\n    sigNormalsScaleChanged = QtCore.Signal(int)       # 1..200\n\n    # Normals (compute) signals\n    sigComputeNormals = QtCore.Signal()\n    sigFastNormalsChanged = QtCore.Signal(bool)\n\n    def __init__(self, parent=None) -&gt; None:\n        \"\"\"Initialize the panel with controls.\"\"\"\n        super().__init__(parent)\n        form = QtWidgets.QFormLayout(self)\n        form.setLabelAlignment(QtCore.Qt.AlignRight)\n        form.setFormAlignment(QtCore.Qt.AlignTop)\n        # Width constraints must be set on widgets, not layouts\n        self.setMaximumWidth(300)\n        self.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Expanding)\n        # (optional) tighten paddings to fit narrow panel nicely\n        form.setHorizontalSpacing(6)\n        form.setVerticalSpacing(6)\n        form.setContentsMargins(6, 6, 6, 6)\n        self.form = form\n\n        # ---- Capabilities (what is present in scene) ----\n        self._has_points = True\n        self._has_mesh = True\n        self._kind = \"points\"  # kept for backward compat; no longer hides rows\n\n        # Points visualization group box (ALWAYS visible)\n        pointsGroupBox = QtWidgets.QGroupBox(\"Points Visualization\")\n        pointsGroupBox.setMaximumWidth(300)\n        pointsGroupBox.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)\n        pointsLayout = QtWidgets.QFormLayout(pointsGroupBox)\n\n        # Point size\n        self.sldSize = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.sldSize.setRange(1, 20)\n        self.sldSize.setValue(3)\n        self.spinSize = QtWidgets.QSpinBox()\n        self.spinSize.setRange(1, 20)\n        self.spinSize.setValue(3)\n        self.sldSize.valueChanged.connect(self.spinSize.setValue)\n        self.spinSize.valueChanged.connect(self.sldSize.setValue)\n        self.sldSize.valueChanged.connect(self.sigPointSizeChanged)\n        sizeRow = QtWidgets.QHBoxLayout()\n        sizeRow.addWidget(self.sldSize, 1)\n        sizeRow.addWidget(self.spinSize)\n        self.rowSize = _wrap(sizeRow)\n        pointsLayout.addRow(\"Point size\", self.rowSize)\n\n        # Point budget (%)\n        self.sldBudget = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.sldBudget.setRange(1, 100)\n        self.sldBudget.setValue(100)\n        self.spinBudget = QtWidgets.QSpinBox()\n        self.spinBudget.setRange(1, 100)\n        self.spinBudget.setValue(100)\n        self.sldBudget.valueChanged.connect(self.spinBudget.setValue)\n        self.spinBudget.valueChanged.connect(self.sldBudget.setValue)\n        self.sldBudget.valueChanged.connect(self.sigPointBudgetChanged)\n        budRow = QtWidgets.QHBoxLayout()\n        budRow.addWidget(self.sldBudget, 1)\n        budRow.addWidget(self.spinBudget)\n        self.rowBudget = _wrap(budRow)\n        pointsLayout.addRow(\"% points shown\", self.rowBudget)\n\n        # Color mode\n        self.cmbColorMode = QtWidgets.QComboBox()\n        self.cmbColorMode.addItems([\"Solid\", \"Normal RGB\", \"Normal Colormap\"])\n        self.cmbColorMode.currentTextChanged.connect(self._on_mode_changed)\n        self.rowColorMode = self.cmbColorMode\n        pointsLayout.addRow(\"Color mode\", self.rowColorMode)\n\n        # Solid color (+ preview)\n        self.btnColor = QtWidgets.QPushButton(\"Choose\u2026\")\n        self.btnColor.clicked.connect(self._pick_color)\n        self.colorPreview = QtWidgets.QLabel()\n        self.colorPreview.setFixedSize(20, 20)\n        self.colorPreview.setAutoFillBackground(True)\n        self._update_color_preview(QtGui.QColor(255, 255, 255))  # Default to white\n        colorRow = QtWidgets.QHBoxLayout()\n        colorRow.addWidget(self.btnColor)\n        colorRow.addWidget(self.colorPreview)\n        self.rowSolid = _wrap(colorRow)\n        pointsLayout.addRow(\"Solid color\", self.rowSolid)\n\n        # Colormap\n        self.cmbCmap = QtWidgets.QComboBox()\n        self.cmbCmap.addItems([\"viridis\", \"magma\", \"plasma\", \"cividis\"])\n        self.cmbCmap.currentTextChanged.connect(self.sigColormapChanged)\n        self.rowCmap = self.cmbCmap\n        pointsLayout.addRow(\"Colormap\", self.rowCmap)\n\n        form.addRow(pointsGroupBox)\n\n        # --- Normals visualization controls (ALWAYS visible, but may be disabled) ---\n        self._build_normals_section(form)\n\n        # --- Mesh visualization group box (NEW &amp; ALWAYS visible) ---\n        meshGroupBox = QtWidgets.QGroupBox(\"Mesh Visualization\")\n        meshGroupBox.setMaximumWidth(300)\n        meshGroupBox.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)\n        meshLayout = QtWidgets.QFormLayout(meshGroupBox)\n\n        # Representation\n        self.cmbMeshRep = QtWidgets.QComboBox()\n        self.cmbMeshRep.addItems([\"Surface\", \"Wireframe\", \"Surface with Edges\", \"Points\"])\n        self.cmbMeshRep.currentTextChanged.connect(self.sigMeshRepresentationChanged)\n        self.rowMeshRep = self.cmbMeshRep\n        meshLayout.addRow(\"Representation\", self.rowMeshRep)\n\n        # Opacity\n        self.sldOpacity = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.sldOpacity.setRange(0, 100)\n        self.sldOpacity.setValue(100)\n        self.spinOpacity = QtWidgets.QSpinBox()\n        self.spinOpacity.setRange(0, 100)\n        self.spinOpacity.setValue(100)\n        self.sldOpacity.valueChanged.connect(self.spinOpacity.setValue)\n        self.spinOpacity.valueChanged.connect(self.sldOpacity.setValue)\n        self.sldOpacity.valueChanged.connect(self.sigMeshOpacityChanged)\n        opaRow = QtWidgets.QHBoxLayout()\n        opaRow.addWidget(self.sldOpacity, 1)\n        opaRow.addWidget(self.spinOpacity)\n        self.rowOpacity = _wrap(opaRow)\n        meshLayout.addRow(\"Opacity\", self.rowOpacity)\n\n        form.addRow(meshGroupBox)\n\n        # Initial enable/disable pass\n        self._update_visibility()\n\n    # NOTE: Changing color mode should not recreate the scalar bar.\n    # The viewer manages bar placement via `set_colorbar_mode`.\n    def _on_mode_changed(self, text: str) -&gt; None:\n        \"\"\"Handle color mode change.\"\"\"\n        self.sigColorModeChanged.emit(text)\n        self._update_visibility()\n\n    def _update_visibility(self) -&gt; None:\n        \"\"\"Enable/disable controls based on current capabilities.\n\n        Rules:\n        - Points controls are always visible; enabled only if _has_points is True.\n        - Mesh controls are always visible; enabled only if _has_mesh is True.\n        - Within points controls:\n            * When color mode == 'Solid' -&gt; enable solid color widgets, disable colormap.\n            * When color mode == 'Normal Colormap' -&gt; enable colormap, disable solid color.\n            * 'Normal RGB' -&gt; both solid and colormap selectors are disabled (RGB is derived).\n        - Normals controls are enabled only if _has_points is True.\n        \"\"\"\n        has_pts = bool(self._has_points)\n        has_mesh = bool(self._has_mesh)\n\n        # Points: base enables\n        self.sldSize.setEnabled(has_pts)\n        self.spinSize.setEnabled(has_pts)\n        self.sldBudget.setEnabled(has_pts)\n        self.spinBudget.setEnabled(has_pts)\n        self.cmbColorMode.setEnabled(has_pts)\n\n        # Points: color sub-modes\n        mode = self.cmbColorMode.currentText()\n        solid_mode = (mode == \"Solid\")\n        cmap_mode = (mode == \"Normal Colormap\")\n\n        self.btnColor.setEnabled(has_pts and solid_mode)\n        self.colorPreview.setEnabled(has_pts and solid_mode)\n        self.cmbCmap.setEnabled(has_pts and cmap_mode)\n\n        # Normals\n        self.comboNormalsStyle.setEnabled(has_pts)\n        self.btnNormalsColor.setEnabled(has_pts and self.comboNormalsStyle.currentText() == \"Uniform\")\n        self.spinNormalsPercent.setEnabled(has_pts)\n        self.sliderNormalsScale.setEnabled(has_pts)\n\n        # Mesh\n        self.cmbMeshRep.setEnabled(has_mesh)\n        self.sldOpacity.setEnabled(has_mesh)\n        self.spinOpacity.setEnabled(has_mesh)\n\n    def set_capabilities(self, has_points: bool, has_mesh: bool) -&gt; None:\n        \"\"\"Declare what is currently available in the scene (points and/or mesh).\n\n        Call this whenever the current tree selection changes, or after imports.\n        The panel keeps every section visible and only toggles enabled state.\n        \"\"\"\n        self._has_points = bool(has_points)\n        self._has_mesh = bool(has_mesh)\n        self._update_visibility()\n\n    def _pick_color(self) -&gt; None:\n        \"\"\"Open color dialog and emit chosen color.\"\"\"\n        col = QtWidgets.QColorDialog.getColor(parent=self)\n        if col.isValid():\n            self._update_color_preview(col)\n            self.sigSolidColorChanged.emit(col)\n\n    def _update_color_preview(self, col: QtGui.QColor) -&gt; None:\n        \"\"\"Update the small color square beside the button.\n\n        The square mirrors the currently selected solid color and follows\n        the visibility/enabled state of the Solid controls. If ``col`` is not\n        valid, fall back to a neutral gray.\n        \"\"\"\n        if not isinstance(col, QtGui.QColor) or not col.isValid():\n            col = QtGui.QColor(200, 200, 200)\n        # Apply a simple stylesheet so it also works across themes\n        try:\n            hexcol = col.name(QtGui.QColor.HexRgb)\n        except Exception:\n            hexcol = col.name()\n        self.colorPreview.setStyleSheet(\n            f\"QLabel {{ border:1px solid #666; border-radius:2px; background-color:{hexcol}; }}\"\n        )\n        self.colorPreview.setToolTip(f\"Solid color: {hexcol}\")\n\n    def _set_row_visible(self, widget: QtWidgets.QWidget, visible: bool) -&gt; None:\n        \"\"\"Utility to show/hide a form row.\"\"\"\n        widget.setVisible(visible)\n        lbl = self.form.labelForField(widget)\n        if lbl is not None:\n            lbl.setVisible(visible)\n\n    def fast_normals_enabled(self) -&gt; bool:\n        \"\"\"Return True if 'Fast normals' is currently enabled.\"\"\"\n        try:\n            return bool(self.chkFastNormals.isChecked())\n        except Exception:\n            return True\n\n    def set_mode(self, kind: str) -&gt; None:\n        \"\"\"Kept for backward compatibility. Does not hide sections anymore.\"\"\"\n        self._kind = kind\n        self._update_visibility()\n\n    def apply_properties(self, props: dict) -&gt; None:\n        \"\"\"Load properties into the panel (non-destructive to visibility).\n\n        This method must NOT emit any signals, as it is used to synchronize UI\n        widgets with external state (e.g., loading). All widget updates are signal-safe.\n        \"\"\"\n        # Optional: detect availability hints\n        self._has_points = bool(props.get(\"has_points\", self._has_points))\n        self._has_mesh = bool(props.get(\"has_mesh\", self._has_mesh))\n\n        kind = props.get(\"kind\", \"points\")\n\n        # Point size (signal-safe)\n        try:\n            self.sldSize.blockSignals(True)\n            self.spinSize.blockSignals(True)\n            self.sldSize.setValue(int(props.get(\"point_size\", self.sldSize.value())))\n            self.spinSize.setValue(self.sldSize.value())\n        finally:\n            self.sldSize.blockSignals(False)\n            self.spinSize.blockSignals(False)\n\n        # Point budget (signal-safe)\n        try:\n            self.sldBudget.blockSignals(True)\n            self.spinBudget.blockSignals(True)\n            self.sldBudget.setValue(int(props.get(\"point_budget\", self.sldBudget.value())))\n            self.spinBudget.setValue(self.sldBudget.value())\n        finally:\n            self.sldBudget.blockSignals(False)\n            self.spinBudget.blockSignals(False)\n\n        # Color mode (signal-safe)\n        try:\n            self.cmbColorMode.blockSignals(True)\n            self.cmbColorMode.setCurrentText(str(props.get(\"color_mode\", self.cmbColorMode.currentText())))\n        finally:\n            self.cmbColorMode.blockSignals(False)\n\n        # Colormap (signal-safe)\n        try:\n            self.cmbCmap.blockSignals(True)\n            self.cmbCmap.setCurrentText(str(props.get(\"colormap\", self.cmbCmap.currentText())))\n        finally:\n            self.cmbCmap.blockSignals(False)\n\n        # Solid color preview (already signal-free, just update preview)\n        col = props.get(\"solid_color\")\n        if col is not None:\n            try:\n                r, g, b = col\n                if r &lt;= 1 and g &lt;= 1 and b &lt;= 1:\n                    r, g, b = int(r * 255), int(g * 255), int(b * 255)\n                self._update_color_preview(QtGui.QColor(int(r), int(g), int(b)))\n            except Exception:\n                pass\n\n        # Normals\n        style = props.get(\"normals_style\")\n        if style in (\"Uniform\", \"Axis RGB\", \"RGB Components\"):\n            self.comboNormalsStyle.blockSignals(True)\n            self.comboNormalsStyle.setCurrentText(style)\n            self.comboNormalsStyle.blockSignals(False)\n        if \"normals_percent\" in props:\n            self.spinNormalsPercent.blockSignals(True)\n            self.spinNormalsPercent.setValue(int(props[\"normals_percent\"]))\n            self.spinNormalsPercent.blockSignals(False)\n        if \"normals_scale\" in props:\n            self.sliderNormalsScale.blockSignals(True)\n            self.sliderNormalsScale.setValue(int(props[\"normals_scale\"]))\n            self.sliderNormalsScale.blockSignals(False)\n\n        # Mesh\n        if \"representation\" in props:\n            self.cmbMeshRep.setCurrentText(str(props[\"representation\"]))\n        if \"opacity\" in props:\n            self.sldOpacity.setValue(int(props[\"opacity\"]))\n\n        # Refresh enable/disable state only (do not emit any signals)\n        self.set_mode(kind)\n\n    # ------------------------------------------------------------------\n    # Normals display UI\n    # ------------------------------------------------------------------\n    def _build_normals_section(self, form: QtWidgets.QFormLayout) -&gt; None:\n        \"\"\"Build UI controls for normals visualization.\n\n        Controls:\n          * Style: Uniform | Axis RGB | RGB Components\n          * Color button (enabled only for Uniform)\n          * Percent shown: 1..100 %\n          * Vector size (scale): 1..200\n        \"\"\"\n\n        normalsGroupBox = QtWidgets.QGroupBox(\"Normals Visualization\")\n        normalsGroupBox.setMaximumWidth(300)\n        normalsGroupBox.setSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)\n        normalsLayout = QtWidgets.QVBoxLayout(normalsGroupBox)\n\n        bar_plugin = QtWidgets.QHBoxLayout()\n        self.btnComputeNormals = QtWidgets.QPushButton(\"Compute normals\u2026\")\n        self.btnComputeNormals.setObjectName(\"btnComputeNormals\")\n        self.chkFastNormals = QtWidgets.QCheckBox(\"Fast normals\")\n        self.chkFastNormals.setObjectName(\"chkFastNormals\")\n        self.chkFastNormals.setChecked(True)\n        bar_plugin.addWidget(self.btnComputeNormals)\n        bar_plugin.addWidget(self.chkFastNormals)\n        normalsLayout.addLayout(bar_plugin)\n        # Emit high-level signals for the host window\n        self.btnComputeNormals.clicked.connect(self.sigComputeNormals.emit)\n        self.chkFastNormals.toggled.connect(self.sigFastNormalsChanged)\n\n        row1 = QtWidgets.QHBoxLayout()\n\n        # Style combo\n        self.comboNormalsStyle = QtWidgets.QComboBox()\n        self.comboNormalsStyle.setObjectName(\"comboNormalsStyle\")\n        self.comboNormalsStyle.addItems([\"Uniform\", \"Axis RGB\", \"RGB Components\"])  # 3 modes\n        self.comboNormalsStyle.currentTextChanged.connect(self.sigNormalsStyleChanged.emit)\n        row1.addWidget(self.comboNormalsStyle, 1)\n\n        # Color button (only for Uniform)\n        self.btnNormalsColor = QtWidgets.QPushButton(\"Color\u2026\")\n        self.btnNormalsColor.setObjectName(\"btnNormalsColor\")\n        self.btnNormalsColor.clicked.connect(self._on_pick_normals_color)\n        row1.addWidget(self.btnNormalsColor)\n\n        self.rowNormalsStyle = _wrap(row1)\n        normalsLayout.addWidget(self.rowNormalsStyle)\n\n        row2 = QtWidgets.QHBoxLayout()\n        # Percent of normals to show\n        self.spinNormalsPercent = QtWidgets.QSpinBox()\n        self.spinNormalsPercent.setRange(1, 100)\n        self.spinNormalsPercent.setValue(1)\n        self.spinNormalsPercent.setSuffix(\" %\")\n        self.spinNormalsPercent.valueChanged.connect(self.sigNormalsPercentChanged.emit)\n        row2.addWidget(QtWidgets.QLabel(\"Shown:\"))\n        row2.addWidget(self.spinNormalsPercent)\n\n        # Vector size (glyph scale)\n        self.sliderNormalsScale = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.sliderNormalsScale.setRange(1, 200)\n        self.sliderNormalsScale.setValue(20)\n        self.sliderNormalsScale.setObjectName(\"sliderNormalsScale\")\n        self.sliderNormalsScale.valueChanged.connect(self.sigNormalsScaleChanged.emit)\n        row2.addWidget(QtWidgets.QLabel(\"Size:\"))\n        row2.addWidget(self.sliderNormalsScale, 2)\n\n        self.rowNormals = _wrap(row2)\n        normalsLayout.addWidget(self.rowNormals)\n\n        # Enable state for color button (only Uniform)\n        self._update_normals_color_enabled(self.comboNormalsStyle.currentText())\n        self.comboNormalsStyle.currentTextChanged.connect(self._update_normals_color_enabled)\n\n        form.addRow(normalsGroupBox)\n\n    def _on_pick_normals_color(self) -&gt; None:\n        \"\"\"Open a color dialog and emit chosen uniform color for normals.\"\"\"\n        col = QtWidgets.QColorDialog.getColor(parent=self, title=\"Normals color\")\n        if col.isValid():\n            self.sigNormalsColorChanged.emit(col)\n\n    def _update_normals_color_enabled(self, mode: str) -&gt; None:\n        \"\"\"Enable/disable the normals color button based on the selected style.\"\"\"\n        enable = (mode == \"Uniform\")\n        try:\n            self.btnNormalsColor.setEnabled(enable)\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel--normals-compute-signals","title":"Normals (compute) signals","text":"<p>sigComputeNormals: Emitted when compute normals is requested. sigFastNormalsChanged: Emitted when fast normals checkbox changes. sigNormalsStyleChanged: Emitted when normals display style changes. sigNormalsColorChanged: Emitted when normals uniform color changes. sigNormalsPercentChanged/sigNormalsScaleChanged: Emitted when fraction/scale of shown normals changes.</p>"},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.btnColor","title":"<code>btnColor = QtWidgets.QPushButton('Choose\u2026')</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.cmbCmap","title":"<code>cmbCmap = QtWidgets.QComboBox()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.cmbColorMode","title":"<code>cmbColorMode = QtWidgets.QComboBox()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.cmbMeshRep","title":"<code>cmbMeshRep = QtWidgets.QComboBox()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.colorPreview","title":"<code>colorPreview = QtWidgets.QLabel()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.form","title":"<code>form = form</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.rowBudget","title":"<code>rowBudget = _wrap(budRow)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.rowCmap","title":"<code>rowCmap = self.cmbCmap</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.rowColorMode","title":"<code>rowColorMode = self.cmbColorMode</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.rowMeshRep","title":"<code>rowMeshRep = self.cmbMeshRep</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.rowOpacity","title":"<code>rowOpacity = _wrap(opaRow)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.rowSize","title":"<code>rowSize = _wrap(sizeRow)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.rowSolid","title":"<code>rowSolid = _wrap(colorRow)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigColorModeChanged","title":"<code>sigColorModeChanged = QtCore.Signal(str)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigColormapChanged","title":"<code>sigColormapChanged = QtCore.Signal(str)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigComputeNormals","title":"<code>sigComputeNormals = QtCore.Signal()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigFastNormalsChanged","title":"<code>sigFastNormalsChanged = QtCore.Signal(bool)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigMeshOpacityChanged","title":"<code>sigMeshOpacityChanged = QtCore.Signal(int)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigMeshRepresentationChanged","title":"<code>sigMeshRepresentationChanged = QtCore.Signal(str)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigNormalsColorChanged","title":"<code>sigNormalsColorChanged = QtCore.Signal(QtGui.QColor)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigNormalsPercentChanged","title":"<code>sigNormalsPercentChanged = QtCore.Signal(int)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigNormalsScaleChanged","title":"<code>sigNormalsScaleChanged = QtCore.Signal(int)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigNormalsStyleChanged","title":"<code>sigNormalsStyleChanged = QtCore.Signal(str)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigPointBudgetChanged","title":"<code>sigPointBudgetChanged = QtCore.Signal(int)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigPointSizeChanged","title":"<code>sigPointSizeChanged = QtCore.Signal(int)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sigSolidColorChanged","title":"<code>sigSolidColorChanged = QtCore.Signal(QtGui.QColor)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sldBudget","title":"<code>sldBudget = QtWidgets.QSlider(QtCore.Qt.Horizontal)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sldOpacity","title":"<code>sldOpacity = QtWidgets.QSlider(QtCore.Qt.Horizontal)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.sldSize","title":"<code>sldSize = QtWidgets.QSlider(QtCore.Qt.Horizontal)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.spinBudget","title":"<code>spinBudget = QtWidgets.QSpinBox()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.spinOpacity","title":"<code>spinOpacity = QtWidgets.QSpinBox()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.spinSize","title":"<code>spinSize = QtWidgets.QSpinBox()</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.apply_properties","title":"<code>apply_properties(props)</code>","text":"<p>Load properties into the panel (non-destructive to visibility).</p> <p>This method must NOT emit any signals, as it is used to synchronize UI widgets with external state (e.g., loading). All widget updates are signal-safe.</p> Source code in <code>src/c2f4dt/ui/display_panel.py</code> <pre><code>def apply_properties(self, props: dict) -&gt; None:\n    \"\"\"Load properties into the panel (non-destructive to visibility).\n\n    This method must NOT emit any signals, as it is used to synchronize UI\n    widgets with external state (e.g., loading). All widget updates are signal-safe.\n    \"\"\"\n    # Optional: detect availability hints\n    self._has_points = bool(props.get(\"has_points\", self._has_points))\n    self._has_mesh = bool(props.get(\"has_mesh\", self._has_mesh))\n\n    kind = props.get(\"kind\", \"points\")\n\n    # Point size (signal-safe)\n    try:\n        self.sldSize.blockSignals(True)\n        self.spinSize.blockSignals(True)\n        self.sldSize.setValue(int(props.get(\"point_size\", self.sldSize.value())))\n        self.spinSize.setValue(self.sldSize.value())\n    finally:\n        self.sldSize.blockSignals(False)\n        self.spinSize.blockSignals(False)\n\n    # Point budget (signal-safe)\n    try:\n        self.sldBudget.blockSignals(True)\n        self.spinBudget.blockSignals(True)\n        self.sldBudget.setValue(int(props.get(\"point_budget\", self.sldBudget.value())))\n        self.spinBudget.setValue(self.sldBudget.value())\n    finally:\n        self.sldBudget.blockSignals(False)\n        self.spinBudget.blockSignals(False)\n\n    # Color mode (signal-safe)\n    try:\n        self.cmbColorMode.blockSignals(True)\n        self.cmbColorMode.setCurrentText(str(props.get(\"color_mode\", self.cmbColorMode.currentText())))\n    finally:\n        self.cmbColorMode.blockSignals(False)\n\n    # Colormap (signal-safe)\n    try:\n        self.cmbCmap.blockSignals(True)\n        self.cmbCmap.setCurrentText(str(props.get(\"colormap\", self.cmbCmap.currentText())))\n    finally:\n        self.cmbCmap.blockSignals(False)\n\n    # Solid color preview (already signal-free, just update preview)\n    col = props.get(\"solid_color\")\n    if col is not None:\n        try:\n            r, g, b = col\n            if r &lt;= 1 and g &lt;= 1 and b &lt;= 1:\n                r, g, b = int(r * 255), int(g * 255), int(b * 255)\n            self._update_color_preview(QtGui.QColor(int(r), int(g), int(b)))\n        except Exception:\n            pass\n\n    # Normals\n    style = props.get(\"normals_style\")\n    if style in (\"Uniform\", \"Axis RGB\", \"RGB Components\"):\n        self.comboNormalsStyle.blockSignals(True)\n        self.comboNormalsStyle.setCurrentText(style)\n        self.comboNormalsStyle.blockSignals(False)\n    if \"normals_percent\" in props:\n        self.spinNormalsPercent.blockSignals(True)\n        self.spinNormalsPercent.setValue(int(props[\"normals_percent\"]))\n        self.spinNormalsPercent.blockSignals(False)\n    if \"normals_scale\" in props:\n        self.sliderNormalsScale.blockSignals(True)\n        self.sliderNormalsScale.setValue(int(props[\"normals_scale\"]))\n        self.sliderNormalsScale.blockSignals(False)\n\n    # Mesh\n    if \"representation\" in props:\n        self.cmbMeshRep.setCurrentText(str(props[\"representation\"]))\n    if \"opacity\" in props:\n        self.sldOpacity.setValue(int(props[\"opacity\"]))\n\n    # Refresh enable/disable state only (do not emit any signals)\n    self.set_mode(kind)\n</code></pre>"},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.fast_normals_enabled","title":"<code>fast_normals_enabled()</code>","text":"<p>Return True if 'Fast normals' is currently enabled.</p> Source code in <code>src/c2f4dt/ui/display_panel.py</code> <pre><code>def fast_normals_enabled(self) -&gt; bool:\n    \"\"\"Return True if 'Fast normals' is currently enabled.\"\"\"\n    try:\n        return bool(self.chkFastNormals.isChecked())\n    except Exception:\n        return True\n</code></pre>"},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.set_capabilities","title":"<code>set_capabilities(has_points, has_mesh)</code>","text":"<p>Declare what is currently available in the scene (points and/or mesh).</p> <p>Call this whenever the current tree selection changes, or after imports. The panel keeps every section visible and only toggles enabled state.</p> Source code in <code>src/c2f4dt/ui/display_panel.py</code> <pre><code>def set_capabilities(self, has_points: bool, has_mesh: bool) -&gt; None:\n    \"\"\"Declare what is currently available in the scene (points and/or mesh).\n\n    Call this whenever the current tree selection changes, or after imports.\n    The panel keeps every section visible and only toggles enabled state.\n    \"\"\"\n    self._has_points = bool(has_points)\n    self._has_mesh = bool(has_mesh)\n    self._update_visibility()\n</code></pre>"},{"location":"api/c2f4dt/ui/display_panel/#c2f4dt.ui.display_panel.DisplayPanel.set_mode","title":"<code>set_mode(kind)</code>","text":"<p>Kept for backward compatibility. Does not hide sections anymore.</p> Source code in <code>src/c2f4dt/ui/display_panel.py</code> <pre><code>def set_mode(self, kind: str) -&gt; None:\n    \"\"\"Kept for backward compatibility. Does not hide sections anymore.\"\"\"\n    self._kind = kind\n    self._update_visibility()\n</code></pre>"},{"location":"api/c2f4dt/ui/import_summary_dialog/","title":"c2f4dt.ui.import_summary_dialog","text":""},{"location":"api/c2f4dt/ui/import_summary_dialog/#c2f4dt.ui.import_summary_dialog","title":"<code>c2f4dt.ui.import_summary_dialog</code>","text":""},{"location":"api/c2f4dt/ui/import_summary_dialog/#c2f4dt.ui.import_summary_dialog.ImportSummaryDialog","title":"<code>ImportSummaryDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>Modal dialog to review imported objects and choose import options.</p> <p>Inspired by CloudCompare. For each object we show discovered attributes (read-only) and let the user:   - Remap axes with sign (e.g., X=+Y, Y=-Z, Z=+X)   - Apply same mapping to normals   - Compute normals if missing   - Choose coloring preference (RGB or colormap over fake intensity)</p> <p>This dialog DOES NOT mutate input objects. Use <code>operations()</code> to retrieve what the user selected and apply it in the caller.</p> Source code in <code>src/c2f4dt/ui/import_summary_dialog.py</code> <pre><code>class ImportSummaryDialog(QtWidgets.QDialog):\n    \"\"\"Modal dialog to review imported objects and choose import options.\n\n    Inspired by CloudCompare. For each object we show discovered attributes\n    (read-only) and let the user:\n      - Remap axes with sign (e.g., X=+Y, Y=-Z, Z=+X)\n      - Apply same mapping to normals\n      - Compute normals if missing\n      - Choose coloring preference (RGB or colormap over fake intensity)\n\n    This dialog DOES NOT mutate input objects. Use `operations()` to\n    retrieve what the user selected and apply it in the caller.\n    \"\"\"\n\n    def __init__(self, objects: Iterable[ImportedObject], parent=None) -&gt; None:\n        super().__init__(parent)\n        self.setWindowTitle(\"Import summary\")\n        self.setModal(True)\n        self._objects: List[ImportedObject] = list(objects)\n\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.setContentsMargins(8, 8, 8, 8)\n        layout.setSpacing(8)\n\n        # One collapsible-like page per object (CloudCompare-like feel)\n        self.toolbox = QtWidgets.QToolBox(self)\n        layout.addWidget(self.toolbox, 1)\n\n        self._pages: List[Dict[str, Any]] = []\n        for obj in self._objects:\n            page = self._build_page(obj)\n            self.toolbox.addItem(page[\"widget\"], obj.name)\n            self._pages.append(page)\n\n        # Bounds/meta hint\n        self.lblMeta = QtWidgets.QLabel(\"\")\n        self.lblMeta.setWordWrap(True)\n        layout.addWidget(self.lblMeta)\n        self._populate_bounds()\n\n        btns = QtWidgets.QDialogButtonBox(\n            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel\n        )\n        btns.accepted.connect(self.accept)\n        btns.rejected.connect(self.reject)\n        layout.addWidget(btns)\n\n    # ------------------------------------------------------------------\n    # UI builders\n    # ------------------------------------------------------------------\n    def _build_page(self, obj: ImportedObject) -&gt; Dict[str, Any]:\n        \"\"\"Create one page with labels and options for an object.\n\n        Args:\n            obj: ImportedObject to present.\n\n        Returns:\n            A dict with references to created widgets to read them later.\n        \"\"\"\n        w = QtWidgets.QWidget()\n        form = QtWidgets.QFormLayout(w)\n        form.setLabelAlignment(QtCore.Qt.AlignRight)\n        form.setFormAlignment(QtCore.Qt.AlignTop)\n\n        # ---- Read-only attributes\n        npts = obj.points.shape[0] if obj.points is not None else (\n            obj.pv_mesh.n_points if obj.pv_mesh is not None else 0\n        )\n        nfaces = obj.faces.shape[0] if obj.faces is not None else (\n            obj.pv_mesh.n_faces if obj.pv_mesh is not None else 0\n        )\n        has_rgb = obj.colors is not None\n        has_int = obj.intensity is not None\n        has_nrm = getattr(obj, \"normals\", None) is not None\n\n        form.addRow(\"Kind\", QtWidgets.QLabel(obj.kind))\n        form.addRow(\"#Points\", QtWidgets.QLabel(str(npts)))\n        form.addRow(\"#Faces\", QtWidgets.QLabel(str(nfaces)))\n        form.addRow(\"Has RGB\", QtWidgets.QLabel(\"Yes\" if has_rgb else \"No\"))\n        form.addRow(\"Has Intensity\", QtWidgets.QLabel(\"Yes\" if has_int else \"No\"))\n        form.addRow(\"Has Normals\", QtWidgets.QLabel(\"Yes\" if has_nrm else \"No\"))\n\n        # ---- Axis mapping (with presets)\n        axis_opts = [\"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"]\n        cmb_preset = QtWidgets.QComboBox()\n        cmb_preset.addItems([\n            \"Custom\",\n            \"Z-up (identity)\",      # X-&gt;+X, Y-&gt;+Y, Z-&gt;+Z\n            \"Y-up (swap Y/Z)\",      # X-&gt;+X, Y-&gt;+Z, Z-&gt;-Y\n            \"X-up (swap X/Z)\",      # X-&gt;+Z, Y-&gt;+Y, Z-&gt;-X\n            \"Flip Z\",               # X-&gt;+X, Y-&gt;+Y, Z-&gt;-Z\n            \"Flip Y\",               # X-&gt;+X, Y-&gt;-Y, Z-&gt;+Z\n            \"Flip X\",               # X-&gt;-X, Y-&gt;+Y, Z-&gt;+Z\n        ])\n\n        cmb_x = QtWidgets.QComboBox(); cmb_x.addItems(axis_opts); cmb_x.setCurrentText(\"+X\")\n        cmb_y = QtWidgets.QComboBox(); cmb_y.addItems(axis_opts); cmb_y.setCurrentText(\"+Y\")\n        cmb_z = QtWidgets.QComboBox(); cmb_z.addItems(axis_opts); cmb_z.setCurrentText(\"+Z\")\n\n        def apply_preset(name: str) -&gt; None:\n            presets = {\n                \"Z-up (identity)\": (\"+X\", \"+Y\", \"+Z\"),\n                \"Y-up (swap Y/Z)\": (\"+X\", \"+Z\", \"-Y\"),\n                \"X-up (swap X/Z)\": (\"+Z\", \"+Y\", \"-X\"),\n                \"Flip Z\": (\"+X\", \"+Y\", \"-Z\"),\n                \"Flip Y\": (\"+X\", \"-Y\", \"+Z\"),\n                \"Flip X\": (\"-X\", \"+Y\", \"+Z\"),\n            }\n            if name in presets:\n                x, y, z = presets[name]\n                cmb_x.setCurrentText(x)\n                cmb_y.setCurrentText(y)\n                cmb_z.setCurrentText(z)\n\n        cmb_preset.currentTextChanged.connect(apply_preset)\n\n        form.addRow(\"Axis preset\", cmb_preset)\n        form.addRow(\"Map to X\", cmb_x)\n        form.addRow(\"Map to Y\", cmb_y)\n        form.addRow(\"Map to Z\", cmb_z)\n\n        chk_apply_normals = QtWidgets.QCheckBox(\"Apply same mapping to normals (if present)\")\n        chk_apply_normals.setChecked(True)\n        form.addRow(\"Normals mapping\", chk_apply_normals)\n\n        chk_compute_normals = QtWidgets.QCheckBox(\"Compute normals if missing\")\n        chk_compute_normals.setChecked(not has_nrm)\n        form.addRow(\"Normals compute\", chk_compute_normals)\n\n        # ---- Coloring preference\n        grp_color = QtWidgets.QGroupBox(\"Coloring preference\")\n        v = QtWidgets.QVBoxLayout(grp_color)\n        rad_rgb = QtWidgets.QRadioButton(\"Use RGB (if available)\")\n        rad_cmap = QtWidgets.QRadioButton(\"Use colormap (fake intensity)\")\n        if has_rgb:\n            rad_rgb.setChecked(True)\n        else:\n            rad_cmap.setChecked(True)\n        v.addWidget(rad_rgb)\n        v.addWidget(rad_cmap)\n        form.addRow(grp_color)\n\n        return {\n            \"widget\": w,\n            \"cmb_preset\": cmb_preset,\n            \"cmb_x\": cmb_x,\n            \"cmb_y\": cmb_y,\n            \"cmb_z\": cmb_z,\n            \"chk_apply_normals\": chk_apply_normals,\n            \"chk_compute_normals\": chk_compute_normals,\n            \"rad_rgb\": rad_rgb,\n            \"rad_cmap\": rad_cmap,\n            \"obj\": obj,\n        }\n\n    def _populate_bounds(self) -&gt; None:\n        meta_desc = []\n        for obj in self._objects:\n            b = obj.bounds() if hasattr(obj, \"bounds\") else None\n            if b:\n                meta_desc.append(\n                    f\"{obj.name} bounds: x=[{b[0]:.3f},{b[1]:.3f}] \"\n                    f\"y=[{b[2]:.3f},{b[3]:.3f}] z=[{b[4]:.3f},{b[5]:.3f}]\"\n                )\n        self.lblMeta.setText(\"\\n\".join(meta_desc))\n\n    # ------------------------------------------------------------------\n    # Results\n    # ------------------------------------------------------------------\n    @property\n    def objects(self) -&gt; List[ImportedObject]:\n        \"\"\"Return original objects (unchanged).\"\"\"\n        return self._objects\n\n    def operations(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Return per-object operations selected in the dialog.\n\n        Each entry:\n          - axis_map: {'X': str, 'Y': str, 'Z': str} in {+X,-X,+Y,-Y,+Z,-Z}\n          - map_normals: bool\n          - compute_normals_if_missing: bool\n          - color_preference: 'rgb' | 'colormap'\n        \"\"\"\n        ops: List[Dict[str, Any]] = []\n        for page in self._pages:\n            axis_map = {\n                \"X\": page[\"cmb_x\"].currentText(),\n                \"Y\": page[\"cmb_y\"].currentText(),\n                \"Z\": page[\"cmb_z\"].currentText(),\n            }\n            color_pref = \"rgb\" if page[\"rad_rgb\"].isChecked() else \"colormap\"\n            ops.append(\n                {\n                    \"axis_map\": axis_map,\n                    \"map_normals\": page[\"chk_apply_normals\"].isChecked(),\n                    \"compute_normals_if_missing\": page[\"chk_compute_normals\"].isChecked(),\n                    \"color_preference\": color_pref,\n                }\n            )\n        return ops\n</code></pre>"},{"location":"api/c2f4dt/ui/import_summary_dialog/#c2f4dt.ui.import_summary_dialog.ImportSummaryDialog.lblMeta","title":"<code>lblMeta = QtWidgets.QLabel('')</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/import_summary_dialog/#c2f4dt.ui.import_summary_dialog.ImportSummaryDialog.objects","title":"<code>objects</code>  <code>property</code>","text":"<p>Return original objects (unchanged).</p>"},{"location":"api/c2f4dt/ui/import_summary_dialog/#c2f4dt.ui.import_summary_dialog.ImportSummaryDialog.toolbox","title":"<code>toolbox = QtWidgets.QToolBox(self)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/import_summary_dialog/#c2f4dt.ui.import_summary_dialog.ImportSummaryDialog.operations","title":"<code>operations()</code>","text":"<p>Return per-object operations selected in the dialog.</p> Each entry <ul> <li>axis_map: {'X': str, 'Y': str, 'Z': str} in {+X,-X,+Y,-Y,+Z,-Z}</li> <li>map_normals: bool</li> <li>compute_normals_if_missing: bool</li> <li>color_preference: 'rgb' | 'colormap'</li> </ul> Source code in <code>src/c2f4dt/ui/import_summary_dialog.py</code> <pre><code>def operations(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Return per-object operations selected in the dialog.\n\n    Each entry:\n      - axis_map: {'X': str, 'Y': str, 'Z': str} in {+X,-X,+Y,-Y,+Z,-Z}\n      - map_normals: bool\n      - compute_normals_if_missing: bool\n      - color_preference: 'rgb' | 'colormap'\n    \"\"\"\n    ops: List[Dict[str, Any]] = []\n    for page in self._pages:\n        axis_map = {\n            \"X\": page[\"cmb_x\"].currentText(),\n            \"Y\": page[\"cmb_y\"].currentText(),\n            \"Z\": page[\"cmb_z\"].currentText(),\n        }\n        color_pref = \"rgb\" if page[\"rad_rgb\"].isChecked() else \"colormap\"\n        ops.append(\n            {\n                \"axis_map\": axis_map,\n                \"map_normals\": page[\"chk_apply_normals\"].isChecked(),\n                \"compute_normals_if_missing\": page[\"chk_compute_normals\"].isChecked(),\n                \"color_preference\": color_pref,\n            }\n        )\n    return ops\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/","title":"c2f4dt.ui.viewer3d","text":""},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d","title":"<code>c2f4dt.ui.viewer3d</code>","text":""},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D","title":"<code>Viewer3D</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>PyVistaQt-based 3D viewer with camera helpers and display API.</p> <p>This widget wraps a <code>pyvistaqt.QtInteractor</code> when available. All public methods are guarded with try/except so that the UI remains responsive.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>class Viewer3D(QtWidgets.QWidget):\n    \"\"\"PyVistaQt-based 3D viewer with camera helpers and display API.\n\n    This widget wraps a ``pyvistaqt.QtInteractor`` when available. All public\n    methods are guarded with try/except so that the UI remains responsive.\n    \"\"\"\n\n    def __init__(self, parent=None) -&gt; None:\n        super().__init__(parent)\n        # Lazy import so that the app can start without hard dependency at import-time.\n        from pyvistaqt import QtInteractor  # type: ignore\n        import pyvista as pv  # noqa: F401  (kept for future use)\n\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        self.plotter = QtInteractor(self)\n        layout.addWidget(self.plotter)\n        # ---- macOS/Metal safety tweaks ----\n        # These settings mitigate GPU driver recoveries seen on some Macs with Qt6+VTK.\n        try:\n            # Disable multisampling (anti-aliasing) at the render window level\n            if hasattr(self.plotter, \"render_window\"):\n                self.plotter.render_window.SetMultiSamples(0)\n\n            # Conservative interactive update rates (throttle rendering)\n            if hasattr(self.plotter, \"iren\"):\n                try:\n                    self.plotter.iren.SetDesiredUpdateRate(5.0)\n                    self.plotter.iren.SetStillUpdateRate(0.5)\n                except Exception:\n                    pass\n\n            # Disable depth peeling and FXAA which may stress Metal backend\n            try:\n                self.plotter.renderer.SetUseDepthPeeling(0)\n                if hasattr(self.plotter.renderer, \"SetUseFXAA\"):\n                    self.plotter.renderer.SetUseFXAA(False)\n            except Exception:\n                pass\n        except Exception:\n            pass\n        # Initial rendering cosmetics (tracked so we can re-apply after clear)\n        try:\n            self._bg_rgb = (255, 255, 255)  # default background; updated by set_background_color()\n            self._apply_background()\n        except Exception:\n            pass\n\n        # Track overlay state so that 'clear()' doesn't permanently remove them\n        self._axes_on: bool = True\n        self._bounds_on: bool = True\n        # Default PyVista bounds style; adjust as you like\n        self._bounds_kwargs: dict = {\"grid\": \"front\", \"location\": \"outer\"}\n\n        # Apply overlays once at startup\n        try:\n            self._apply_overlays()\n        except Exception:\n            pass\n\n        # State for display options\n        self._point_size = 3\n        self._budget = 100\n        self._color_mode = \"Solid\"\n        self._solid_color = (200, 200, 200)\n        self._cmap = getattr(self, \"_cmap\", \"viridis\")\n        # ---- Normals (viewer defaults) ------------------------------------\n        # Publicly controllable via setters; copied per-dataset at add time.\n        # style: \"Uniform\" | \"Axis RGB\" | \"RGB Components\"\n        self._normals_style: str = \"Axis RGB\"\n        # Default uniform color in [0..1]\n        self._normals_color: tuple[float, float, float] = (0.9, 0.9, 0.2)\n        # Percentage of normals to visualize (1..100)\n        self._normals_percent: int = 1\n        # Scale slider 1..200 \u2192 glyph_len = diag * (scale / 1000.0)\n        self._normals_scale: int = 20\n\n        # Rendering style &amp; datasets registry\n        self._points_as_spheres = getattr(self, \"_points_as_spheres\", False)  # user reported better perf with raw points\n        # Registry of datasets\n        self._datasets = getattr(self, \"_datasets\", [])  # list of dicts: {\"pdata\": pv.PolyData, \"actor_points\": vtkActor|None, \"actor_normals\": vtkActor|None, \"has_rgb\": bool}\n        # View-time LOD budget control\n        self._view_budget_percent: int = 100  # global percent applied to visible datasets\n        self._auto_budget_initialized: bool = False\n        # Per-dataset solid color support\n        self._default_palette = [\n            (0.90, 0.36, 0.36),  # red-ish\n            (0.39, 0.77, 0.36),  # green-ish\n            (0.36, 0.53, 0.90),  # blue-ish\n            (0.91, 0.72, 0.36),  # orange-ish\n            (0.58, 0.39, 0.77),  # purple-ish\n            (0.36, 0.77, 0.73),  # teal-ish\n        ]\n        # Fallback Solid (0\u20131) coerente con _solid_color (0\u2013255)\n        try:\n            self._solid_fallback = (\n                float(self._solid_color[0]) / 255.0,\n                float(self._solid_color[1]) / 255.0,\n                float(self._solid_color[2]) / 255.0,\n            )\n        except Exception:\n            self._solid_fallback = (0.78, 0.78, 0.78)\n\n        self.view_fit()\n\n    def _target_visible_points(self) -&gt; int:\n        \"\"\"Heuristic cap for total visible points based on platform/render style.\"\"\"\n        try:\n            import sys\n            if sys.platform == \"darwin\":\n                return 2_000_000 if not self._points_as_spheres else 600_000\n            return 4_000_000 if not self._points_as_spheres else 1_200_000\n        except Exception:\n            return 2_000_000\n\n    def _rebalance_budget_across_datasets(self) -&gt; None:\n        \"\"\"Adjust global percent so that total visible points stays under target cap.\"\"\"\n        try:\n            total_full = 0\n            for rec in self._datasets:\n                if not rec.get(\"visible\", True):\n                    continue\n                full = rec.get(\"full_pdata\", rec.get(\"pdata\"))\n                if hasattr(full, \"n_points\"):\n                    total_full += int(full.n_points)\n            if total_full &lt;= 0:\n                return\n            cap = self._target_visible_points()\n            p = min(100, max(1, int(cap * 100 / total_full)))\n            if p != self._view_budget_percent:\n                self._view_budget_percent = p\n        except Exception:\n            pass\n\n    # ---- Bounds helpers ----\n    def _visible_bounds(self):\n        \"\"\"Compute combined bounds (xmin,xmax,ymin,ymax,zmin,zmax) of visible datasets.\n\n        Returns:\n            tuple[float,float,float,float,float,float] | None\n        \"\"\"\n        try:\n            import numpy as np\n        except Exception:\n            np = None\n\n        xmin = ymin = zmin = float(\"inf\")\n        xmax = ymax = zmax = float(\"-inf\")\n        any_ok = False\n\n        for rec in self._datasets:\n            if not rec.get(\"visible\", True):\n                continue\n            b = None\n            kind = rec.get(\"kind\", \"points\")\n            try:\n                if kind == \"points\":\n                    pd = rec.get(\"full_pdata\", rec.get(\"pdata\"))\n                    if pd is not None and hasattr(pd, \"bounds\"):\n                        b = pd.bounds  # (xmin,xmax,ymin,ymax,zmin,zmax)\n                elif kind == \"mesh\":\n                    m = rec.get(\"mesh\")\n                    if m is not None and hasattr(m, \"bounds\"):\n                        b = m.bounds\n            except Exception:\n                b = None\n\n            if not b:\n                continue\n\n            try:\n                xmin = min(xmin, float(b[0])); xmax = max(xmax, float(b[1]))\n                ymin = min(ymin, float(b[2])); ymax = max(ymax, float(b[3]))\n                zmin = min(zmin, float(b[4])); zmax = max(zmax, float(b[5]))\n                any_ok = True\n            except Exception:\n                continue\n\n        if not any_ok:\n            return None\n\n        # Guard against degenerate extents (make them at least epsilon wide)\n        eps = 1e-9\n        if xmax &lt;= xmin: xmax = xmin + eps\n        if ymax &lt;= ymin: ymax = ymin + eps\n        if zmax &lt;= zmin: zmax = zmin + eps\n\n        return (xmin, xmax, ymin, ymax, zmin, zmax)\n\n    # ---- Camera helpers ----\n    def view_fit(self) -&gt; None:\n        \"\"\"Fit camera to the bounds of *visible* datasets only.\"\"\"\n        try:\n            b = self._visible_bounds()\n            if b is None:\n                # Fallback: nothing visible \u2192 default reset\n                try:\n                    self.plotter.reset_camera()\n                except Exception:\n                    pass\n                return\n\n            ren = getattr(self.plotter, \"renderer\", None)\n            if ren is not None and hasattr(ren, \"ResetCamera\"):\n                # ResetCamera(xmin,xmax,ymin,ymax,zmin,zmax)\n                ren.ResetCamera(b[0], b[1], b[2], b[3], b[4], b[5])\n                try:\n                    ren.ResetCameraClippingRange()\n                except Exception:\n                    pass\n            else:\n                # Fallback if renderer API is not available\n                self.plotter.reset_camera()\n\n            # Final render\n            try:\n                if hasattr(self.plotter, \"render\"):\n                    self.plotter.render()\n                else:\n                    self.plotter.update()\n            except Exception:\n                pass\n        except Exception:\n            # Never raise from a UI callback\n            pass\n\n    def view_axis(self, axis: str) -&gt; None:\n        \"\"\"Set camera to an orthographic axis view.\n\n        Args:\n            axis: One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".\n        \"\"\"\n        try:\n            if axis == \"+X\":\n                self.plotter.view_xz(negative=False)\n            elif axis == \"-X\":\n                self.plotter.view_xz(negative=True)\n            elif axis == \"+Y\":\n                self.plotter.view_yz(negative=False)\n            elif axis == \"-Y\":\n                self.plotter.view_yz(negative=True)\n            elif axis == \"+Z\":\n                self.plotter.view_xy(negative=False)\n            elif axis == \"-Z\":\n                self.plotter.view_xy(negative=True)\n            # self.plotter.reset_camera()\n        except Exception:\n            pass\n\n    def view_iso(self, positive: bool = True) -&gt; None:\n        \"\"\"Set an isometric camera preset.\n\n        Args:\n            positive: If True, use a ( +1, +1, +1 ) view direction; if False use a mirrored variant.\n        \"\"\"\n        try:\n            if positive:\n                # Keep PyVista's built-in for the \u201c+\u201d preset\n                self.plotter.view_isometric()\n                try:\n                    self.plotter.reset_camera_clipping_range()\n                except Exception:\n                    pass\n                # Render\n                try:\n                    self.plotter.render()\n                except Exception:\n                    pass\n            else:\n                # A mirrored isometric direction (you can change to (-1, +1, +1) if you prefer)\n                self._set_camera_iso(direction=(-1.0, -1.0, 1.0))\n        except Exception:\n            pass\n\n    def _scene_center_radius(self):\n        \"\"\"Return (center_xyz, diag_len) computed from visible bounds.\n\n        Falls back to plotter bounds if none are visible.\n        \"\"\"\n        try:\n            b = self._visible_bounds()\n            if b is None and hasattr(self.plotter, \"bounds\"):\n                b = self.plotter.bounds  # (xmin,xmax,ymin,ymax,zmin,zmax)\n            if not b:\n                return (0.0, 0.0, 0.0), 1.0\n            cx = 0.5 * (float(b[0]) + float(b[1]))\n            cy = 0.5 * (float(b[2]) + float(b[3]))\n            cz = 0.5 * (float(b[4]) + float(b[5]))\n            dx = float(b[1]) - float(b[0])\n            dy = float(b[3]) - float(b[2])\n            dz = float(b[5]) - float(b[4])\n            import math\n            diag = max(1e-9, math.sqrt(dx*dx + dy*dy + dz*dz))\n            return (cx, cy, cz), diag\n        except Exception:\n            return (0.0, 0.0, 0.0), 1.0\n\n    def _set_camera_iso(self, direction=(1.0, 1.0, 1.0)) -&gt; None:\n        \"\"\"Place camera along an isometric direction, scaled to scene size.\"\"\"\n        import math\n        # center &amp; size\n        ctr, diag = self._scene_center_radius()\n        cx, cy, cz = ctr\n\n        # normalize direction\n        dx, dy, dz = map(float, direction)\n        n = math.sqrt(dx*dx + dy*dy + dz*dz) or 1.0\n        dx, dy, dz = dx/n, dy/n, dz/n\n\n        # pick an 'up' that is not parallel to the view dir\n        up = (0.0, 0.0, 1.0)\n        dot = dx*up[0] + dy*up[1] + dz*up[2]\n        if abs(dot) &gt; 0.95:   # almost parallel \u2192 use Y-up\n            up = (0.0, 1.0, 0.0)\n\n        # distance factor: a bit larger than diagonal so everything fits\n        dist = 2.0 * diag\n\n        pos = (cx + dx*dist, cy + dy*dist, cz + dz*dist)\n        try:\n            self.plotter.camera_position = [pos, (cx, cy, cz), up]\n            # make sure clipping range adapts; avoid full reset_camera() to keep the pose\n            if hasattr(self.plotter, \"reset_camera_clipping_range\"):\n                self.plotter.reset_camera_clipping_range()\n        except Exception:\n            pass\n        try:\n            if hasattr(self.plotter, \"render\"):\n                self.plotter.render()\n            else:\n                self.plotter.update()\n        except Exception:\n            pass\n    def invert_view(self) -&gt; None:\n        \"\"\"Invert the camera position through the focal point.\"\"\"\n        try:\n            pos, foc, up = self.plotter.camera_position\n            inv = (2 * foc[0] - pos[0], 2 * foc[1] - pos[1], 2 * foc[2] - pos[2])\n            self.plotter.camera_position = [inv, foc, up]\n            self.plotter.reset_camera_clipping_range()\n        except Exception:\n            pass\n\n    def refresh(self) -&gt; None:\n        \"\"\"Request a render update (prefer immediate render if available).\"\"\"\n        try:\n            if hasattr(self.plotter, \"render\"):\n                self.plotter.render()\n            else:\n                self.plotter.update()\n        except Exception:\n            pass\n\n    # ---- Display controls ----\n    def set_mesh_representation(self, ds: int, mode: str) -&gt; None:\n        \"\"\"Set mesh representation for dataset *ds*.\n\n        Args:\n            ds: Dataset index in the internal cache.\n            mode: One of {'Points','Wireframe','Surface','Surface with Edges'}.\n        \"\"\"\n        recs = getattr(self, \"_datasets\", [])\n        if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n            return\n        rec = recs[ds]\n        pdata = rec.get(\"mesh_surface\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n        if pdata is None or self.plotter is None:\n            return\n\n        rec[\"representation\"] = mode\n\n        # Remove previous actor\n        try:\n            act = rec.get(\"actor\") or rec.get(\"actor_mesh\") or rec.get(\"actor_points\")\n            if act is not None:\n                self.plotter.remove_actor(act)\n        except Exception:\n            pass\n\n        scalars = rec.get(\"active_scalars\", None)\n        cmap = rec.get(\"colormap\", \"Viridis\")\n        clim = rec.get(\"clim\", None)\n        scalar_bar = bool(rec.get(\"scalar_bar\", False))\n\n        style = None\n        show_edges = False\n        if mode == \"Points\":\n            style = \"points\"\n        elif mode == \"Wireframe\":\n            style = \"wireframe\"\n        elif mode == \"Surface with Edges\":\n            show_edges = True\n\n        try:\n            actor = self.plotter.add_mesh(\n                pdata,\n                scalars=scalars,\n                cmap=cmap,\n                clim=clim,\n                style=style,\n                show_edges=show_edges or bool(rec.get(\"edge_visibility\", False)),\n                edge_color=tuple(rec.get(\"edge_color\", (0, 0, 0))),\n                opacity=float(rec.get(\"opacity\", 100)) / 100.0,\n                point_size=int(rec.get(\"point_size\", 3)),\n                line_width=int(rec.get(\"line_width\", 1)),\n                lighting=bool(rec.get(\"lighting\", True)),\n                name=rec.get(\"name\", f\"ds{ds}\"),\n                scalar_bar_args={\"title\": rec.get(\"active_scalar_name\", \"\")} if scalar_bar else None,\n                copy_mesh=False,\n                reset_camera=False,\n            )\n            rec[\"actor\"] = actor\n        except Exception:\n            return\n\n        # Solid color fallback (if no scalars)\n        if scalars is None:\n            try:\n                rgb = rec.get(\"solid_color\", (1.0, 1.0, 1.0))\n                if all(isinstance(c, int) for c in rgb):\n                    rgb = (rgb[0]/255.0, rgb[1]/255.0, rgb[2]/255.0)\n                actor.prop.color = (float(rgb[0]), float(rgb[1]), float(rgb[2]))\n            except Exception:\n                pass\n\n        try:\n            self.plotter.render()\n        except Exception:\n            pass\n\n    def set_dataset_color(self, ds: int, r: int, g: int, b: int) -&gt; None:\n        \"\"\"Apply solid RGB color to dataset *ds* and persist.\n\n        Args:\n            ds: Dataset index.\n            r, g, b: 0..255 components.\n        \"\"\"\n        recs = getattr(self, \"_datasets\", [])\n        if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n            return\n        rec = recs[ds]\n        rec[\"solid_color\"] = (int(r), int(g), int(b))\n        act = rec.get(\"actor\")\n        if act is not None:\n            try:\n                act.mapper.scalar_visibility = False  # force solid\n            except Exception:\n                pass\n            try:\n                act.prop.color = (r/255.0, g/255.0, b/255.0)\n            except Exception:\n                pass\n            try:\n                self.plotter.render()\n            except Exception:\n                pass\n\n    def set_colormap(self, name: str, ds: int) -&gt; None:\n        \"\"\"Set the colormap name for dataset *ds* and refresh scalar mapping.\"\"\"\n        recs = getattr(self, \"_datasets\", [])\n        if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n            return\n        rec = recs[ds]\n        rec[\"colormap\"] = str(name)\n        self._refresh_scalars(ds)\n\n    def set_color_mode(self, mode: str, ds: int) -&gt; None:\n        \"\"\"Set 'color mode' for dataset *ds*.\n\n        Supported modes:\n        - \"Solid Color\"\n        - \"PointData/&lt;ARRAY&gt;\"\n        - \"CellData/&lt;ARRAY&gt;\"  (TODO: mapping via vtkOriginalCellIds)\n        \"\"\"\n        recs = getattr(self, \"_datasets\", [])\n        if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n            return\n        rec = recs[ds]\n        rec[\"color_mode\"] = mode\n\n        # Solid \u21d2 disattiva scalars e aggiorna\n        if mode == \"Solid Color\":\n            rec[\"active_scalars\"] = None\n            rec[\"active_scalar_name\"] = \"\"\n            self._refresh_scalars(ds)\n            return\n\n        # Parse association/name\n        assoc = \"POINT\"\n        array_name = None\n        if mode.startswith(\"PointData/\"):\n            assoc = \"POINT\"\n            array_name = mode.split(\"/\", 1)[1]\n        elif mode.startswith(\"CellData/\"):\n            assoc = \"CELL\"\n            array_name = mode.split(\"/\", 1)[1]\n        else:\n            array_name = mode  # raw name, assume point\n\n        # Build scalars mapped to the render surface\n        scal = None\n        if assoc == \"POINT\" and array_name:\n            vmode = rec.get(\"vector_mode\", \"Magnitude\")\n            scal = self._map_point_scalars_to_surface_rec(rec, array_name, vmode)\n        else:\n            # TODO: support CellData via vtkOriginalCellIds and per-face averaging if needed\n            scal = None\n\n        if scal is None:\n            # fallback to solid\n            rec[\"active_scalars\"] = None\n            rec[\"active_scalar_name\"] = \"\"\n        else:\n            rec[\"active_scalars\"] = scal\n            rec[\"active_scalar_name\"] = array_name\n\n        self._refresh_scalars(ds)\n\n    def _map_point_scalars_to_surface_rec(self, rec: dict, name: str, vector_mode: str = \"Magnitude\"):\n        \"\"\"Return per-point scalars mapped to the render surface.\n\n        Priority:\n        1) rec['mesh_surface'].point_data['vtkOriginalPointIds'] \u2192 direct gather\n        2) KDTree( mesh.points ) \u2192 nearest-neighbor on surface.points\n        3) pass-through if sizes match\n        Handles vector arrays (Magnitude / X / Y / Z).\n        \"\"\"\n        try:\n            mesh = rec.get(\"mesh_orig\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n            surf = rec.get(\"mesh_surface\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n            if mesh is None or surf is None:\n                return None\n\n            # fetch from original mesh (or from surface if already there)\n            if hasattr(mesh, \"point_data\") and name in mesh.point_data:\n                base = np.asarray(mesh.point_data[name])\n            elif hasattr(surf, \"point_data\") and name in surf.point_data:\n                base = np.asarray(surf.point_data[name])\n            else:\n                return None\n\n            # vector handling\n            if base.ndim == 2 and base.shape[1] in (2, 3):\n                vm = (vector_mode or \"Magnitude\").title()\n                if vm == \"Magnitude\":\n                    base = np.linalg.norm(base, axis=1)\n                else:\n                    comp = {\"X\": 0, \"Y\": 1, \"Z\": 2}.get(vm, 0)\n                    comp = min(comp, base.shape[1] - 1)\n                    base = base[:, comp]\n\n            # 1) mapping via OriginalPointIds\n            ids = None\n            if hasattr(surf, \"point_data\"):\n                for key in (\"vtkOriginalPointIds\", \"vtkOriginalPointID\", \"origids\", \"OriginalPointIds\"):\n                    if key in surf.point_data:\n                        ids = np.asarray(surf.point_data[key]).astype(np.int64)\n                        break\n            if ids is not None:\n                ids = np.clip(ids, 0, base.shape[0] - 1)\n                return base[ids]\n\n            # 2) KDTree fallback\n            if KDTree is not None and hasattr(mesh, \"points\") and hasattr(surf, \"points\"):\n                P_src = np.asarray(mesh.points)\n                P_dst = np.asarray(surf.points)\n                if P_src.size and P_dst.size:\n                    tree = KDTree(P_src)\n                    idx = tree.query(P_dst, k=1, workers=-1)[1]\n                    idx = np.clip(np.asarray(idx, dtype=np.int64), 0, base.shape[0] - 1)\n                    return base[idx]\n\n            # 3) last resort: sizes equal \u2192 pass-through\n            return base if getattr(surf, \"n_points\", -1) == base.shape[0] else None\n        except Exception:\n            return None\n\n    def _refresh_scalars(self, ds: int) -&gt; None:\n        \"\"\"Internal: re-apply scalar mapping and LUT/CLIM/scalar bar to current actor.\"\"\"\n        recs = getattr(self, \"_datasets\", [])\n        if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n            return\n        rec = recs[ds]\n        act = rec.get(\"actor\")\n        if act is None or self.plotter is None:\n            # attempt to rebuild the actor via representation\n            rep = rec.get(\"representation\", \"Surface\")\n            self.set_mesh_representation(ds, rep)\n            act = rec.get(\"actor\")\n            if act is None:\n                return\n\n        scalars = rec.get(\"active_scalars\", None)\n        cmap = rec.get(\"colormap\", \"Viridis\")\n        clim = rec.get(\"clim\", None)\n        sbar = bool(rec.get(\"scalar_bar\", False))\n\n        try:\n            if scalars is None:\n                act.mapper.scalar_visibility = False\n                # Apply solid color when scalar visibility is disabled\n                try:\n                    rgb = rec.get(\"solid_color\", (1.0, 1.0, 1.0))\n                    if all(isinstance(c, int) for c in rgb):\n                        rgb = (rgb[0]/255.0, rgb[1]/255.0, rgb[2]/255.0)\n                    act.prop.color = (float(rgb[0]), float(rgb[1]), float(rgb[2]))\n                except Exception:\n                    pass\n            else:\n                pdata = rec.get(\"mesh_surface\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n                try:\n                    self.plotter.remove_actor(act)\n                except Exception:\n                    pass\n                act = self.plotter.add_mesh(\n                    pdata,\n                    scalars=scalars,\n                    cmap=cmap,\n                    clim=clim,\n                    style=None if rec.get(\"representation\", \"Surface\") != \"Wireframe\" else \"wireframe\",\n                    show_edges=(rec.get(\"representation\", \"Surface\") == \"Surface with Edges\") or bool(rec.get(\"edge_visibility\", False)),\n                    edge_color=tuple(rec.get(\"edge_color\", (0, 0, 0))),\n                    opacity=float(rec.get(\"opacity\", 100)) / 100.0,\n                    point_size=int(rec.get(\"point_size\", 3)),\n                    line_width=int(rec.get(\"line_width\", 1)),\n                    lighting=bool(rec.get(\"lighting\", True)),\n                    name=rec.get(\"name\", f\"ds{ds}\"),\n                    scalar_bar_args={\"title\": rec.get(\"active_scalar_name\", \"\")} if sbar else None,\n                    copy_mesh=False,\n                    reset_camera=False,\n                )\n                rec[\"actor\"] = act\n                if not sbar:\n                    try:\n                        self.plotter.remove_scalar_bar()\n                    except Exception:\n                        pass\n        except Exception:\n            pass\n\n        try:\n            self.plotter.render()\n        except Exception:\n            pass\n\n    def set_point_size(self, size: int, dataset_index: int | None = None) -&gt; None:\n        \"\"\"Set point size globally or for a specific dataset.\"\"\"\n        try:\n            sz = int(size)\n        except Exception:\n            return\n        if dataset_index is None:\n            self._point_size = sz\n            for idx, rec in enumerate(self._datasets):\n                if rec.get(\"kind\") != \"points\":\n                    continue\n                rec[\"point_size\"] = sz\n                actor = rec.get(\"actor_points\")\n                if actor is not None:\n                    try:\n                        prop = actor.GetProperty()\n                        if prop:\n                            prop.SetPointSize(sz)\n                    except Exception:\n                        pass\n            try:\n                self.plotter.update()\n            except Exception:\n                pass\n            return\n\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n        if rec.get(\"kind\") != \"points\":\n            return\n        rec[\"point_size\"] = sz\n        actor = rec.get(\"actor_points\")\n        if actor is not None:\n            try:\n                prop = actor.GetProperty()\n                if prop:\n                    prop.SetPointSize(sz)\n                self.plotter.update()\n            except Exception:\n                pass\n\n    # def set_color_mode(self, mode: str, dataset_index: int | None = None) -&gt; None:\n    #     \"\"\"Set color mode globally or for a specific point dataset.\"\"\"\n    #     if dataset_index is None:\n    #         self._color_mode = mode\n    #         for idx, rec in enumerate(self._datasets):\n    #             if rec.get(\"kind\") == \"points\":\n    #                 self.set_color_mode(mode, idx)\n    #         return\n    #     try:\n    #         rec = self._datasets[dataset_index]\n    #     except Exception:\n    #         return\n    #     if rec.get(\"kind\") != \"points\":\n    #         return\n    #     rec[\"color_mode\"] = mode\n    #     actor = rec.get(\"actor_points\")\n    #     if actor is not None:\n    #         try:\n    #             self.plotter.remove_actor(actor)\n    #         except Exception:\n    #             pass\n    #         rec[\"actor_points\"] = None\n    #     if rec.get(\"visible\", True):\n    #         rec[\"actor_points\"] = self._add_points_by_mode(\n    #             rec.get(\"pdata\"),\n    #             rec.get(\"has_rgb\", False),\n    #             rec.get(\"solid_color\", self._solid_fallback),\n    #             mode,\n    #             rec.get(\"cmap\", self._cmap),\n    #             rec.get(\"points_as_spheres\", self._points_as_spheres),\n    #         )\n    #         actor = rec.get(\"actor_points\")\n    #         if actor is not None:\n    #             try:\n    #                 prop = actor.GetProperty()\n    #                 if prop:\n    #                     prop.SetPointSize(rec.get(\"point_size\", self._point_size))\n    #             except Exception:\n    #                 pass\n    #     # Auto-show a managed scalar bar when switching to colormap mode\n    #     try:\n    #         if mode == \"Normal Colormap\":\n    #             title = str(rec.get(\"scalar_name\", \"Intensity\"))\n    #             current = str(getattr(self, \"_scalarbar_mode\", \"horizontal-br\"))\n    #             if current == \"hidden\":\n    #                 current = \"vertical-tr\"  # default sensato\n    #             self.set_colorbar_mode(current, title)\n    #     except Exception:\n    #         pass\n    #     try:\n    #         self._apply_scalarbar()\n    #     except Exception:\n    #         pass\n    #     try:\n    #         self.plotter.update()\n    #     except Exception:\n    #         pass\n\n    def set_solid_color(self, r: int, g: int, b: int) -&gt; None:\n        \"\"\"Set a solid RGB color on all actors (best-effort).\"\"\"\n        self._solid_color = (r, g, b)\n        self._refresh_datasets()\n\n    # def set_colormap(self, name: str, dataset_index: int | None = None) -&gt; None:\n    #     \"\"\"Set colormap globally or for a specific dataset when in colormap mode.\"\"\"\n    #     if dataset_index is None:\n    #         self._cmap = name\n    #         for idx, rec in enumerate(self._datasets):\n    #             if rec.get(\"kind\") == \"points\":\n    #                 self.set_colormap(name, idx)\n    #         return\n    #     try:\n    #         rec = self._datasets[dataset_index]\n    #     except Exception:\n    #         return\n    #     if rec.get(\"kind\") != \"points\":\n    #         return\n    #     rec[\"cmap\"] = name\n    #     if rec.get(\"color_mode\", self._color_mode) != \"Normal Colormap\" and rec.get(\"has_rgb\", False):\n    #         return\n    #     actor = rec.get(\"actor_points\")\n    #     if actor is not None:\n    #         try:\n    #             self.plotter.remove_actor(actor)\n    #         except Exception:\n    #             pass\n    #     rec[\"actor_points\"] = None\n    #     if rec.get(\"visible\", True):\n    #         rec[\"actor_points\"] = self._add_points_by_mode(\n    #             rec.get(\"pdata\"),\n    #             rec.get(\"has_rgb\", False),\n    #             rec.get(\"solid_color\", self._solid_fallback),\n    #             rec.get(\"color_mode\", self._color_mode),\n    #             name,\n    #             rec.get(\"points_as_spheres\", self._points_as_spheres),\n    #         )\n    #         actor = rec.get(\"actor_points\")\n    #         if actor is not None:\n    #             try:\n    #                 prop = actor.GetProperty()\n    #                 if prop:\n    #                     prop.SetPointSize(rec.get(\"point_size\", self._point_size))\n    #             except Exception:\n    #                 pass\n    #     # Ensure the scalar bar is shown with the correct title in colormap mode\n    #     try:\n    #         if rec.get(\"color_mode\", self._color_mode) == \"Normal Colormap\":\n    #             title = str(rec.get(\"scalar_name\", \"Intensity\"))\n    #             current = str(getattr(self, \"_scalarbar_mode\", \"horizontal-br\"))\n    #             if current == \"hidden\":\n    #                 current = \"vertical-tr\"\n    #             self.set_colorbar_mode(current, title)\n    #     except Exception:\n    #         pass\n    #     try:\n    #         self._apply_scalarbar()\n    #     except Exception:\n    #         pass\n    #     try:\n    #         self.plotter.update()\n    #     except Exception:\n    #         pass\n\n    # def set_dataset_color(self, dataset_index: int, r: int, g: int, b: int) -&gt; None:\n    #     \"\"\"Set per-dataset solid color and update its actor if needed.\n\n    #     Works for both point clouds and meshes. For points, if the dataset's\n    #     current color mode is Solid, the actor color is updated directly;\n    #     otherwise the actor is rebuilt only when needed.\n    #     \"\"\"\n    #     try:\n    #         rec = self._datasets[dataset_index]\n    #     except Exception:\n    #         return\n\n    #     # Clamp and normalize to 0..1\n    #     rgb = (\n    #         max(0, min(255, int(r))) / 255.0,\n    #         max(0, min(255, int(g))) / 255.0,\n    #         max(0, min(255, int(b))) / 255.0,\n    #     )\n    #     rec[\"solid_color\"] = rgb\n\n    #     # Mesh datasets: update actor property if present\n    #     if rec.get(\"kind\") == \"mesh\":\n    #         actor_m = rec.get(\"actor_mesh\")\n    #         if actor_m is not None:\n    #             try:\n    #                 actor_m.GetProperty().SetColor(rgb)\n    #                 self.plotter.update()\n    #             except Exception:\n    #                 pass\n    #         return\n\n    #     # Point datasets\n    #     if rec.get(\"kind\") != \"points\":\n    #         return\n\n    #     mode = str(rec.get(\"color_mode\", self._color_mode))\n    #     actor = rec.get(\"actor_points\")\n\n    #     # If currently in Solid mode and an actor exists, update in-place\n    #     if actor is not None and mode == \"Solid\":\n    #         try:\n    #             actor.GetProperty().SetColor(rgb)\n    #             self.plotter.update()\n    #             return\n    #         except Exception:\n    #             pass\n\n    #     # Otherwise, rebuild only if visible (to reflect future switch to Solid)\n    #     if actor is not None:\n    #         try:\n    #             self.plotter.remove_actor(actor)\n    #         except Exception:\n    #             pass\n    #         rec[\"actor_points\"] = None\n\n    #     if rec.get(\"visible\", True):\n    #         new_actor = self._add_points_by_mode(\n    #             rec.get(\"pdata\"),\n    #             rec.get(\"has_rgb\", False),\n    #             rec.get(\"solid_color\", self._solid_fallback),\n    #             rec.get(\"color_mode\", self._color_mode),\n    #             rec.get(\"cmap\", self._cmap),\n    #             rec.get(\"points_as_spheres\", self._points_as_spheres),\n    #         )\n    #         if new_actor is not None:\n    #             try:\n    #                 prop = new_actor.GetProperty()\n    #                 if prop:\n    #                     prop.SetPointSize(rec.get(\"point_size\", self._point_size))\n    #             except Exception:\n    #                 pass\n    #         rec[\"actor_points\"] = new_actor\n    #         try:\n    #             self.plotter.update()\n    #         except Exception:\n    #             pass\n\n    def set_points_as_spheres(self, enabled: bool) -&gt; None:\n        \"\"\"Toggle rendering style for points and refresh existing actors.\"\"\"\n        self._points_as_spheres = bool(enabled)\n        self._refresh_datasets()\n\n\n    def add_points(self, points, colors=None, normals=None) -&gt; int:\n        \"\"\"Add a point cloud to the scene with smart coloring and optional normals.\n\n        Args:\n            points: array-like (N,3)\n            colors: optional (N,3) in [0,1] or [0,255]\n            normals: optional (N,3) float array of unit vectors\n\n        Returns:\n            Integer dataset index that can be used to toggle/augment visuals later.\n        \"\"\"\n        try:\n            import numpy as np\n            import pyvista as pv  # type: ignore\n\n            pts = np.asarray(points, dtype=float)\n            pdata = pv.PolyData(pts)\n\n            has_rgb = False\n            if colors is not None:\n                cols = np.asarray(colors)\n                if cols.max() &gt; 1.5:\n                    cols = cols / 255.0\n                pdata[\"RGB\"] = (cols * 255).astype(np.uint8)\n                has_rgb = True\n\n            if normals is not None:\n                nrm = np.asarray(normals, dtype=float)\n                if nrm.ndim == 2 and nrm.shape[1] &gt;= 3 and nrm.shape[0] == pts.shape[0]:\n                    pdata[\"Normals\"] = nrm[:, :3].astype(np.float32)\n\n            # fake intensity per colormap fallback\n            if pts.size:\n                z = pts[:, 2]\n                zmin, zmax = float(z.min()), float(z.max())\n                inten = (z - zmin) / (zmax - zmin) if zmax &gt; zmin else np.zeros_like(z)\n                pdata[\"Intensity\"] = inten.astype(np.float32)\n\n            # Auto-initialize or rebalance the view budget\n            if not self._auto_budget_initialized:\n                cap = self._target_visible_points()\n                n = int(pts.shape[0])\n                p = min(100, max(1, int(cap * 100 / max(1, n))))\n                self._view_budget_percent = p\n                self._auto_budget_initialized = True\n            else:\n                self._rebalance_budget_across_datasets()\n\n            full_pdata = pdata\n            pdata_for_view = self._apply_budget_to_polydata(full_pdata, has_rgb, self._view_budget_percent)\n            # Scegli un colore distinto dalla palette per questo dataset\n            palette = getattr(self, \"_default_palette\", [self._solid_fallback])\n            ds_color = palette[len(self._datasets) % len(palette)] if palette else self._solid_fallback\n            actor_points = self._add_points_by_mode(\n                pdata_for_view,\n                has_rgb,\n                ds_color,\n                self._color_mode,\n                self._cmap,\n                self._points_as_spheres,\n            )\n            # Ensure the new actor uses the current point size\n            try:\n                if actor_points is not None:\n                    prop = actor_points.GetProperty()\n                    if prop:\n                        prop.SetPointSize(self._point_size)\n            except Exception:\n                pass\n\n            rec = {\n                \"kind\": \"points\",\n                \"full_pdata\": full_pdata,\n                \"pdata\": pdata_for_view,\n                \"actor_points\": actor_points,\n                \"actor_normals\": None,\n                \"has_rgb\": has_rgb,\n                \"solid_color\": ds_color,\n                \"visible\": True,\n                \"point_size\": self._point_size,\n                \"view_percent\": self._view_budget_percent,\n                \"color_mode\": self._color_mode,\n                \"cmap\": self._cmap,\n                \"points_as_spheres\": self._points_as_spheres,\n                # ---- per-dataset normals state ----\n                \"normals_visible\": False,\n                \"normals_style\": self._normals_style,\n                \"normals_color\": self._normals_color,\n                \"normals_percent\": self._normals_percent,\n                \"normals_scale\": self._normals_scale,\n                \"scalar_name\": \"Intensity\",\n            }\n            self._datasets.append(rec)\n            ds_index = len(self._datasets) - 1\n\n            self.plotter.reset_camera()\n            try:\n                self._apply_overlays()\n            except Exception:\n                pass\n            return ds_index\n        except Exception:\n            return -1\n\n\n    def _add_points_by_mode(self, pdata, has_rgb: bool, solid_color=None, mode=None, cmap=None, spheres=None):\n        \"\"\"Internal helper to add points according to current mode and style.\n\n        Args:\n            pdata: PolyData con eventuali array 'RGB'/'Intensity'.\n            has_rgb: True se 'RGB' \u00e8 presente.\n            solid_color: opzionale (r,g,b) in [0,1] da usare in Solid.\n            mode: rendering mode (Solid, Normal RGB, Normal Colormap).\n            cmap: colormap name when in colormap mode.\n            spheres: render points as spheres if True.\n        \"\"\"\n        mode = self._color_mode if mode is None else mode\n        cmap = self._cmap if cmap is None else cmap\n        spheres = self._points_as_spheres if spheres is None else spheres\n\n        # Colore Solid risolto (per-dataset o fallback globale)\n        solid = solid_color if solid_color is not None else self._solid_fallback\n\n        # Modalit\u00e0 Solid\n        if mode == \"Solid\":\n            try:\n                return self.plotter.add_points(\n                    pdata,\n                    color=solid,\n                    render_points_as_spheres=spheres,\n                    show_scalar_bar=False,\n                )\n            except Exception:\n                pass\n\n        # Colormap (o fallback se manca RGB)\n        if mode == \"Normal Colormap\" or not has_rgb:\n            try:\n                return self.plotter.add_points(\n                    pdata,\n                    scalars=\"Intensity\",\n                    cmap=cmap,\n                    render_points_as_spheres=spheres,\n                    show_scalar_bar=False,\n                )\n            except Exception:\n                pass\n\n        # Default: RGB reale\n        try:\n            return self.plotter.add_points(\n                pdata,\n                scalars=\"RGB\",\n                rgb=True,\n                render_points_as_spheres=spheres,\n                show_scalar_bar=False,\n            )\n        except Exception:\n            # Fallback finale: Solid\n            try:\n                return self.plotter.add_points(\n                    pdata,\n                    color=solid,\n                    render_points_as_spheres=spheres,\n                    show_scalar_bar=False,\n                )\n            except Exception:\n                return None\n\n    def _refresh_datasets(self) -&gt; None:\n        \"\"\"Rebuild all actors according to current rendering settings.\n\n        Preserves:\n        - camera position/clip range,\n        - point-size on point actors,\n        - per-dataset normals state (visibility, style, color, percent, scale).\n        \"\"\"\n        try:\n            # Save camera\n            try:\n                cam_pos = self.plotter.camera_position\n            except Exception:\n                cam_pos = None\n\n            # Clear scene and rebuild dataset list\n            self.plotter.clear()\n            # After a clear() we must re-apply axes/grid overlays\n            try:\n                self._apply_overlays()\n            except Exception:\n                pass\n            try:\n                self._apply_background()\n                self._apply_scalarbar()\n            except Exception:\n                pass\n            new_list: list[dict] = []\n\n            for old_rec in self._datasets:\n                kind = old_rec.get(\"kind\", \"points\")\n\n                # ---------- Mesh datasets ----------\n                if kind == \"mesh\":\n                    actor_mesh = None\n                    if old_rec.get(\"visible\", True):\n                        try:\n                            actor_mesh = self._add_mesh_no_bar(\n                                old_rec.get(\"mesh\"),\n                                color=old_rec.get(\"solid_color\", self._solid_fallback),\n                                style=\"wireframe\"\n                                if old_rec.get(\"representation\", \"surface\") == \"wireframe\"\n                                else \"surface\",\n                                opacity=float(old_rec.get(\"opacity\", 100)) / 100.0,\n                            )\n                        except Exception:\n                            actor_mesh = None\n\n                    new_rec = dict(old_rec)\n                    new_rec[\"actor_mesh\"] = actor_mesh\n                    new_list.append(new_rec)\n                    continue\n\n                # ---------- Point datasets ----------\n                full_pdata = old_rec.get(\"full_pdata\", old_rec.get(\"pdata\"))\n                has_rgb = bool(old_rec.get(\"has_rgb\", False))\n                was_visible = bool(old_rec.get(\"visible\", True))\n                view_pct = int(old_rec.get(\"view_percent\", 100))\n\n                # Apply view budget\n                pdata_for_view = self._apply_budget_to_polydata(\n                    full_pdata, has_rgb, view_pct\n                )\n\n                # Re-add points actor according to color mode/cmap\n                actor_points = None\n                if was_visible:\n                    actor_points = self._add_points_by_mode(\n                        pdata_for_view,\n                        has_rgb,\n                        old_rec.get(\"solid_color\", self._solid_fallback),\n                        old_rec.get(\"color_mode\", self._color_mode),\n                        old_rec.get(\"cmap\", self._cmap),\n                        old_rec.get(\"points_as_spheres\", self._points_as_spheres),\n                    )\n                    # Re-apply point size\n                    try:\n                        if actor_points is not None:\n                            prop = actor_points.GetProperty()\n                            if prop:\n                                prop.SetPointSize(old_rec.get(\"point_size\", self._point_size))\n                    except Exception:\n                        pass\n\n                # Base new record\n                new_rec = {\n                    \"kind\": \"points\",\n                    \"full_pdata\": full_pdata,\n                    \"pdata\": pdata_for_view,\n                    \"actor_points\": actor_points,\n                    \"actor_normals\": None,  # will be rebuilt below if needed\n                    \"has_rgb\": has_rgb,\n                    \"solid_color\": old_rec.get(\"solid_color\", self._solid_fallback),\n                    \"visible\": was_visible,\n                    \"point_size\": old_rec.get(\"point_size\", self._point_size),\n                    \"view_percent\": view_pct,\n                    \"color_mode\": old_rec.get(\"color_mode\", self._color_mode),\n                    \"cmap\": old_rec.get(\"cmap\", self._cmap),\n                    \"points_as_spheres\": old_rec.get(\n                        \"points_as_spheres\", self._points_as_spheres\n                    ),\n                    # ---- Normals per-dataset state (carry over with sane defaults) ----\n                    \"normals_visible\": bool(old_rec.get(\"normals_visible\", False)),\n                    \"normals_style\": str(old_rec.get(\"normals_style\", getattr(self, \"_normals_style\", \"Axis RGB\"))),\n                    \"normals_color\": tuple(old_rec.get(\"normals_color\", getattr(self, \"_normals_color\", (0.9, 0.9, 0.2)))),\n                    \"normals_percent\": int(old_rec.get(\"normals_percent\", getattr(self, \"_normals_percent\", 50))),\n                    \"normals_scale\": int(old_rec.get(\"normals_scale\", getattr(self, \"_normals_scale\", 20))),\n                }\n                new_list.append(new_rec)\n\n                # ---- Rebuild normals actor if it was visible ----\n                try:\n                    if new_rec[\"normals_visible\"] and hasattr(pdata_for_view, \"point_data\") and \"Normals\" in pdata_for_view.point_data:\n                        self._rebuild_normals_actor(\n                            ds=len(new_list) - 1, # here it was data_index\n                            style=new_rec[\"normals_style\"],\n                            color=new_rec[\"normals_color\"],\n                            percent=new_rec[\"normals_percent\"],\n                            scale=new_rec[\"normals_scale\"],\n                        )\n                except Exception:\n                    # Best-effort: keep going even if normals rebuild fails\n                    pass\n\n            # Swap registry\n            self._datasets = new_list\n\n            # Ensure point-size is applied to all point actors (paranoia pass)\n            try:\n                for rec in self._datasets:\n                    if rec.get(\"kind\") != \"points\":\n                        continue\n                    actor = rec.get(\"actor_points\")\n                    if actor is not None:\n                        prop = actor.GetProperty()\n                        if prop:\n                            prop.SetPointSize(rec.get(\"point_size\", self._point_size))\n            except Exception:\n                pass\n\n            # Restore camera\n            if cam_pos is not None:\n                try:\n                    self.plotter.camera_position = cam_pos\n                    self.plotter.reset_camera_clipping_range()\n                except Exception:\n                    pass\n\n            # Final refresh\n            try:\n                self.plotter.update()\n            except Exception:\n                pass\n\n        except Exception:\n            # Never raise from a refresh; keep UI responsive.\n            pass\n\n    def add_pyvista_mesh(self, mesh) -&gt; int:\n        \"\"\"Add a VTK/PyVista mesh to the scene with a guaranteed surface actor.\n\n        Stores both:\n        - rec['mesh_orig']    : the original dataset (e.g. UnstructuredGrid)\n        - rec['mesh_surface'] : a PolyData surface extracted for rendering\n\n        All visual representations use the surface, so scalars and edges behave.\n        \"\"\"\n        try:\n            render_mesh = _ensure_surface_mesh(mesh)\n            actor = self._add_mesh_no_bar(render_mesh)\n            rec = {\n                \"kind\": \"mesh\",\n                \"mesh_orig\": mesh,\n                \"mesh_surface\": render_mesh,\n                \"actor\": actor,\n                \"visible\": True,\n                \"representation\": \"Surface\",\n                \"opacity\": 100,\n                \"solid_color\": (1.0, 1.0, 1.0),\n                \"active_scalars\": None,\n                \"active_scalar_name\": \"\",\n                \"colormap\": \"Viridis\",\n                \"clim\": None,\n                \"scalar_bar\": False,\n                \"edge_visibility\": False,\n                \"edge_color\": (0, 0, 0),\n                \"point_size\": 3,\n                \"line_width\": 1,\n                \"lighting\": True,\n            }\n            self._datasets.append(rec)\n            try:\n                self.plotter.reset_camera()\n            except Exception:\n                pass\n            return len(self._datasets) - 1\n        except Exception:\n            return -1\n\n    def clear(self) -&gt; None:\n        \"\"\"Remove all actors from the scene.\"\"\"\n        try:\n            self.plotter.clear()\n        except Exception:\n            pass\n\n    def enable_safe_rendering(self, enabled: bool = True) -&gt; None:\n        \"\"\"Toggle conservative rendering settings (useful on macOS/Metal).\n\n        Args:\n            enabled: If True, apply safe settings; if False, attempt to restore defaults.\n        \"\"\"\n        try:\n            if not hasattr(self.plotter, \"render_window\"):\n                return\n            if enabled:\n                self.plotter.render_window.SetMultiSamples(0)\n                try:\n                    self.plotter.renderer.SetUseDepthPeeling(0)\n                    if hasattr(self.plotter.renderer, \"SetUseFXAA\"):\n                        self.plotter.renderer.SetUseFXAA(False)\n                except Exception:\n                    pass\n            else:\n                # Best-effort revert\n                try:\n                    self.plotter.render_window.SetMultiSamples(4)\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n    def _apply_background(self) -&gt; None:\n        \"\"\"Apply the current background RGB to the plotter (best-effort).\"\"\"\n        try:\n            r, g, b = getattr(self, \"_bg_rgb\", (255, 255, 255))\n            if hasattr(self.plotter, \"set_background\"):\n                self.plotter.set_background((int(r), int(g), int(b)))\n        except Exception:\n            pass\n\n    def _infer_scalarbar_title(self) -&gt; str:\n        \"\"\"Return a sensible scalar bar title based on visible datasets.\n\n        Prefers the first visible point dataset in 'Normal Colormap' mode and\n        uses its recorded scalar name; defaults to 'Intensity'.\n        \"\"\"\n        try:\n            for rec in self._datasets:\n                if rec.get(\"kind\") == \"points\" and rec.get(\"visible\", True):\n                    if rec.get(\"color_mode\", self._color_mode) == \"Normal Colormap\":\n                        return str(rec.get(\"scalar_name\", \"Intensity\"))\n        except Exception:\n            pass\n        return \"Intensity\"\n\n    def _apply_scalarbar(self) -&gt; None:\n        \"\"\"Apply current scalar bar mode/title to the plotter (removes existing first).\"\"\"\n        try:\n            mode = getattr(self, \"_scalarbar_mode\", \"horizontal-br\")\n            _title = getattr(self, \"_scalarbar_title\", \"\")\n            if not _title:\n                _title = self._infer_scalarbar_title()\n            title = _title\n            if hasattr(self.plotter, \"remove_scalar_bar\"):\n                try:\n                    self.plotter.remove_scalar_bar()\n                except Exception:\n                    pass\n            if mode == \"hidden\":\n                return\n            if mode == \"vertical-tr\":\n                opts = dict(\n                    vertical=True,\n                    position_x=0.85,\n                    position_y=0.1,\n                    height=0.8,\n                    width=0.1,\n                    title=title,\n                    fmt=\"%0.3f\",\n                )\n            else:  # horizontal-br default\n                opts = dict(\n                    vertical=False,\n                    position_x=0.62,\n                    position_y=0.02,\n                    height=0.12,\n                    width=0.36,\n                    title=title,\n                    fmt=\"%0.3f\",\n                )\n            try:\n                self.plotter.add_scalar_bar(**opts)\n            except Exception:\n                pass\n        except Exception:\n            pass\n\n    def set_background_color(self, color) -&gt; None:\n        \"\"\"Set the plotter background color.\n\n        Args:\n            color: `QtGui.QColor` or an (r,g,b) tuple in 0..255 or 0..1 floats.\n        \"\"\"\n        try:\n            r = g = b = None\n            try:\n                from PySide6 import QtGui as _QtGui  # local import\n            except Exception:\n                _QtGui = None\n            if _QtGui is not None and isinstance(color, _QtGui.QColor):\n                r, g, b = color.red(), color.green(), color.blue()\n            else:\n                r, g, b = color\n                if all(isinstance(c, float) and 0.0 &lt;= c &lt;= 1.0 for c in (r, g, b)):\n                    r, g, b = int(round(r * 255)), int(round(g * 255)), int(round(b * 255))\n            self._bg_rgb = (int(r), int(g), int(b))\n            self._apply_background()\n            self.refresh()\n        except Exception:\n            pass\n\n    def set_colorbar_mode(self, mode: str = \"horizontal-br\", title: str = \"\") -&gt; None:\n        \"\"\"Set scalar bar layout and apply it immediately.\n\n        Supported modes:\n            - 'hidden'         : remove scalar bar\n            - 'horizontal-br'  : bottom-right horizontal bar\n            - 'vertical-tr'    : top-right vertical bar\n        \"\"\"\n        try:\n            mode = str(mode).strip().lower()\n            if mode not in (\"hidden\", \"horizontal-br\", \"vertical-tr\"):\n                mode = \"horizontal-br\"\n            self._scalarbar_mode = mode\n            self._scalarbar_title = str(title)\n            self._apply_scalarbar()\n            self.refresh()\n        except Exception:\n            pass\n\n    def _add_mesh_no_bar(self, *args, **kwargs):\n        \"\"\"Wrapper around plotter.add_mesh that guarantees no auto scalar bar is shown.\n\n        Forces show_scalar_bar=False so that colorbar placement is managed exclusively\n        by `_apply_scalarbar()` / `set_colorbar_mode()`.\n        \"\"\"\n        try:\n            kwargs = dict(kwargs)\n            kwargs[\"show_scalar_bar\"] = False\n            return self.plotter.add_mesh(*args, **kwargs)\n        except Exception:\n            try:\n                return self.plotter.add_mesh(*args)\n            except Exception:\n                return None\n\n    # ---- Overlays (axes + bounds grid) ---------------------------------\n    def _apply_overlays(self) -&gt; None:\n        \"\"\"(Re)apply overlays (axes, bounds grid) based on current flags.\"\"\"\n        try:\n            # Remove previous bounds axes if the backend keeps them around\n            if hasattr(self.plotter, \"remove_bounds_axes\"):\n                try:\n                    self.plotter.remove_bounds_axes()\n                except Exception:\n                    pass\n\n            if self._axes_on:\n                try:\n                    self.plotter.add_axes()\n                except Exception:\n                    pass\n            if self._bounds_on:\n                try:\n                    self.plotter.show_bounds(**self._bounds_kwargs)\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n    def set_colorbar_vertical(self, enabled: bool = True, title: str = \"\") -&gt; None:\n        \"\"\"Show or hide a vertical colorbar at top-right of the scene.\n\n        Args:\n            enabled: If True, display the colorbar; if False, remove it.\n            title: Optional label for the scalar bar.\n        \"\"\"\n        try:\n            if not enabled:\n                if hasattr(self.plotter, \"remove_scalar_bar\"):\n                    try:\n                        self.plotter.remove_scalar_bar()\n                    except Exception:\n                        pass\n                return\n\n            opts = dict(\n                vertical=True,\n                position_x=0.85,  # right margin\n                position_y=0.1,   # start a bit below the top\n                height=0.8,\n                width=0.1,\n                title=title,\n                fmt=\"%0.3f\",\n            )\n            try:\n                self.plotter.add_scalar_bar(**opts)\n            except Exception:\n                pass\n        except Exception:\n            pass\n\n    def set_axes_enabled(self, enabled: bool) -&gt; None:\n        \"\"\"Public toggle for axes overlay.\"\"\"\n        self._axes_on = bool(enabled)\n        try:\n            self._apply_overlays()\n            self.refresh()\n        except Exception:\n            pass\n\n    def set_grid_enabled(self, enabled: bool, **kwargs) -&gt; None:\n        \"\"\"Public toggle for bounds grid overlay.\n\n        You may pass additional kwargs forwarded to plotter.show_bounds(),\n        e.g., grid='front', location='outer', color='black', etc.\n        \"\"\"\n        self._bounds_on = bool(enabled)\n        if kwargs:\n            self._bounds_kwargs.update(kwargs)\n        try:\n            self._apply_overlays()\n            self.refresh()\n        except Exception:\n            pass\n\n    def apply_normals_properties(\n        self,\n        ds: int,\n        *,\n        style: str | None = None,\n        color: tuple[float, float, float] | None = None,\n        percent: int | None = None,\n        scale: int | None = None,\n        ensure_visible: bool = True,\n    ) -&gt; None:\n        \"\"\"Update per-dataset normals properties and optionally rebuild glyphs.\n\n        Args:\n            ds: Dataset index.\n            style: 'Uniform' | 'Axis RGB' | 'RGB Components'.\n            color: Uniform RGB (0..1 floats).\n            percent: 1..100 fraction of glyphs shown.\n            scale: 1..200 glyph magnitude slider value.\n            ensure_visible: If True, shows/rebuilds normals actor immediately.\n        \"\"\"\n        try:\n            rec = self._datasets[ds]\n        except Exception:\n            return\n\n        if style is not None:\n            rec[\"normals_style\"] = str(style)\n        if color is not None:\n            try:\n                r, g, b = color\n                rec[\"normals_color\"] = (float(r), float(g), float(b))\n            except Exception:\n                pass\n        if percent is not None:\n            rec[\"normals_percent\"] = int(max(1, min(100, int(percent))))\n        if scale is not None:\n            rec[\"normals_scale\"] = int(max(1, min(200, int(scale))))\n\n        if ensure_visible:\n            # This will rebuild the actor with the latest properties\n            self.set_normals_visibility(ds, True)\n        elif rec.get(\"normals_visible\"):\n            # Rebuild without toggling visibility\n            self._rebuild_normals_actor(\n                ds,\n                style=str(rec.get(\"normals_style\", self._normals_style)),\n                color=tuple(rec.get(\"normals_color\", self._normals_color)),\n                percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n                scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n            )\n\n    def set_normals_visibility(self, dataset_index: int, visible: bool, scale: float | None = None) -&gt; None:\n        \"\"\"Show/hide normals glyphs for a given dataset.\n\n        This keeps per-dataset state and rebuilds the glyph actor as needed.\n\n        Args:\n            dataset_index: Target dataset index.\n            visible: True to show normals, False to hide them.\n            scale: Optional legacy float override (kept for backward compat).\n                   If provided, it is mapped to the new integer slider domain (1..200).\n        \"\"\"\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n\n        # Hide path\n        if not visible:\n            try:\n                if rec.get(\"actor_normals\") is not None:\n                    self.plotter.remove_actor(rec[\"actor_normals\"])\n            except Exception:\n                pass\n            rec[\"actor_normals\"] = None\n            rec[\"normals_visible\"] = False\n            try:\n                self.plotter.update()\n            except Exception:\n                pass\n            return\n\n        # Show path: rebuild regardless of whether the budgeted pdata already carries \"Normals\"\n        # (the builder will source from rec[\"normals_array\"] or full_pdata as needed)\n        pdata = rec.get(\"pdata\")\n\n        # Optional legacy scale override\n        if scale is not None:\n            try:\n                s = int(max(1, min(200, round(float(scale) * 1000.0))))\n                rec[\"normals_scale\"] = s\n            except Exception:\n                pass\n\n        self._rebuild_normals_actor(\n            dataset_index,\n            style=str(rec.get(\"normals_style\", self._normals_style)),\n            color=tuple(rec.get(\"normals_color\", self._normals_color)),\n            percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n            scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n        )\n        rec[\"normals_visible\"] = True\n        try:\n            self.plotter.update()\n        except Exception:\n            pass\n\n    # ---- Public normals setters -------------------------------------------\n    def set_normals_style(self, dataset_index: int, style: str) -&gt; None:\n        \"\"\"Set normals color style for a dataset and rebuild if visible.\"\"\"\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n        style = str(style).strip()\n        if style not in (\"Uniform\", \"Axis RGB\", \"RGB Components\"):\n            style = \"Axis RGB\"\n        rec[\"normals_style\"] = style\n        if rec.get(\"normals_visible\", False):\n            self._rebuild_normals_actor(\n                dataset_index,\n                style=style,\n                color=tuple(rec.get(\"normals_color\", self._normals_color)),\n                percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n                scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n            )\n            try:\n                self.plotter.update()\n            except Exception:\n                pass\n\n    def set_normals_color(self, dataset_index: int, r: int, g: int, b: int) -&gt; None:\n        \"\"\"Set uniform color for normals (used only in 'Uniform' style).\"\"\"\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n        color = (\n            max(0, min(255, int(r))) / 255.0,\n            max(0, min(255, int(g))) / 255.0,\n            max(0, min(255, int(b))) / 255.0,\n        )\n        rec[\"normals_color\"] = color\n        if rec.get(\"normals_visible\", False) and rec.get(\"normals_style\") == \"Uniform\":\n            self._rebuild_normals_actor(\n                dataset_index,\n                style=\"Uniform\",\n                color=color,\n                percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n                scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n            )\n            try:\n                self.plotter.update()\n            except Exception:\n                pass\n\n    def set_normals_fraction(self, dataset_index: int, percent: int) -&gt; None:\n        \"\"\"Set the percentage (1..100) of normals to draw and rebuild if visible.\"\"\"\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n        p = max(1, min(100, int(percent)))\n        rec[\"normals_percent\"] = p\n        if rec.get(\"normals_visible\", False):\n            self._rebuild_normals_actor(\n                dataset_index,\n                style=str(rec.get(\"normals_style\", self._normals_style)),\n                color=tuple(rec.get(\"normals_color\", self._normals_color)),\n                percent=p,\n                scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n            )\n            try:\n                self.plotter.update()\n            except Exception:\n                pass\n\n    def set_normals_scale(self, dataset_index: int, scale: int) -&gt; None:\n        \"\"\"Set the glyph scale slider value (1..200) and rebuild if visible.\"\"\"\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n        s = max(1, min(200, int(scale)))\n        rec[\"normals_scale\"] = s\n        if rec.get(\"normals_visible\", False):\n            self._rebuild_normals_actor(\n                dataset_index,\n                style=str(rec.get(\"normals_style\", self._normals_style)),\n                color=tuple(rec.get(\"normals_color\", self._normals_color)),\n                percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n                scale=s,\n            )\n            try:\n                self.plotter.update()\n            except Exception:\n                pass\n\n    def set_points_visibility(self, dataset_index: int, visible: bool) -&gt; None:\n        \"\"\"Show/hide the points actor for a dataset by removing/adding the actor.\"\"\"\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n\n        rec[\"visible\"] = bool(visible)\n        try:\n            if not visible:\n                actor = rec.get(\"actor_points\")\n                if actor is not None:\n                    try:\n                        self.plotter.remove_actor(actor)\n                    except Exception:\n                        pass\n                    rec[\"actor_points\"] = None\n                self.plotter.update()\n                return\n\n            # Visible: (re)create from current budgeted pdata\n            pdata_for_view = self._apply_budget_to_polydata(\n                rec.get(\"full_pdata\", rec.get(\"pdata\")),\n                rec.get(\"has_rgb\", False),\n                rec.get(\"view_percent\", 100),\n            )\n            rec[\"pdata\"] = pdata_for_view\n            actor = self._add_points_by_mode(\n                pdata_for_view,\n                bool(rec.get(\"has_rgb\", False)),\n                rec.get(\"solid_color\", self._solid_fallback),\n                rec.get(\"color_mode\", self._color_mode),\n                rec.get(\"cmap\", self._cmap),\n                rec.get(\"points_as_spheres\", self._points_as_spheres),\n            )\n            # Applica la dimensione punti corrente\n            try:\n                if actor is not None:\n                    prop = actor.GetProperty()\n                    if prop:\n                        prop.SetPointSize(self._point_size)\n            except Exception:\n                pass\n            rec[\"actor_points\"] = actor\n            self.plotter.update()\n        except Exception:\n            pass\n\n    def color_points_by_array(self, dataset_index: int, array_name: str, cmap: str = \"viridis\", show_scalar_bar: bool = True) -&gt; None:\n        \"\"\"Color a point dataset by a point-data array and rebuild its actor.\n\n        Args:\n            dataset_index: Index of the target dataset (must be kind == 'points').\n            array_name: Name of the array present in rec['pdata'].point_data.\n            cmap: Matplotlib colormap name (e.g., 'viridis', 'plasma').\n            show_scalar_bar: If True, show scalar bar titled with the array name.\n        \"\"\"\n        recs = getattr(self, \"_datasets\", [])\n        if not (isinstance(dataset_index, int) and 0 &lt;= dataset_index &lt; len(recs)):\n            return\n        rec = recs[dataset_index]\n        if rec.get(\"kind\") != \"points\":\n            return\n\n        pdata = rec.get(\"pdata\")\n        if pdata is None:\n            return\n        try:\n            npts = int(getattr(pdata, \"n_points\", 0))\n        except Exception:\n            npts = 0\n        if npts &lt;= 0:\n            return\n\n        # Ensure the array exists on pdata\n        try:\n            if not (hasattr(pdata, \"point_data\") and array_name in pdata.point_data):\n                return\n        except Exception:\n            return\n\n        # Remove previous points actor\n        try:\n            actor = rec.get(\"actor_points\")\n            if actor is not None and hasattr(self, \"plotter\"):\n                self.plotter.remove_actor(actor)\n        except Exception:\n            pass\n        rec[\"actor_points\"] = None\n\n        # Add a new points actor using the provided scalars\n        try:\n            actor = self.plotter.add_points(\n                pdata,\n                scalars=array_name,\n                cmap=cmap,\n                render_points_as_spheres=bool(rec.get(\"points_as_spheres\", False)),\n                show_scalar_bar=False,\n            )\n            rec[\"actor_points\"] = actor\n            # Keep point size\n            try:\n                size = int(rec.get(\"point_size\", getattr(self, \"_point_size\", 3)))\n                prop = actor.GetProperty() if actor is not None else None\n                if prop:\n                    prop.SetPointSize(size)\n            except Exception:\n                pass\n        except Exception:\n            return\n\n        # Book-keeping and optional scalar bar\n        rec[\"color_mode\"] = f\"PointData/{array_name}\"\n        rec[\"scalar_name\"] = array_name\n        rec[\"cmap\"] = cmap\n        try:\n            if show_scalar_bar and hasattr(self, \"set_colorbar_mode\"):\n                self.set_colorbar_mode(getattr(self, \"_scalarbar_mode\", \"horizontal-br\"), title=array_name)\n            elif hasattr(self, \"set_colorbar_mode\"):\n                self.set_colorbar_mode(\"hidden\")\n        except Exception:\n            pass\n\n        try:\n            if hasattr(self, \"plotter\"):\n                self.plotter.render()\n        except Exception:\n            pass\n\n\n    def reset_point_coloring(self, dataset_index: int) -&gt; None:\n        \"\"\"Restore default coloring for a point dataset (Solid/RGB/Intensity heuristic).\"\"\"\n        recs = getattr(self, \"_datasets\", [])\n        if not (isinstance(dataset_index, int) and 0 &lt;= dataset_index &lt; len(recs)):\n            return\n        rec = recs[dataset_index]\n        if rec.get(\"kind\") != \"points\":\n            return\n\n        # Remove current actor\n        try:\n            actor = rec.get(\"actor_points\")\n            if actor is not None and hasattr(self, \"plotter\"):\n                self.plotter.remove_actor(actor)\n        except Exception:\n            pass\n        rec[\"actor_points\"] = None\n\n        # Rebuild via helper if available\n        try:\n            actor = None\n            if hasattr(self, \"_add_points_by_mode\"):\n                actor = self._add_points_by_mode(\n                    rec.get(\"pdata\"),\n                    rec.get(\"has_rgb\", False),\n                    rec.get(\"solid_color\", getattr(self, \"_solid_fallback\", (200, 200, 200))),\n                    rec.get(\"color_mode\", getattr(self, \"_color_mode\", \"Solid\")),\n                    rec.get(\"cmap\", getattr(self, \"_cmap\", \"viridis\")),\n                    rec.get(\"points_as_spheres\", getattr(self, \"_points_as_spheres\", False)),\n                )\n            rec[\"actor_points\"] = actor\n            # Hide scalar bar\n            if hasattr(self, \"set_colorbar_mode\"):\n                self.set_colorbar_mode(\"hidden\")\n            # Restore point size\n            try:\n                if actor is not None:\n                    prop = actor.GetProperty()\n                    if prop:\n                        prop.SetPointSize(int(rec.get(\"point_size\", getattr(self, \"_point_size\", 3))))\n            except Exception:\n                pass\n            if hasattr(self, \"plotter\"):\n                self.plotter.render()\n        except Exception:\n            pass\n\n    def set_mesh_visibility(self, dataset_index: int, visible: bool) -&gt; None:\n        \"\"\"Show or hide a mesh dataset.\"\"\"\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n        if rec.get(\"kind\") != \"mesh\":\n            return\n        rec[\"visible\"] = bool(visible)\n        actor = rec.get(\"actor_mesh\")\n        if not visible and actor is not None:\n            try:\n                self.plotter.remove_actor(actor)\n            except Exception:\n                pass\n            rec[\"actor_mesh\"] = None\n            try:\n                self.plotter.update()\n            except Exception:\n                pass\n            return\n        if visible and actor is None:\n            try:\n                rec[\"actor_mesh\"] = self._add_mesh_no_bar(\n                    rec.get(\"mesh\"),\n                    color=rec.get(\"solid_color\", self._solid_fallback),\n                    style=\"wireframe\"\n                    if rec.get(\"representation\", \"surface\") == \"wireframe\"\n                    else \"surface\",\n                    opacity=float(rec.get(\"opacity\", 100)) / 100.0,\n                )\n                self.plotter.update()\n            except Exception:\n                pass\n\n    def set_mesh_opacity(self, dataset_index: int, opacity: int) -&gt; None:\n        \"\"\"Set mesh opacity (0-100).\"\"\"\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n        if rec.get(\"kind\") != \"mesh\":\n            return\n        rec[\"opacity\"] = max(0, min(100, int(opacity)))\n        actor = rec.get(\"actor_mesh\")\n        if actor is not None:\n            try:\n                prop = actor.GetProperty()\n                if prop:\n                    prop.SetOpacity(rec[\"opacity\"] / 100.0)\n                self.plotter.update()\n            except Exception:\n                pass\n\n    def _apply_budget_to_polydata(self, full_pdata, has_rgb: bool, percent: int = 100):\n        \"\"\"Return a PolyData respecting view budget with smooth % changes.\n\n        Args:\n            full_pdata: PolyData with all points.\n            has_rgb: True if dataset has RGB values.\n            percent: Desired visible percent (1-100).\n\n        Uses a deterministic hash-per-point probability test so tiny percent\n        changes produce proportionally small visual changes (no big jumps),\n        and results are stable across refreshes.\n        \"\"\"\n        try:\n            import numpy as np\n            import pyvista as pv\n        except Exception:\n            return full_pdata\n\n        pct = max(1, min(100, int(percent)))\n        if pct &gt;= 100:\n            return full_pdata\n\n        pts = np.asarray(full_pdata.points)\n        n = pts.shape[0]\n        if n == 0:\n            return full_pdata\n\n        # Quantize coordinates to integers to build a fast, deterministic hash\n        q = np.round(pts * 1e4).astype(np.int64)  # 0.1 mm se unit\u00e0 metri\n        # 32-bit mix\n        h = (\n            (q[:, 0] * 73856093) ^\n            (q[:, 1] * 19349663) ^\n            (q[:, 2] * 83492791)\n        ) &amp; 0xFFFFFFFF\n        # Bucket 0..99\n        bucket = (h % 100).astype(np.int32)\n        mask = bucket &lt; pct\n        if not np.any(mask):\n            mask[0] = True\n\n        out = pv.PolyData(pts[mask])\n\n        # Copia arrays allineati\n        pd = full_pdata.point_data\n        for key in list(pd.keys()):\n            try:\n                arr = np.asarray(pd[key])\n                if arr.shape[0] == n:\n                    out.point_data[key] = arr[mask]\n            except Exception:\n                pass\n\n        return out\n\n        # ---- Internals: normals helpers ---------------------------------------\n    def _dataset_diag(self, pdata) -&gt; float:\n        \"\"\"Return scene-space diagonal length for a PolyData's bounds.\"\"\"\n        try:\n            import numpy as np\n            pts = pdata.points\n            if pts.size == 0:\n                return 1.0\n            bb = np.array([pts.min(axis=0), pts.max(axis=0)])\n            return float(np.linalg.norm(bb[1] - bb[0])) or 1.0\n        except Exception:\n            return 1.0\n\n    def _normals_subset(self, pts, nrm, percent: int):\n        \"\"\"Return a deterministic subset of points+normals given a percentage.\"\"\"\n        import numpy as np\n        p = max(1, min(100, int(percent)))\n        n = pts.shape[0]\n        if n &lt;= 20000 and p &gt;= 100:\n            return pts, nrm\n        q = np.round(pts * 1e4).astype(np.int64)\n        h = ((q[:, 0] * 73856093) ^ (q[:, 1] * 19349663) ^ (q[:, 2] * 83492791)) &amp; 0xFFFFFFFF\n        mask = (h % 100) &lt; p\n        if not mask.any():\n            mask[0] = True\n        return pts[mask], nrm[mask]\n\n    def _normals_colors(self, pts, nrm, style: str, uniform_rgb: tuple[float, float, float]):\n        \"\"\"Compute per-glyph colors according to the selected style.\"\"\"\n        import numpy as np\n        if style == \"Axis RGB\":\n            c = np.abs(nrm[:, :3])\n            c = c / np.maximum(1e-12, c.max(axis=1, keepdims=True))\n            return c\n        if style == \"RGB Components\":\n            c = (nrm[:, :3] * 0.5) + 0.5\n            return c\n        return None\n\n    import numpy as _np\n    import pyvista as _pv\n\n    def _get_normals_array(self, pdata) -&gt; _np.ndarray | None:\n        # 1) propriet\u00e0 comoda\n        import numpy as _np\n        import pyvista as _pv\n        try:\n            n = getattr(pdata, \"point_normals\", None)\n            if n is not None:\n                n = _np.asarray(n)\n                if n.ndim == 2 and n.shape[1] == 3:\n                    return n\n        except Exception:\n            pass\n        # 2) chiavi comuni\n        try:\n            pcd = getattr(pdata, \"point_data\", {})\n            for key in (\"Normals\", \"normals\", \"PointNormals\"):\n                if key in pcd:\n                    n = _np.asarray(pcd[key])\n                    if n.ndim == 2 and n.shape[1] == 3:\n                        return n\n        except Exception:\n            pass\n        return None\n\n    def _rebuild_normals_actor(self, ds: int,\n                            style: str = \"Uniform\",\n                            color: tuple[float, float, float] = (1.0, 0.2, 0.2),\n                            percent: int = 10,\n                            scale: int = 30) -&gt; None:\n        \"\"\"(Re)build normals glyph actor for dataset `ds`.\"\"\"\n        import numpy as _np\n        import pyvista as _pv\n        try:\n            rec = self._datasets[ds]\n        except Exception:\n            return\n\n        # Remove previous\n        try:\n            if rec.get(\"actor_normals\") is not None:\n                self.plotter.remove_actor(rec[\"actor_normals\"])\n        except Exception:\n            pass\n        rec[\"actor_normals\"] = None\n\n        pdata = rec.get(\"pdata\")\n        if pdata is None or getattr(pdata, \"n_points\", 0) == 0:\n            print(\"[Normals] pdata missing or empty\")\n            return\n\n        pdata_view = rec.get(\"pdata\")\n        full_pdata = rec.get(\"full_pdata\", pdata_view)\n\n        if full_pdata is None or getattr(full_pdata, \"n_points\", 0) == 0:\n            print(\"[Normals] pdata missing or empty\")\n            return\n\n        # Points from FULL dataset (aligns best with worker-produced normals)\n        P = _np.asarray(full_pdata.points, dtype=float)\n\n        # Normals priority:\n        # 1) result saved by the worker (rec[\"normals_array\"])\n        # 2) arrays already present on full_pdata\n        # 3) arrays on the budgeted view (if any)\n        # 4) as last resort, compute in place on full_pdata\n        N = rec.get(\"normals_array\", None)\n\n        if N is None:\n            N = self._get_normals_array(full_pdata)\n\n        if N is None and pdata_view is not None:\n            N = self._get_normals_array(pdata_view)\n\n        if N is None:\n            try:\n                full_pdata.compute_normals(point_normals=True, inplace=True)\n                N = self._get_normals_array(full_pdata)\n            except Exception:\n                N = None\n\n        if N is None:\n            print(\"[Normals] No normals array found\")\n            return\n\n        # Clean + normalize, reconcile lengths\n        N = _np.asarray(N, dtype=float)\n        P = _np.asarray(P, dtype=float)\n\n        nP = int(P.shape[0]) if P.ndim == 2 and P.shape[1] == 3 else 0\n        nN = int(N.shape[0]) if N.ndim == 2 and N.shape[1] == 3 else 0\n        if nP == 0 or nN == 0:\n            return\n        if nP != nN:\n            m = min(nP, nN)\n            P = P[:m]\n            N = N[:m]\n\n        ok = _np.isfinite(N).all(axis=1)\n        ok &amp;= _np.isfinite(P).all(axis=1)\n        if not ok.any():\n            return\n        N = N[ok]\n        P = P[ok]\n        if N.size == 0 or P.size == 0:\n            return\n\n        # Normalize normals\n        norm = _np.linalg.norm(N, axis=1)\n        eps = 1e-12\n        nz = norm &gt; eps\n        N[nz] = (N[nz].T / norm[nz]).T\n        N[~nz] = _np.array([0.0, 0.0, 1.0])\n\n        npts = P.shape[0]\n        perc = int(max(1, min(100, percent)))\n        nsamp = max(1, int(round(npts * (perc / 100.0))))\n        rng = _np.random.default_rng(12345 + int(ds))\n        idx = rng.choice(npts, size=nsamp, replace=False) if nsamp &lt; npts else _np.arange(npts)\n\n        scl = float(max(1, min(200, int(scale)))) * 0.01\n\n        try:\n            # Compute a stable glyph length based on dataset diagonal (scale slider: 1..200 -&gt; /1000)\n            diag = self._dataset_diag(full_pdata)\n            factor = max(diag * (float(scale) / 1000.0), 1e-9)\n\n            # Build arrow glyphs explicitly so we can attach per-glyph RGB\n            centers = _pv.PolyData(P[idx])\n            centers[\"vectors\"] = N[idx]\n            arrow = _pv.Arrow()  # default small arrow geometry\n            glyph = centers.glyph(orient=\"vectors\", scale=False, factor=factor, geom=arrow)\n\n            # Decide coloring\n            if style == \"Uniform\":\n                # Single uniform color\n                actor = self._add_mesh_no_bar(\n                    glyph,\n                    color=(float(color[0]), float(color[1]), float(color[2])),\n                    name=f\"normals_ds{ds}\",\n                )\n            # --- dentro _rebuild_normals_actor, nel blocco \"else:\" per gli stili non 'Uniform' ---\n            else:\n                # Per-glyph RGB based on style (Axis RGB / RGB Components)\n                C = self._normals_colors(P[idx], N[idx], style, color)\n                if C is None:\n                    # Fallback a colore uniforme se stile non riconosciuto\n                    actor = self._add_mesh_no_bar(\n                        glyph,\n                        color=(float(color[0]), float(color[1]), float(color[2])),\n                        name=f\"normals_ds{ds}\",\n                    )\n                else:\n                    import numpy as _np\n                    # RGB per freccia in [0..255] uint8\n                    rgb = _np.asarray(_np.clip(_np.round(C * 255.0), 0, 255), dtype=_np.uint8)\n\n                    k = rgb.shape[0]  # numero di frecce (= nsamp)\n                    # Tentativo 1: per-cella\n                    try:\n                        cells_per = max(1, int(glyph.n_cells // max(1, k)))\n                        rgb_cells = _np.repeat(rgb, cells_per, axis=0)\n                        # Allinea esattamente alla lunghezza richiesta\n                        if rgb_cells.shape[0] &lt; glyph.n_cells:\n                            pad = _np.repeat(rgb[-1:], glyph.n_cells - rgb_cells.shape[0], axis=0)\n                            rgb_cells = _np.concatenate([rgb_cells, pad], axis=0)\n                        elif rgb_cells.shape[0] &gt; glyph.n_cells:\n                            rgb_cells = rgb_cells[:glyph.n_cells]\n\n                        glyph.cell_data[\"RGB\"] = rgb_cells\n                        actor = self._add_mesh_no_bar(\n                            glyph,\n                            scalars=\"RGB\",\n                            rgb=True,\n                            name=f\"normals_ds{ds}\",\n                        )\n                    except Exception:\n                        # Tentativo 2: per-punto\n                        try:\n                            pts_per = max(1, int(glyph.n_points // max(1, k)))\n                            rgb_pts = _np.repeat(rgb, pts_per, axis=0)\n                            if rgb_pts.shape[0] &lt; glyph.n_points:\n                                pad = _np.repeat(rgb[-1:], glyph.n_points - rgb_pts.shape[0], axis=0)\n                                rgb_pts = _np.concatenate([rgb_pts, pad], axis=0)\n                            elif rgb_pts.shape[0] &gt; glyph.n_points:\n                                rgb_pts = rgb_pts[:glyph.n_points]\n\n                            glyph.point_data[\"RGB\"] = rgb_pts\n                            actor = self._add_mesh_no_bar(\n                                glyph,\n                                scalars=\"RGB\",\n                                rgb=True,\n                                name=f\"normals_ds{ds}\",\n                            )\n                        except Exception:\n                            # Ultimo fallback: colore uniforme\n                            actor = self._add_mesh_no_bar(\n                                glyph,\n                                color=(float(color[0]), float(color[1]), float(color[2])),\n                                name=f\"normals_ds{ds}\",\n                            )\n\n            rec[\"actor_normals\"] = actor\n            rec[\"normals_visible\"] = True\n            rec[\"normals_style\"] = style\n            rec[\"normals_color\"] = color\n            rec[\"normals_percent\"] = perc\n            rec[\"normals_scale\"] = int(scale)\n\n            try:\n                self.plotter.update()\n            except Exception:\n                pass\n            # print(f\"[Normals] ds={ds} points={npts} shown={idx.size} factor={factor:.6f}\")\n        except Exception as ex:\n            print(f\"[Normals] normals glyph failed: {ex}\")\n            rec[\"actor_normals\"] = None\n            rec[\"normals_visible\"] = False\n\n    def set_point_budget(self, percent: int, dataset_index: int | None = None) -&gt; None:\n        \"\"\"Set visible percent for points globally or for a specific dataset.\"\"\"\n        try:\n            p = int(percent)\n        except Exception:\n            return\n        p = max(1, min(100, p))\n\n        if dataset_index is None:\n            self._view_budget_percent = p\n            for idx, rec in enumerate(self._datasets):\n                if rec.get(\"kind\") != \"points\":\n                    continue\n                self.set_point_budget(p, idx)\n            return\n\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n        if rec.get(\"kind\") != \"points\":\n            return\n\n        rec[\"view_percent\"] = p\n        full_pdata = rec.get(\"full_pdata\", rec.get(\"pdata\"))\n        pdata_for_view = self._apply_budget_to_polydata(\n            full_pdata, rec.get(\"has_rgb\", False), p\n        )\n        rec[\"pdata\"] = pdata_for_view\n        actor = rec.get(\"actor_points\")\n        if actor is not None:\n            try:\n                self.plotter.remove_actor(actor)\n            except Exception:\n                pass\n        rec[\"actor_points\"] = None\n        if rec.get(\"visible\", True):\n            rec[\"actor_points\"] = self._add_points_by_mode(\n                pdata_for_view,\n                rec.get(\"has_rgb\", False),\n                rec.get(\"solid_color\", self._solid_fallback),\n                rec.get(\"color_mode\", self._color_mode),\n                rec.get(\"cmap\", self._cmap),\n                rec.get(\"points_as_spheres\", self._points_as_spheres),\n            )\n            actor = rec.get(\"actor_points\")\n            if actor is not None:\n                try:\n                    prop = actor.GetProperty()\n                    if prop:\n                        prop.SetPointSize(rec.get(\"point_size\", self._point_size))\n                except Exception:\n                    pass\n        try:\n            self.plotter.update()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.plotter","title":"<code>plotter = QtInteractor(self)</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.add_points","title":"<code>add_points(points, colors=None, normals=None)</code>","text":"<p>Add a point cloud to the scene with smart coloring and optional normals.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <p>array-like (N,3)</p> required <code>colors</code> <p>optional (N,3) in [0,1] or [0,255]</p> <code>None</code> <code>normals</code> <p>optional (N,3) float array of unit vectors</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Integer dataset index that can be used to toggle/augment visuals later.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def add_points(self, points, colors=None, normals=None) -&gt; int:\n    \"\"\"Add a point cloud to the scene with smart coloring and optional normals.\n\n    Args:\n        points: array-like (N,3)\n        colors: optional (N,3) in [0,1] or [0,255]\n        normals: optional (N,3) float array of unit vectors\n\n    Returns:\n        Integer dataset index that can be used to toggle/augment visuals later.\n    \"\"\"\n    try:\n        import numpy as np\n        import pyvista as pv  # type: ignore\n\n        pts = np.asarray(points, dtype=float)\n        pdata = pv.PolyData(pts)\n\n        has_rgb = False\n        if colors is not None:\n            cols = np.asarray(colors)\n            if cols.max() &gt; 1.5:\n                cols = cols / 255.0\n            pdata[\"RGB\"] = (cols * 255).astype(np.uint8)\n            has_rgb = True\n\n        if normals is not None:\n            nrm = np.asarray(normals, dtype=float)\n            if nrm.ndim == 2 and nrm.shape[1] &gt;= 3 and nrm.shape[0] == pts.shape[0]:\n                pdata[\"Normals\"] = nrm[:, :3].astype(np.float32)\n\n        # fake intensity per colormap fallback\n        if pts.size:\n            z = pts[:, 2]\n            zmin, zmax = float(z.min()), float(z.max())\n            inten = (z - zmin) / (zmax - zmin) if zmax &gt; zmin else np.zeros_like(z)\n            pdata[\"Intensity\"] = inten.astype(np.float32)\n\n        # Auto-initialize or rebalance the view budget\n        if not self._auto_budget_initialized:\n            cap = self._target_visible_points()\n            n = int(pts.shape[0])\n            p = min(100, max(1, int(cap * 100 / max(1, n))))\n            self._view_budget_percent = p\n            self._auto_budget_initialized = True\n        else:\n            self._rebalance_budget_across_datasets()\n\n        full_pdata = pdata\n        pdata_for_view = self._apply_budget_to_polydata(full_pdata, has_rgb, self._view_budget_percent)\n        # Scegli un colore distinto dalla palette per questo dataset\n        palette = getattr(self, \"_default_palette\", [self._solid_fallback])\n        ds_color = palette[len(self._datasets) % len(palette)] if palette else self._solid_fallback\n        actor_points = self._add_points_by_mode(\n            pdata_for_view,\n            has_rgb,\n            ds_color,\n            self._color_mode,\n            self._cmap,\n            self._points_as_spheres,\n        )\n        # Ensure the new actor uses the current point size\n        try:\n            if actor_points is not None:\n                prop = actor_points.GetProperty()\n                if prop:\n                    prop.SetPointSize(self._point_size)\n        except Exception:\n            pass\n\n        rec = {\n            \"kind\": \"points\",\n            \"full_pdata\": full_pdata,\n            \"pdata\": pdata_for_view,\n            \"actor_points\": actor_points,\n            \"actor_normals\": None,\n            \"has_rgb\": has_rgb,\n            \"solid_color\": ds_color,\n            \"visible\": True,\n            \"point_size\": self._point_size,\n            \"view_percent\": self._view_budget_percent,\n            \"color_mode\": self._color_mode,\n            \"cmap\": self._cmap,\n            \"points_as_spheres\": self._points_as_spheres,\n            # ---- per-dataset normals state ----\n            \"normals_visible\": False,\n            \"normals_style\": self._normals_style,\n            \"normals_color\": self._normals_color,\n            \"normals_percent\": self._normals_percent,\n            \"normals_scale\": self._normals_scale,\n            \"scalar_name\": \"Intensity\",\n        }\n        self._datasets.append(rec)\n        ds_index = len(self._datasets) - 1\n\n        self.plotter.reset_camera()\n        try:\n            self._apply_overlays()\n        except Exception:\n            pass\n        return ds_index\n    except Exception:\n        return -1\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.add_pyvista_mesh","title":"<code>add_pyvista_mesh(mesh)</code>","text":"<p>Add a VTK/PyVista mesh to the scene with a guaranteed surface actor.</p> <p>Stores both: - rec['mesh_orig']    : the original dataset (e.g. UnstructuredGrid) - rec['mesh_surface'] : a PolyData surface extracted for rendering</p> <p>All visual representations use the surface, so scalars and edges behave.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def add_pyvista_mesh(self, mesh) -&gt; int:\n    \"\"\"Add a VTK/PyVista mesh to the scene with a guaranteed surface actor.\n\n    Stores both:\n    - rec['mesh_orig']    : the original dataset (e.g. UnstructuredGrid)\n    - rec['mesh_surface'] : a PolyData surface extracted for rendering\n\n    All visual representations use the surface, so scalars and edges behave.\n    \"\"\"\n    try:\n        render_mesh = _ensure_surface_mesh(mesh)\n        actor = self._add_mesh_no_bar(render_mesh)\n        rec = {\n            \"kind\": \"mesh\",\n            \"mesh_orig\": mesh,\n            \"mesh_surface\": render_mesh,\n            \"actor\": actor,\n            \"visible\": True,\n            \"representation\": \"Surface\",\n            \"opacity\": 100,\n            \"solid_color\": (1.0, 1.0, 1.0),\n            \"active_scalars\": None,\n            \"active_scalar_name\": \"\",\n            \"colormap\": \"Viridis\",\n            \"clim\": None,\n            \"scalar_bar\": False,\n            \"edge_visibility\": False,\n            \"edge_color\": (0, 0, 0),\n            \"point_size\": 3,\n            \"line_width\": 1,\n            \"lighting\": True,\n        }\n        self._datasets.append(rec)\n        try:\n            self.plotter.reset_camera()\n        except Exception:\n            pass\n        return len(self._datasets) - 1\n    except Exception:\n        return -1\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.apply_normals_properties","title":"<code>apply_normals_properties(ds, *, style=None, color=None, percent=None, scale=None, ensure_visible=True)</code>","text":"<p>Update per-dataset normals properties and optionally rebuild glyphs.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>int</code> <p>Dataset index.</p> required <code>style</code> <code>str | None</code> <p>'Uniform' | 'Axis RGB' | 'RGB Components'.</p> <code>None</code> <code>color</code> <code>tuple[float, float, float] | None</code> <p>Uniform RGB (0..1 floats).</p> <code>None</code> <code>percent</code> <code>int | None</code> <p>1..100 fraction of glyphs shown.</p> <code>None</code> <code>scale</code> <code>int | None</code> <p>1..200 glyph magnitude slider value.</p> <code>None</code> <code>ensure_visible</code> <code>bool</code> <p>If True, shows/rebuilds normals actor immediately.</p> <code>True</code> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def apply_normals_properties(\n    self,\n    ds: int,\n    *,\n    style: str | None = None,\n    color: tuple[float, float, float] | None = None,\n    percent: int | None = None,\n    scale: int | None = None,\n    ensure_visible: bool = True,\n) -&gt; None:\n    \"\"\"Update per-dataset normals properties and optionally rebuild glyphs.\n\n    Args:\n        ds: Dataset index.\n        style: 'Uniform' | 'Axis RGB' | 'RGB Components'.\n        color: Uniform RGB (0..1 floats).\n        percent: 1..100 fraction of glyphs shown.\n        scale: 1..200 glyph magnitude slider value.\n        ensure_visible: If True, shows/rebuilds normals actor immediately.\n    \"\"\"\n    try:\n        rec = self._datasets[ds]\n    except Exception:\n        return\n\n    if style is not None:\n        rec[\"normals_style\"] = str(style)\n    if color is not None:\n        try:\n            r, g, b = color\n            rec[\"normals_color\"] = (float(r), float(g), float(b))\n        except Exception:\n            pass\n    if percent is not None:\n        rec[\"normals_percent\"] = int(max(1, min(100, int(percent))))\n    if scale is not None:\n        rec[\"normals_scale\"] = int(max(1, min(200, int(scale))))\n\n    if ensure_visible:\n        # This will rebuild the actor with the latest properties\n        self.set_normals_visibility(ds, True)\n    elif rec.get(\"normals_visible\"):\n        # Rebuild without toggling visibility\n        self._rebuild_normals_actor(\n            ds,\n            style=str(rec.get(\"normals_style\", self._normals_style)),\n            color=tuple(rec.get(\"normals_color\", self._normals_color)),\n            percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n            scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n        )\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.clear","title":"<code>clear()</code>","text":"<p>Remove all actors from the scene.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all actors from the scene.\"\"\"\n    try:\n        self.plotter.clear()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.color_points_by_array","title":"<code>color_points_by_array(dataset_index, array_name, cmap='viridis', show_scalar_bar=True)</code>","text":"<p>Color a point dataset by a point-data array and rebuild its actor.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_index</code> <code>int</code> <p>Index of the target dataset (must be kind == 'points').</p> required <code>array_name</code> <code>str</code> <p>Name of the array present in rec['pdata'].point_data.</p> required <code>cmap</code> <code>str</code> <p>Matplotlib colormap name (e.g., 'viridis', 'plasma').</p> <code>'viridis'</code> <code>show_scalar_bar</code> <code>bool</code> <p>If True, show scalar bar titled with the array name.</p> <code>True</code> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def color_points_by_array(self, dataset_index: int, array_name: str, cmap: str = \"viridis\", show_scalar_bar: bool = True) -&gt; None:\n    \"\"\"Color a point dataset by a point-data array and rebuild its actor.\n\n    Args:\n        dataset_index: Index of the target dataset (must be kind == 'points').\n        array_name: Name of the array present in rec['pdata'].point_data.\n        cmap: Matplotlib colormap name (e.g., 'viridis', 'plasma').\n        show_scalar_bar: If True, show scalar bar titled with the array name.\n    \"\"\"\n    recs = getattr(self, \"_datasets\", [])\n    if not (isinstance(dataset_index, int) and 0 &lt;= dataset_index &lt; len(recs)):\n        return\n    rec = recs[dataset_index]\n    if rec.get(\"kind\") != \"points\":\n        return\n\n    pdata = rec.get(\"pdata\")\n    if pdata is None:\n        return\n    try:\n        npts = int(getattr(pdata, \"n_points\", 0))\n    except Exception:\n        npts = 0\n    if npts &lt;= 0:\n        return\n\n    # Ensure the array exists on pdata\n    try:\n        if not (hasattr(pdata, \"point_data\") and array_name in pdata.point_data):\n            return\n    except Exception:\n        return\n\n    # Remove previous points actor\n    try:\n        actor = rec.get(\"actor_points\")\n        if actor is not None and hasattr(self, \"plotter\"):\n            self.plotter.remove_actor(actor)\n    except Exception:\n        pass\n    rec[\"actor_points\"] = None\n\n    # Add a new points actor using the provided scalars\n    try:\n        actor = self.plotter.add_points(\n            pdata,\n            scalars=array_name,\n            cmap=cmap,\n            render_points_as_spheres=bool(rec.get(\"points_as_spheres\", False)),\n            show_scalar_bar=False,\n        )\n        rec[\"actor_points\"] = actor\n        # Keep point size\n        try:\n            size = int(rec.get(\"point_size\", getattr(self, \"_point_size\", 3)))\n            prop = actor.GetProperty() if actor is not None else None\n            if prop:\n                prop.SetPointSize(size)\n        except Exception:\n            pass\n    except Exception:\n        return\n\n    # Book-keeping and optional scalar bar\n    rec[\"color_mode\"] = f\"PointData/{array_name}\"\n    rec[\"scalar_name\"] = array_name\n    rec[\"cmap\"] = cmap\n    try:\n        if show_scalar_bar and hasattr(self, \"set_colorbar_mode\"):\n            self.set_colorbar_mode(getattr(self, \"_scalarbar_mode\", \"horizontal-br\"), title=array_name)\n        elif hasattr(self, \"set_colorbar_mode\"):\n            self.set_colorbar_mode(\"hidden\")\n    except Exception:\n        pass\n\n    try:\n        if hasattr(self, \"plotter\"):\n            self.plotter.render()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.enable_safe_rendering","title":"<code>enable_safe_rendering(enabled=True)</code>","text":"<p>Toggle conservative rendering settings (useful on macOS/Metal).</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>If True, apply safe settings; if False, attempt to restore defaults.</p> <code>True</code> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def enable_safe_rendering(self, enabled: bool = True) -&gt; None:\n    \"\"\"Toggle conservative rendering settings (useful on macOS/Metal).\n\n    Args:\n        enabled: If True, apply safe settings; if False, attempt to restore defaults.\n    \"\"\"\n    try:\n        if not hasattr(self.plotter, \"render_window\"):\n            return\n        if enabled:\n            self.plotter.render_window.SetMultiSamples(0)\n            try:\n                self.plotter.renderer.SetUseDepthPeeling(0)\n                if hasattr(self.plotter.renderer, \"SetUseFXAA\"):\n                    self.plotter.renderer.SetUseFXAA(False)\n            except Exception:\n                pass\n        else:\n            # Best-effort revert\n            try:\n                self.plotter.render_window.SetMultiSamples(4)\n            except Exception:\n                pass\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.invert_view","title":"<code>invert_view()</code>","text":"<p>Invert the camera position through the focal point.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def invert_view(self) -&gt; None:\n    \"\"\"Invert the camera position through the focal point.\"\"\"\n    try:\n        pos, foc, up = self.plotter.camera_position\n        inv = (2 * foc[0] - pos[0], 2 * foc[1] - pos[1], 2 * foc[2] - pos[2])\n        self.plotter.camera_position = [inv, foc, up]\n        self.plotter.reset_camera_clipping_range()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.refresh","title":"<code>refresh()</code>","text":"<p>Request a render update (prefer immediate render if available).</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Request a render update (prefer immediate render if available).\"\"\"\n    try:\n        if hasattr(self.plotter, \"render\"):\n            self.plotter.render()\n        else:\n            self.plotter.update()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.reset_point_coloring","title":"<code>reset_point_coloring(dataset_index)</code>","text":"<p>Restore default coloring for a point dataset (Solid/RGB/Intensity heuristic).</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def reset_point_coloring(self, dataset_index: int) -&gt; None:\n    \"\"\"Restore default coloring for a point dataset (Solid/RGB/Intensity heuristic).\"\"\"\n    recs = getattr(self, \"_datasets\", [])\n    if not (isinstance(dataset_index, int) and 0 &lt;= dataset_index &lt; len(recs)):\n        return\n    rec = recs[dataset_index]\n    if rec.get(\"kind\") != \"points\":\n        return\n\n    # Remove current actor\n    try:\n        actor = rec.get(\"actor_points\")\n        if actor is not None and hasattr(self, \"plotter\"):\n            self.plotter.remove_actor(actor)\n    except Exception:\n        pass\n    rec[\"actor_points\"] = None\n\n    # Rebuild via helper if available\n    try:\n        actor = None\n        if hasattr(self, \"_add_points_by_mode\"):\n            actor = self._add_points_by_mode(\n                rec.get(\"pdata\"),\n                rec.get(\"has_rgb\", False),\n                rec.get(\"solid_color\", getattr(self, \"_solid_fallback\", (200, 200, 200))),\n                rec.get(\"color_mode\", getattr(self, \"_color_mode\", \"Solid\")),\n                rec.get(\"cmap\", getattr(self, \"_cmap\", \"viridis\")),\n                rec.get(\"points_as_spheres\", getattr(self, \"_points_as_spheres\", False)),\n            )\n        rec[\"actor_points\"] = actor\n        # Hide scalar bar\n        if hasattr(self, \"set_colorbar_mode\"):\n            self.set_colorbar_mode(\"hidden\")\n        # Restore point size\n        try:\n            if actor is not None:\n                prop = actor.GetProperty()\n                if prop:\n                    prop.SetPointSize(int(rec.get(\"point_size\", getattr(self, \"_point_size\", 3))))\n        except Exception:\n            pass\n        if hasattr(self, \"plotter\"):\n            self.plotter.render()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_axes_enabled","title":"<code>set_axes_enabled(enabled)</code>","text":"<p>Public toggle for axes overlay.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_axes_enabled(self, enabled: bool) -&gt; None:\n    \"\"\"Public toggle for axes overlay.\"\"\"\n    self._axes_on = bool(enabled)\n    try:\n        self._apply_overlays()\n        self.refresh()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_background_color","title":"<code>set_background_color(color)</code>","text":"<p>Set the plotter background color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <p><code>QtGui.QColor</code> or an (r,g,b) tuple in 0..255 or 0..1 floats.</p> required Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_background_color(self, color) -&gt; None:\n    \"\"\"Set the plotter background color.\n\n    Args:\n        color: `QtGui.QColor` or an (r,g,b) tuple in 0..255 or 0..1 floats.\n    \"\"\"\n    try:\n        r = g = b = None\n        try:\n            from PySide6 import QtGui as _QtGui  # local import\n        except Exception:\n            _QtGui = None\n        if _QtGui is not None and isinstance(color, _QtGui.QColor):\n            r, g, b = color.red(), color.green(), color.blue()\n        else:\n            r, g, b = color\n            if all(isinstance(c, float) and 0.0 &lt;= c &lt;= 1.0 for c in (r, g, b)):\n                r, g, b = int(round(r * 255)), int(round(g * 255)), int(round(b * 255))\n        self._bg_rgb = (int(r), int(g), int(b))\n        self._apply_background()\n        self.refresh()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_color_mode","title":"<code>set_color_mode(mode, ds)</code>","text":"<p>Set 'color mode' for dataset ds.</p> <p>Supported modes: - \"Solid Color\" - \"PointData/\" - \"CellData/\"  (TODO: mapping via vtkOriginalCellIds) Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_color_mode(self, mode: str, ds: int) -&gt; None:\n    \"\"\"Set 'color mode' for dataset *ds*.\n\n    Supported modes:\n    - \"Solid Color\"\n    - \"PointData/&lt;ARRAY&gt;\"\n    - \"CellData/&lt;ARRAY&gt;\"  (TODO: mapping via vtkOriginalCellIds)\n    \"\"\"\n    recs = getattr(self, \"_datasets\", [])\n    if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n        return\n    rec = recs[ds]\n    rec[\"color_mode\"] = mode\n\n    # Solid \u21d2 disattiva scalars e aggiorna\n    if mode == \"Solid Color\":\n        rec[\"active_scalars\"] = None\n        rec[\"active_scalar_name\"] = \"\"\n        self._refresh_scalars(ds)\n        return\n\n    # Parse association/name\n    assoc = \"POINT\"\n    array_name = None\n    if mode.startswith(\"PointData/\"):\n        assoc = \"POINT\"\n        array_name = mode.split(\"/\", 1)[1]\n    elif mode.startswith(\"CellData/\"):\n        assoc = \"CELL\"\n        array_name = mode.split(\"/\", 1)[1]\n    else:\n        array_name = mode  # raw name, assume point\n\n    # Build scalars mapped to the render surface\n    scal = None\n    if assoc == \"POINT\" and array_name:\n        vmode = rec.get(\"vector_mode\", \"Magnitude\")\n        scal = self._map_point_scalars_to_surface_rec(rec, array_name, vmode)\n    else:\n        # TODO: support CellData via vtkOriginalCellIds and per-face averaging if needed\n        scal = None\n\n    if scal is None:\n        # fallback to solid\n        rec[\"active_scalars\"] = None\n        rec[\"active_scalar_name\"] = \"\"\n    else:\n        rec[\"active_scalars\"] = scal\n        rec[\"active_scalar_name\"] = array_name\n\n    self._refresh_scalars(ds)\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_colorbar_mode","title":"<code>set_colorbar_mode(mode='horizontal-br', title='')</code>","text":"<p>Set scalar bar layout and apply it immediately.</p> Supported modes <ul> <li>'hidden'         : remove scalar bar</li> <li>'horizontal-br'  : bottom-right horizontal bar</li> <li>'vertical-tr'    : top-right vertical bar</li> </ul> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_colorbar_mode(self, mode: str = \"horizontal-br\", title: str = \"\") -&gt; None:\n    \"\"\"Set scalar bar layout and apply it immediately.\n\n    Supported modes:\n        - 'hidden'         : remove scalar bar\n        - 'horizontal-br'  : bottom-right horizontal bar\n        - 'vertical-tr'    : top-right vertical bar\n    \"\"\"\n    try:\n        mode = str(mode).strip().lower()\n        if mode not in (\"hidden\", \"horizontal-br\", \"vertical-tr\"):\n            mode = \"horizontal-br\"\n        self._scalarbar_mode = mode\n        self._scalarbar_title = str(title)\n        self._apply_scalarbar()\n        self.refresh()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_colorbar_vertical","title":"<code>set_colorbar_vertical(enabled=True, title='')</code>","text":"<p>Show or hide a vertical colorbar at top-right of the scene.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>If True, display the colorbar; if False, remove it.</p> <code>True</code> <code>title</code> <code>str</code> <p>Optional label for the scalar bar.</p> <code>''</code> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_colorbar_vertical(self, enabled: bool = True, title: str = \"\") -&gt; None:\n    \"\"\"Show or hide a vertical colorbar at top-right of the scene.\n\n    Args:\n        enabled: If True, display the colorbar; if False, remove it.\n        title: Optional label for the scalar bar.\n    \"\"\"\n    try:\n        if not enabled:\n            if hasattr(self.plotter, \"remove_scalar_bar\"):\n                try:\n                    self.plotter.remove_scalar_bar()\n                except Exception:\n                    pass\n            return\n\n        opts = dict(\n            vertical=True,\n            position_x=0.85,  # right margin\n            position_y=0.1,   # start a bit below the top\n            height=0.8,\n            width=0.1,\n            title=title,\n            fmt=\"%0.3f\",\n        )\n        try:\n            self.plotter.add_scalar_bar(**opts)\n        except Exception:\n            pass\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_colormap","title":"<code>set_colormap(name, ds)</code>","text":"<p>Set the colormap name for dataset ds and refresh scalar mapping.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_colormap(self, name: str, ds: int) -&gt; None:\n    \"\"\"Set the colormap name for dataset *ds* and refresh scalar mapping.\"\"\"\n    recs = getattr(self, \"_datasets\", [])\n    if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n        return\n    rec = recs[ds]\n    rec[\"colormap\"] = str(name)\n    self._refresh_scalars(ds)\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_dataset_color","title":"<code>set_dataset_color(ds, r, g, b)</code>","text":"<p>Apply solid RGB color to dataset ds and persist.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>int</code> <p>Dataset index.</p> required <code>r, g, b</code> <p>0..255 components.</p> required Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_dataset_color(self, ds: int, r: int, g: int, b: int) -&gt; None:\n    \"\"\"Apply solid RGB color to dataset *ds* and persist.\n\n    Args:\n        ds: Dataset index.\n        r, g, b: 0..255 components.\n    \"\"\"\n    recs = getattr(self, \"_datasets\", [])\n    if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n        return\n    rec = recs[ds]\n    rec[\"solid_color\"] = (int(r), int(g), int(b))\n    act = rec.get(\"actor\")\n    if act is not None:\n        try:\n            act.mapper.scalar_visibility = False  # force solid\n        except Exception:\n            pass\n        try:\n            act.prop.color = (r/255.0, g/255.0, b/255.0)\n        except Exception:\n            pass\n        try:\n            self.plotter.render()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_grid_enabled","title":"<code>set_grid_enabled(enabled, **kwargs)</code>","text":"<p>Public toggle for bounds grid overlay.</p> <p>You may pass additional kwargs forwarded to plotter.show_bounds(), e.g., grid='front', location='outer', color='black', etc.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_grid_enabled(self, enabled: bool, **kwargs) -&gt; None:\n    \"\"\"Public toggle for bounds grid overlay.\n\n    You may pass additional kwargs forwarded to plotter.show_bounds(),\n    e.g., grid='front', location='outer', color='black', etc.\n    \"\"\"\n    self._bounds_on = bool(enabled)\n    if kwargs:\n        self._bounds_kwargs.update(kwargs)\n    try:\n        self._apply_overlays()\n        self.refresh()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_mesh_opacity","title":"<code>set_mesh_opacity(dataset_index, opacity)</code>","text":"<p>Set mesh opacity (0-100).</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_mesh_opacity(self, dataset_index: int, opacity: int) -&gt; None:\n    \"\"\"Set mesh opacity (0-100).\"\"\"\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n    if rec.get(\"kind\") != \"mesh\":\n        return\n    rec[\"opacity\"] = max(0, min(100, int(opacity)))\n    actor = rec.get(\"actor_mesh\")\n    if actor is not None:\n        try:\n            prop = actor.GetProperty()\n            if prop:\n                prop.SetOpacity(rec[\"opacity\"] / 100.0)\n            self.plotter.update()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_mesh_representation","title":"<code>set_mesh_representation(ds, mode)</code>","text":"<p>Set mesh representation for dataset ds.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>int</code> <p>Dataset index in the internal cache.</p> required <code>mode</code> <code>str</code> <p>One of {'Points','Wireframe','Surface','Surface with Edges'}.</p> required Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_mesh_representation(self, ds: int, mode: str) -&gt; None:\n    \"\"\"Set mesh representation for dataset *ds*.\n\n    Args:\n        ds: Dataset index in the internal cache.\n        mode: One of {'Points','Wireframe','Surface','Surface with Edges'}.\n    \"\"\"\n    recs = getattr(self, \"_datasets\", [])\n    if not (isinstance(ds, int) and 0 &lt;= ds &lt; len(recs)):\n        return\n    rec = recs[ds]\n    pdata = rec.get(\"mesh_surface\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n    if pdata is None or self.plotter is None:\n        return\n\n    rec[\"representation\"] = mode\n\n    # Remove previous actor\n    try:\n        act = rec.get(\"actor\") or rec.get(\"actor_mesh\") or rec.get(\"actor_points\")\n        if act is not None:\n            self.plotter.remove_actor(act)\n    except Exception:\n        pass\n\n    scalars = rec.get(\"active_scalars\", None)\n    cmap = rec.get(\"colormap\", \"Viridis\")\n    clim = rec.get(\"clim\", None)\n    scalar_bar = bool(rec.get(\"scalar_bar\", False))\n\n    style = None\n    show_edges = False\n    if mode == \"Points\":\n        style = \"points\"\n    elif mode == \"Wireframe\":\n        style = \"wireframe\"\n    elif mode == \"Surface with Edges\":\n        show_edges = True\n\n    try:\n        actor = self.plotter.add_mesh(\n            pdata,\n            scalars=scalars,\n            cmap=cmap,\n            clim=clim,\n            style=style,\n            show_edges=show_edges or bool(rec.get(\"edge_visibility\", False)),\n            edge_color=tuple(rec.get(\"edge_color\", (0, 0, 0))),\n            opacity=float(rec.get(\"opacity\", 100)) / 100.0,\n            point_size=int(rec.get(\"point_size\", 3)),\n            line_width=int(rec.get(\"line_width\", 1)),\n            lighting=bool(rec.get(\"lighting\", True)),\n            name=rec.get(\"name\", f\"ds{ds}\"),\n            scalar_bar_args={\"title\": rec.get(\"active_scalar_name\", \"\")} if scalar_bar else None,\n            copy_mesh=False,\n            reset_camera=False,\n        )\n        rec[\"actor\"] = actor\n    except Exception:\n        return\n\n    # Solid color fallback (if no scalars)\n    if scalars is None:\n        try:\n            rgb = rec.get(\"solid_color\", (1.0, 1.0, 1.0))\n            if all(isinstance(c, int) for c in rgb):\n                rgb = (rgb[0]/255.0, rgb[1]/255.0, rgb[2]/255.0)\n            actor.prop.color = (float(rgb[0]), float(rgb[1]), float(rgb[2]))\n        except Exception:\n            pass\n\n    try:\n        self.plotter.render()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_mesh_visibility","title":"<code>set_mesh_visibility(dataset_index, visible)</code>","text":"<p>Show or hide a mesh dataset.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_mesh_visibility(self, dataset_index: int, visible: bool) -&gt; None:\n    \"\"\"Show or hide a mesh dataset.\"\"\"\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n    if rec.get(\"kind\") != \"mesh\":\n        return\n    rec[\"visible\"] = bool(visible)\n    actor = rec.get(\"actor_mesh\")\n    if not visible and actor is not None:\n        try:\n            self.plotter.remove_actor(actor)\n        except Exception:\n            pass\n        rec[\"actor_mesh\"] = None\n        try:\n            self.plotter.update()\n        except Exception:\n            pass\n        return\n    if visible and actor is None:\n        try:\n            rec[\"actor_mesh\"] = self._add_mesh_no_bar(\n                rec.get(\"mesh\"),\n                color=rec.get(\"solid_color\", self._solid_fallback),\n                style=\"wireframe\"\n                if rec.get(\"representation\", \"surface\") == \"wireframe\"\n                else \"surface\",\n                opacity=float(rec.get(\"opacity\", 100)) / 100.0,\n            )\n            self.plotter.update()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_normals_color","title":"<code>set_normals_color(dataset_index, r, g, b)</code>","text":"<p>Set uniform color for normals (used only in 'Uniform' style).</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_normals_color(self, dataset_index: int, r: int, g: int, b: int) -&gt; None:\n    \"\"\"Set uniform color for normals (used only in 'Uniform' style).\"\"\"\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n    color = (\n        max(0, min(255, int(r))) / 255.0,\n        max(0, min(255, int(g))) / 255.0,\n        max(0, min(255, int(b))) / 255.0,\n    )\n    rec[\"normals_color\"] = color\n    if rec.get(\"normals_visible\", False) and rec.get(\"normals_style\") == \"Uniform\":\n        self._rebuild_normals_actor(\n            dataset_index,\n            style=\"Uniform\",\n            color=color,\n            percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n            scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n        )\n        try:\n            self.plotter.update()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_normals_fraction","title":"<code>set_normals_fraction(dataset_index, percent)</code>","text":"<p>Set the percentage (1..100) of normals to draw and rebuild if visible.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_normals_fraction(self, dataset_index: int, percent: int) -&gt; None:\n    \"\"\"Set the percentage (1..100) of normals to draw and rebuild if visible.\"\"\"\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n    p = max(1, min(100, int(percent)))\n    rec[\"normals_percent\"] = p\n    if rec.get(\"normals_visible\", False):\n        self._rebuild_normals_actor(\n            dataset_index,\n            style=str(rec.get(\"normals_style\", self._normals_style)),\n            color=tuple(rec.get(\"normals_color\", self._normals_color)),\n            percent=p,\n            scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n        )\n        try:\n            self.plotter.update()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_normals_scale","title":"<code>set_normals_scale(dataset_index, scale)</code>","text":"<p>Set the glyph scale slider value (1..200) and rebuild if visible.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_normals_scale(self, dataset_index: int, scale: int) -&gt; None:\n    \"\"\"Set the glyph scale slider value (1..200) and rebuild if visible.\"\"\"\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n    s = max(1, min(200, int(scale)))\n    rec[\"normals_scale\"] = s\n    if rec.get(\"normals_visible\", False):\n        self._rebuild_normals_actor(\n            dataset_index,\n            style=str(rec.get(\"normals_style\", self._normals_style)),\n            color=tuple(rec.get(\"normals_color\", self._normals_color)),\n            percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n            scale=s,\n        )\n        try:\n            self.plotter.update()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_normals_style","title":"<code>set_normals_style(dataset_index, style)</code>","text":"<p>Set normals color style for a dataset and rebuild if visible.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_normals_style(self, dataset_index: int, style: str) -&gt; None:\n    \"\"\"Set normals color style for a dataset and rebuild if visible.\"\"\"\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n    style = str(style).strip()\n    if style not in (\"Uniform\", \"Axis RGB\", \"RGB Components\"):\n        style = \"Axis RGB\"\n    rec[\"normals_style\"] = style\n    if rec.get(\"normals_visible\", False):\n        self._rebuild_normals_actor(\n            dataset_index,\n            style=style,\n            color=tuple(rec.get(\"normals_color\", self._normals_color)),\n            percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n            scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n        )\n        try:\n            self.plotter.update()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_normals_visibility","title":"<code>set_normals_visibility(dataset_index, visible, scale=None)</code>","text":"<p>Show/hide normals glyphs for a given dataset.</p> <p>This keeps per-dataset state and rebuilds the glyph actor as needed.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_index</code> <code>int</code> <p>Target dataset index.</p> required <code>visible</code> <code>bool</code> <p>True to show normals, False to hide them.</p> required <code>scale</code> <code>float | None</code> <p>Optional legacy float override (kept for backward compat).    If provided, it is mapped to the new integer slider domain (1..200).</p> <code>None</code> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_normals_visibility(self, dataset_index: int, visible: bool, scale: float | None = None) -&gt; None:\n    \"\"\"Show/hide normals glyphs for a given dataset.\n\n    This keeps per-dataset state and rebuilds the glyph actor as needed.\n\n    Args:\n        dataset_index: Target dataset index.\n        visible: True to show normals, False to hide them.\n        scale: Optional legacy float override (kept for backward compat).\n               If provided, it is mapped to the new integer slider domain (1..200).\n    \"\"\"\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n\n    # Hide path\n    if not visible:\n        try:\n            if rec.get(\"actor_normals\") is not None:\n                self.plotter.remove_actor(rec[\"actor_normals\"])\n        except Exception:\n            pass\n        rec[\"actor_normals\"] = None\n        rec[\"normals_visible\"] = False\n        try:\n            self.plotter.update()\n        except Exception:\n            pass\n        return\n\n    # Show path: rebuild regardless of whether the budgeted pdata already carries \"Normals\"\n    # (the builder will source from rec[\"normals_array\"] or full_pdata as needed)\n    pdata = rec.get(\"pdata\")\n\n    # Optional legacy scale override\n    if scale is not None:\n        try:\n            s = int(max(1, min(200, round(float(scale) * 1000.0))))\n            rec[\"normals_scale\"] = s\n        except Exception:\n            pass\n\n    self._rebuild_normals_actor(\n        dataset_index,\n        style=str(rec.get(\"normals_style\", self._normals_style)),\n        color=tuple(rec.get(\"normals_color\", self._normals_color)),\n        percent=int(rec.get(\"normals_percent\", self._normals_percent)),\n        scale=int(rec.get(\"normals_scale\", self._normals_scale)),\n    )\n    rec[\"normals_visible\"] = True\n    try:\n        self.plotter.update()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_point_budget","title":"<code>set_point_budget(percent, dataset_index=None)</code>","text":"<p>Set visible percent for points globally or for a specific dataset.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_point_budget(self, percent: int, dataset_index: int | None = None) -&gt; None:\n    \"\"\"Set visible percent for points globally or for a specific dataset.\"\"\"\n    try:\n        p = int(percent)\n    except Exception:\n        return\n    p = max(1, min(100, p))\n\n    if dataset_index is None:\n        self._view_budget_percent = p\n        for idx, rec in enumerate(self._datasets):\n            if rec.get(\"kind\") != \"points\":\n                continue\n            self.set_point_budget(p, idx)\n        return\n\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n    if rec.get(\"kind\") != \"points\":\n        return\n\n    rec[\"view_percent\"] = p\n    full_pdata = rec.get(\"full_pdata\", rec.get(\"pdata\"))\n    pdata_for_view = self._apply_budget_to_polydata(\n        full_pdata, rec.get(\"has_rgb\", False), p\n    )\n    rec[\"pdata\"] = pdata_for_view\n    actor = rec.get(\"actor_points\")\n    if actor is not None:\n        try:\n            self.plotter.remove_actor(actor)\n        except Exception:\n            pass\n    rec[\"actor_points\"] = None\n    if rec.get(\"visible\", True):\n        rec[\"actor_points\"] = self._add_points_by_mode(\n            pdata_for_view,\n            rec.get(\"has_rgb\", False),\n            rec.get(\"solid_color\", self._solid_fallback),\n            rec.get(\"color_mode\", self._color_mode),\n            rec.get(\"cmap\", self._cmap),\n            rec.get(\"points_as_spheres\", self._points_as_spheres),\n        )\n        actor = rec.get(\"actor_points\")\n        if actor is not None:\n            try:\n                prop = actor.GetProperty()\n                if prop:\n                    prop.SetPointSize(rec.get(\"point_size\", self._point_size))\n            except Exception:\n                pass\n    try:\n        self.plotter.update()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_point_size","title":"<code>set_point_size(size, dataset_index=None)</code>","text":"<p>Set point size globally or for a specific dataset.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_point_size(self, size: int, dataset_index: int | None = None) -&gt; None:\n    \"\"\"Set point size globally or for a specific dataset.\"\"\"\n    try:\n        sz = int(size)\n    except Exception:\n        return\n    if dataset_index is None:\n        self._point_size = sz\n        for idx, rec in enumerate(self._datasets):\n            if rec.get(\"kind\") != \"points\":\n                continue\n            rec[\"point_size\"] = sz\n            actor = rec.get(\"actor_points\")\n            if actor is not None:\n                try:\n                    prop = actor.GetProperty()\n                    if prop:\n                        prop.SetPointSize(sz)\n                except Exception:\n                    pass\n        try:\n            self.plotter.update()\n        except Exception:\n            pass\n        return\n\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n    if rec.get(\"kind\") != \"points\":\n        return\n    rec[\"point_size\"] = sz\n    actor = rec.get(\"actor_points\")\n    if actor is not None:\n        try:\n            prop = actor.GetProperty()\n            if prop:\n                prop.SetPointSize(sz)\n            self.plotter.update()\n        except Exception:\n            pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_points_as_spheres","title":"<code>set_points_as_spheres(enabled)</code>","text":"<p>Toggle rendering style for points and refresh existing actors.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_points_as_spheres(self, enabled: bool) -&gt; None:\n    \"\"\"Toggle rendering style for points and refresh existing actors.\"\"\"\n    self._points_as_spheres = bool(enabled)\n    self._refresh_datasets()\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_points_visibility","title":"<code>set_points_visibility(dataset_index, visible)</code>","text":"<p>Show/hide the points actor for a dataset by removing/adding the actor.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_points_visibility(self, dataset_index: int, visible: bool) -&gt; None:\n    \"\"\"Show/hide the points actor for a dataset by removing/adding the actor.\"\"\"\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n\n    rec[\"visible\"] = bool(visible)\n    try:\n        if not visible:\n            actor = rec.get(\"actor_points\")\n            if actor is not None:\n                try:\n                    self.plotter.remove_actor(actor)\n                except Exception:\n                    pass\n                rec[\"actor_points\"] = None\n            self.plotter.update()\n            return\n\n        # Visible: (re)create from current budgeted pdata\n        pdata_for_view = self._apply_budget_to_polydata(\n            rec.get(\"full_pdata\", rec.get(\"pdata\")),\n            rec.get(\"has_rgb\", False),\n            rec.get(\"view_percent\", 100),\n        )\n        rec[\"pdata\"] = pdata_for_view\n        actor = self._add_points_by_mode(\n            pdata_for_view,\n            bool(rec.get(\"has_rgb\", False)),\n            rec.get(\"solid_color\", self._solid_fallback),\n            rec.get(\"color_mode\", self._color_mode),\n            rec.get(\"cmap\", self._cmap),\n            rec.get(\"points_as_spheres\", self._points_as_spheres),\n        )\n        # Applica la dimensione punti corrente\n        try:\n            if actor is not None:\n                prop = actor.GetProperty()\n                if prop:\n                    prop.SetPointSize(self._point_size)\n        except Exception:\n            pass\n        rec[\"actor_points\"] = actor\n        self.plotter.update()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.set_solid_color","title":"<code>set_solid_color(r, g, b)</code>","text":"<p>Set a solid RGB color on all actors (best-effort).</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_solid_color(self, r: int, g: int, b: int) -&gt; None:\n    \"\"\"Set a solid RGB color on all actors (best-effort).\"\"\"\n    self._solid_color = (r, g, b)\n    self._refresh_datasets()\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.view_axis","title":"<code>view_axis(axis)</code>","text":"<p>Set camera to an orthographic axis view.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> required Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def view_axis(self, axis: str) -&gt; None:\n    \"\"\"Set camera to an orthographic axis view.\n\n    Args:\n        axis: One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".\n    \"\"\"\n    try:\n        if axis == \"+X\":\n            self.plotter.view_xz(negative=False)\n        elif axis == \"-X\":\n            self.plotter.view_xz(negative=True)\n        elif axis == \"+Y\":\n            self.plotter.view_yz(negative=False)\n        elif axis == \"-Y\":\n            self.plotter.view_yz(negative=True)\n        elif axis == \"+Z\":\n            self.plotter.view_xy(negative=False)\n        elif axis == \"-Z\":\n            self.plotter.view_xy(negative=True)\n        # self.plotter.reset_camera()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.view_fit","title":"<code>view_fit()</code>","text":"<p>Fit camera to the bounds of visible datasets only.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def view_fit(self) -&gt; None:\n    \"\"\"Fit camera to the bounds of *visible* datasets only.\"\"\"\n    try:\n        b = self._visible_bounds()\n        if b is None:\n            # Fallback: nothing visible \u2192 default reset\n            try:\n                self.plotter.reset_camera()\n            except Exception:\n                pass\n            return\n\n        ren = getattr(self.plotter, \"renderer\", None)\n        if ren is not None and hasattr(ren, \"ResetCamera\"):\n            # ResetCamera(xmin,xmax,ymin,ymax,zmin,zmax)\n            ren.ResetCamera(b[0], b[1], b[2], b[3], b[4], b[5])\n            try:\n                ren.ResetCameraClippingRange()\n            except Exception:\n                pass\n        else:\n            # Fallback if renderer API is not available\n            self.plotter.reset_camera()\n\n        # Final render\n        try:\n            if hasattr(self.plotter, \"render\"):\n                self.plotter.render()\n            else:\n                self.plotter.update()\n        except Exception:\n            pass\n    except Exception:\n        # Never raise from a UI callback\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3D.view_iso","title":"<code>view_iso(positive=True)</code>","text":"<p>Set an isometric camera preset.</p> <p>Parameters:</p> Name Type Description Default <code>positive</code> <code>bool</code> <p>If True, use a ( +1, +1, +1 ) view direction; if False use a mirrored variant.</p> <code>True</code> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def view_iso(self, positive: bool = True) -&gt; None:\n    \"\"\"Set an isometric camera preset.\n\n    Args:\n        positive: If True, use a ( +1, +1, +1 ) view direction; if False use a mirrored variant.\n    \"\"\"\n    try:\n        if positive:\n            # Keep PyVista's built-in for the \u201c+\u201d preset\n            self.plotter.view_isometric()\n            try:\n                self.plotter.reset_camera_clipping_range()\n            except Exception:\n                pass\n            # Render\n            try:\n                self.plotter.render()\n            except Exception:\n                pass\n        else:\n            # A mirrored isometric direction (you can change to (-1, +1, +1) if you prefer)\n            self._set_camera_iso(direction=(-1.0, -1.0, 1.0))\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder","title":"<code>Viewer3DPlaceholder</code>","text":"<p>               Bases: <code>QFrame</code></p> <p>Placeholder for the 3D viewer area.</p> <p>This placeholder keeps the UI functional when PyVista/VTK is not installed. All public methods are no-op to avoid AttributeError when actions are triggered.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>class Viewer3DPlaceholder(QtWidgets.QFrame):\n    \"\"\"Placeholder for the 3D viewer area.\n\n    This placeholder keeps the UI functional when PyVista/VTK is not installed.\n    All public methods are no-op to avoid AttributeError when actions are triggered.\n    \"\"\"\n\n    def __init__(self, parent=None) -&gt; None:\n        super().__init__(parent)\n        self.setFrameShape(QtWidgets.QFrame.StyledPanel)\n        self.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self._view_budget_percent: int = 100  # on-screen LOD budget, per-dataset\n\n    # --- Camera helpers (no-op) ---\n    def view_fit(self) -&gt; None:\n        \"\"\"No-op fit view.\"\"\"\n        pass\n\n    def view_axis(self, axis: str) -&gt; None:\n        \"\"\"No-op axis view.\n\n        Args:\n            axis: One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".\n        \"\"\"\n        pass\n\n    def view_iso(self, positive: bool = True) -&gt; None:\n        \"\"\"No-op isometric view.\n\n        Args:\n            positive: If True use isometric+, otherwise isometric\u2212.\n        \"\"\"\n        pass\n\n    def invert_view(self) -&gt; None:\n        \"\"\"No-op invert camera direction.\"\"\"\n        pass\n\n    def refresh(self) -&gt; None:\n        \"\"\"No-op refresh renderer.\"\"\"\n        pass\n\n    # --- Display controls (no-op) ---\n    def set_point_size(self, size: int, dataset_index: int | None = None) -&gt; None:\n        \"\"\"No-op set point size.\"\"\"\n        pass\n\n    def set_point_budget(self, percent: int, dataset_index: int | None = None) -&gt; None:\n        \"\"\"No-op set visible points percentage.\"\"\"\n        pass\n\n    def set_color_mode(self, mode: str, dataset_index: int | None = None) -&gt; None:\n        \"\"\"No-op set color mode.\"\"\"\n        pass\n\n    def set_solid_color(self, r: int, g: int, b: int) -&gt; None:\n        \"\"\"No-op set solid RGB color.\n\n        Args:\n            r: Red channel (0\u2013255).\n            g: Green channel (0\u2013255).\n            b: Blue channel (0\u2013255).\n        \"\"\"\n        self._solid_color = (r, g, b)\n        try:\n            self._solid_fallback = (r / 255.0, g / 255.0, b / 255.0)\n        except Exception:\n            self._solid_fallback = (0.78, 0.78, 0.78)\n        self._refresh_datasets()\n\n    def set_colormap(self, name: str, dataset_index: int | None = None) -&gt; None:\n        \"\"\"No-op set colormap name.\"\"\"\n        pass\n\n    def set_dataset_color(self, dataset_index: int, r: int, g: int, b: int) -&gt; None:\n        \"\"\"Set per-dataset solid color and update actor if in Solid mode.\"\"\"\n        try:\n            rec = self._datasets[dataset_index]\n        except Exception:\n            return\n        rgb = (\n            max(0, min(255, r)) / 255.0,\n            max(0, min(255, g)) / 255.0,\n            max(0, min(255, b)) / 255.0,\n        )\n        rec[\"solid_color\"] = rgb\n        if rec.get(\"kind\") == \"mesh\":\n            actor_m = rec.get(\"actor_mesh\")\n            if actor_m is not None:\n                try:\n                    actor_m.GetProperty().SetColor(rgb)\n                    self.plotter.update()\n                except Exception:\n                    pass\n            return\n        mode = getattr(rec, \"color_mode\", getattr(self, \"_color_mode\", \"Normal RGB\")).lower()\n        actor = rec.get(\"actor_points\")\n        if actor is not None and mode.startswith(\"solid\"):\n            try:\n                actor.GetProperty().SetColor(rgb)\n                self.plotter.update()\n                return\n            except Exception:\n                pass\n        # Fallback: ricrea l'attore\n        try:\n            if actor is not None:\n                self.plotter.remove_actor(actor)\n        except Exception:\n            pass\n        rec[\"actor_points\"] = self._add_points_by_mode(\n            rec.get(\"pdata\"),\n            rec.get(\"has_rgb\", False),\n            rec.get(\"solid_color\", self._solid_fallback),\n            rec.get(\"color_mode\", self._color_mode),\n            rec.get(\"cmap\", self._cmap),\n            rec.get(\"points_as_spheres\", self._points_as_spheres),\n        )\n        self.plotter.update()\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.invert_view","title":"<code>invert_view()</code>","text":"<p>No-op invert camera direction.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def invert_view(self) -&gt; None:\n    \"\"\"No-op invert camera direction.\"\"\"\n    pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.refresh","title":"<code>refresh()</code>","text":"<p>No-op refresh renderer.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"No-op refresh renderer.\"\"\"\n    pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.set_color_mode","title":"<code>set_color_mode(mode, dataset_index=None)</code>","text":"<p>No-op set color mode.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_color_mode(self, mode: str, dataset_index: int | None = None) -&gt; None:\n    \"\"\"No-op set color mode.\"\"\"\n    pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.set_colormap","title":"<code>set_colormap(name, dataset_index=None)</code>","text":"<p>No-op set colormap name.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_colormap(self, name: str, dataset_index: int | None = None) -&gt; None:\n    \"\"\"No-op set colormap name.\"\"\"\n    pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.set_dataset_color","title":"<code>set_dataset_color(dataset_index, r, g, b)</code>","text":"<p>Set per-dataset solid color and update actor if in Solid mode.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_dataset_color(self, dataset_index: int, r: int, g: int, b: int) -&gt; None:\n    \"\"\"Set per-dataset solid color and update actor if in Solid mode.\"\"\"\n    try:\n        rec = self._datasets[dataset_index]\n    except Exception:\n        return\n    rgb = (\n        max(0, min(255, r)) / 255.0,\n        max(0, min(255, g)) / 255.0,\n        max(0, min(255, b)) / 255.0,\n    )\n    rec[\"solid_color\"] = rgb\n    if rec.get(\"kind\") == \"mesh\":\n        actor_m = rec.get(\"actor_mesh\")\n        if actor_m is not None:\n            try:\n                actor_m.GetProperty().SetColor(rgb)\n                self.plotter.update()\n            except Exception:\n                pass\n        return\n    mode = getattr(rec, \"color_mode\", getattr(self, \"_color_mode\", \"Normal RGB\")).lower()\n    actor = rec.get(\"actor_points\")\n    if actor is not None and mode.startswith(\"solid\"):\n        try:\n            actor.GetProperty().SetColor(rgb)\n            self.plotter.update()\n            return\n        except Exception:\n            pass\n    # Fallback: ricrea l'attore\n    try:\n        if actor is not None:\n            self.plotter.remove_actor(actor)\n    except Exception:\n        pass\n    rec[\"actor_points\"] = self._add_points_by_mode(\n        rec.get(\"pdata\"),\n        rec.get(\"has_rgb\", False),\n        rec.get(\"solid_color\", self._solid_fallback),\n        rec.get(\"color_mode\", self._color_mode),\n        rec.get(\"cmap\", self._cmap),\n        rec.get(\"points_as_spheres\", self._points_as_spheres),\n    )\n    self.plotter.update()\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.set_point_budget","title":"<code>set_point_budget(percent, dataset_index=None)</code>","text":"<p>No-op set visible points percentage.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_point_budget(self, percent: int, dataset_index: int | None = None) -&gt; None:\n    \"\"\"No-op set visible points percentage.\"\"\"\n    pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.set_point_size","title":"<code>set_point_size(size, dataset_index=None)</code>","text":"<p>No-op set point size.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_point_size(self, size: int, dataset_index: int | None = None) -&gt; None:\n    \"\"\"No-op set point size.\"\"\"\n    pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.set_solid_color","title":"<code>set_solid_color(r, g, b)</code>","text":"<p>No-op set solid RGB color.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Red channel (0\u2013255).</p> required <code>g</code> <code>int</code> <p>Green channel (0\u2013255).</p> required <code>b</code> <code>int</code> <p>Blue channel (0\u2013255).</p> required Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def set_solid_color(self, r: int, g: int, b: int) -&gt; None:\n    \"\"\"No-op set solid RGB color.\n\n    Args:\n        r: Red channel (0\u2013255).\n        g: Green channel (0\u2013255).\n        b: Blue channel (0\u2013255).\n    \"\"\"\n    self._solid_color = (r, g, b)\n    try:\n        self._solid_fallback = (r / 255.0, g / 255.0, b / 255.0)\n    except Exception:\n        self._solid_fallback = (0.78, 0.78, 0.78)\n    self._refresh_datasets()\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.view_axis","title":"<code>view_axis(axis)</code>","text":"<p>No-op axis view.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".</p> required Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def view_axis(self, axis: str) -&gt; None:\n    \"\"\"No-op axis view.\n\n    Args:\n        axis: One of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\".\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.view_fit","title":"<code>view_fit()</code>","text":"<p>No-op fit view.</p> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def view_fit(self) -&gt; None:\n    \"\"\"No-op fit view.\"\"\"\n    pass\n</code></pre>"},{"location":"api/c2f4dt/ui/viewer3d/#c2f4dt.ui.viewer3d.Viewer3DPlaceholder.view_iso","title":"<code>view_iso(positive=True)</code>","text":"<p>No-op isometric view.</p> <p>Parameters:</p> Name Type Description Default <code>positive</code> <code>bool</code> <p>If True use isometric+, otherwise isometric\u2212.</p> <code>True</code> Source code in <code>src/c2f4dt/ui/viewer3d.py</code> <pre><code>def view_iso(self, positive: bool = True) -&gt; None:\n    \"\"\"No-op isometric view.\n\n    Args:\n        positive: If True use isometric+, otherwise isometric\u2212.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/c2f4dt/utils/icons/","title":"c2f4dt.utils.icons","text":""},{"location":"api/c2f4dt/utils/icons/#c2f4dt.utils.icons","title":"<code>c2f4dt.utils.icons</code>","text":""},{"location":"api/c2f4dt/utils/icons/#c2f4dt.utils.icons.icon_path","title":"<code>icon_path(name)</code>","text":"<p>Return absolute path to an icon in the project <code>icons/</code> directory.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Filename of the icon (e.g., '32x32_document-new.png').</p> required <p>Returns:</p> Type Description <code>str</code> <p>Absolute path string. If not found, returns the original name,</p> <code>str</code> <p>allowing Qt to fallback gracefully (useful in dev).</p> Source code in <code>src/c2f4dt/utils/icons.py</code> <pre><code>def icon_path(name: str) -&gt; str:\n    \"\"\"Return absolute path to an icon in the project `icons/` directory.\n\n    Args:\n        name: Filename of the icon (e.g., '32x32_document-new.png').\n\n    Returns:\n        Absolute path string. If not found, returns the original name,\n        allowing Qt to fallback gracefully (useful in dev).\n    \"\"\"\n    # icons folder sits at project root beside c2f4dt/\n    base = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"..\", \"c2f4dt/assets/icons\"))\n    path = os.path.join(base, name)\n    return path if os.path.isfile(path) else name\n</code></pre>"},{"location":"api/c2f4dt/utils/icons/#c2f4dt.utils.icons.qicon","title":"<code>qicon(name)</code>","text":"<p>Convenience to create a QIcon from the project icons folder.</p> Source code in <code>src/c2f4dt/utils/icons.py</code> <pre><code>def qicon(name: str) -&gt; QtGui.QIcon:\n    \"\"\"Convenience to create a QIcon from the project icons folder.\"\"\"\n    return QtGui.QIcon(icon_path(name))\n</code></pre>"},{"location":"api/c2f4dt/utils/io/","title":"c2f4dt.utils.io","text":""},{"location":"api/c2f4dt/utils/io/#c2f4dt.utils.io","title":"<code>c2f4dt.utils.io</code>","text":"<p>Package init.</p>"},{"location":"api/c2f4dt/utils/systeminfo/","title":"c2f4dt.utils.systeminfo","text":""},{"location":"api/c2f4dt/utils/systeminfo/#c2f4dt.utils.systeminfo","title":"<code>c2f4dt.utils.systeminfo</code>","text":""},{"location":"api/c2f4dt/utils/systeminfo/#c2f4dt.utils.systeminfo.disk_usage_percent","title":"<code>disk_usage_percent(path='/')</code>","text":"<p>Return disk usage as (used_GB, free_GB, used_percent).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Filesystem path to query. Defaults to root.</p> <code>'/'</code> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>Tuple containing used space (GB), free space (GB), and used percentage.</p> Source code in <code>src/c2f4dt/utils/systeminfo.py</code> <pre><code>def disk_usage_percent(path: str = \"/\") -&gt; tuple[float, float, float]:\n    \"\"\"Return disk usage as (used_GB, free_GB, used_percent).\n\n    Args:\n        path: Filesystem path to query. Defaults to root.\n\n    Returns:\n        Tuple containing used space (GB), free space (GB), and used percentage.\n    \"\"\"\n    total, used, free = shutil.disk_usage(path)\n    to_gb = lambda b: b / (1024**3)\n    percent = (used / total) * 100 if total else 0.0\n    return to_gb(used), to_gb(free), percent\n</code></pre>"},{"location":"api/c2f4dt/utils/theme/","title":"c2f4dt.utils.theme","text":""},{"location":"api/c2f4dt/utils/theme/#c2f4dt.utils.theme","title":"<code>c2f4dt.utils.theme</code>","text":""},{"location":"api/c2f4dt/utils/theme/#c2f4dt.utils.theme.apply_user_theme","title":"<code>apply_user_theme(window, mode='auto')</code>","text":"<p>Apply light/dark/auto theme.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>QWidget</code> <p>Root widget to theme.</p> required <code>mode</code> <code>str</code> <p>'light', 'dark', or 'auto' (follows system).</p> <code>'auto'</code> Source code in <code>src/c2f4dt/utils/theme.py</code> <pre><code>def apply_user_theme(window: QtWidgets.QWidget, mode: str = \"auto\") -&gt; None:\n    \"\"\"Apply light/dark/auto theme.\n\n    Args:\n        window: Root widget to theme.\n        mode: 'light', 'dark', or 'auto' (follows system).\n    \"\"\"\n    palette = QtGui.QPalette()\n\n    def set_dark(p: QtGui.QPalette) -&gt; None:\n        p.setColor(QtGui.QPalette.Window, QtGui.QColor(45, 45, 45))\n        p.setColor(QtGui.QPalette.WindowText, QtCore.Qt.white)\n        p.setColor(QtGui.QPalette.Base, QtGui.QColor(30, 30, 30))\n        p.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(45, 45, 45))\n        p.setColor(QtGui.QPalette.ToolTipBase, QtCore.Qt.white)\n        p.setColor(QtGui.QPalette.ToolTipText, QtCore.Qt.white)\n        p.setColor(QtGui.QPalette.Text, QtCore.Qt.white)\n        p.setColor(QtGui.QPalette.Button, QtGui.QColor(45, 45, 45))\n        p.setColor(QtGui.QPalette.ButtonText, QtCore.Qt.white)\n        p.setColor(QtGui.QPalette.BrightText, QtCore.Qt.red)\n        p.setColor(QtGui.QPalette.Highlight, QtGui.QColor(38, 79, 120))\n        p.setColor(QtGui.QPalette.HighlightedText, QtCore.Qt.white)\n\n    if mode == \"auto\":\n        # Heuristic: use dark if system uses a dark base color\n        # (Qt doesn't expose a universal dark-mode flag cross-platform)\n        base_lightness = QtWidgets.QApplication.palette().window().color().lightness()\n        if base_lightness &lt; 128:\n            set_dark(palette)\n        else:\n            palette = QtWidgets.QApplication.palette()\n    elif mode == \"dark\":\n        set_dark(palette)\n    else:\n        palette = QtWidgets.QApplication.palette()\n\n    QtWidgets.QApplication.setPalette(palette)\n</code></pre>"},{"location":"api/c2f4dt/utils/io/importers/","title":"c2f4dt.utils.io.importers","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers","title":"<code>c2f4dt.utils.io.importers</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject","title":"<code>ImportedObject</code>  <code>dataclass</code>","text":"<p>Container for imported datasets (point cloud or mesh).</p> Source code in <code>src/c2f4dt/utils/io/importers.py</code> <pre><code>@dataclass\nclass ImportedObject:\n    \"\"\"Container for imported datasets (point cloud or mesh).\"\"\"\n\n    kind: str  # \"points\" | \"mesh\"\n    name: str\n    points: Optional[np.ndarray] = None        # (N, 3) float64\n    colors: Optional[np.ndarray] = None        # (N, 3) float32 in [0,1]\n    intensity: Optional[np.ndarray] = None     # (N,) float32\n    normals: Optional[np.ndarray] = None       # (N, 3) float32 unit vectors\n    faces: Optional[np.ndarray] = None         # (M, 3) int32 (triangles)\n    pv_mesh: Optional[object] = None           # pyvista.PolyData or similar\n    meta: Dict[str, object] = field(default_factory=dict)\n\n    def bounds(self) -&gt; Optional[Tuple[float, float, float, float, float, float]]:\n        \"\"\"Return (xmin, xmax, ymin, ymax, zmin, zmax) if available.\"\"\"\n        if self.points is not None and len(self.points):\n            mins = self.points.min(axis=0)\n            maxs = self.points.max(axis=0)\n            return (\n                float(mins[0]), float(maxs[0]),\n                float(mins[1]), float(maxs[1]),\n                float(mins[2]), float(maxs[2])\n            )\n        if self.pv_mesh is not None and _HAS_PYVISTA:\n            try:\n                return tuple(self.pv_mesh.bounds)  # type: ignore[return-value]\n            except Exception:\n                return None\n        return None\n</code></pre>"},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.colors","title":"<code>colors = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.faces","title":"<code>faces = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.intensity","title":"<code>intensity = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.kind","title":"<code>kind</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.meta","title":"<code>meta = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.normals","title":"<code>normals = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.points","title":"<code>points = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.pv_mesh","title":"<code>pv_mesh = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.ImportedObject.bounds","title":"<code>bounds()</code>","text":"<p>Return (xmin, xmax, ymin, ymax, zmin, zmax) if available.</p> Source code in <code>src/c2f4dt/utils/io/importers.py</code> <pre><code>def bounds(self) -&gt; Optional[Tuple[float, float, float, float, float, float]]:\n    \"\"\"Return (xmin, xmax, ymin, ymax, zmin, zmax) if available.\"\"\"\n    if self.points is not None and len(self.points):\n        mins = self.points.min(axis=0)\n        maxs = self.points.max(axis=0)\n        return (\n            float(mins[0]), float(maxs[0]),\n            float(mins[1]), float(maxs[1]),\n            float(mins[2]), float(maxs[2])\n        )\n    if self.pv_mesh is not None and _HAS_PYVISTA:\n        try:\n            return tuple(self.pv_mesh.bounds)  # type: ignore[return-value]\n        except Exception:\n            return None\n    return None\n</code></pre>"},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.downsample_random","title":"<code>downsample_random(points, percent)</code>","text":"<p>Randomly downsample points to the given percentage.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>(N, 3) float array.</p> required <code>percent</code> <code>float</code> <p>Target percentage in [1, 100].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Indices of selected points (1D int array).</p> Source code in <code>src/c2f4dt/utils/io/importers.py</code> <pre><code>def downsample_random(points: np.ndarray, percent: float) -&gt; np.ndarray:\n    \"\"\"Randomly downsample points to the given percentage.\n\n    Args:\n        points: (N, 3) float array.\n        percent: Target percentage in [1, 100].\n\n    Returns:\n        Indices of selected points (1D int array).\n    \"\"\"\n    if points.size == 0:\n        return np.empty((0,), dtype=np.int64)\n    p = np.clip(percent, 1.0, 100.0) / 100.0\n    n = points.shape[0]\n    k = max(1, int(round(n * p)))\n    idx = np.random.default_rng().choice(n, size=k, replace=False)\n    return np.sort(idx)\n</code></pre>"},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.downsample_voxel_auto","title":"<code>downsample_voxel_auto(points, target_percent)</code>","text":"<p>Voxel-grid downsampling using a simple auto voxel-size heuristic.</p> <p>Heuristic: scala la dimensione del voxel con l'estensione del bounding-box e il fattore di riduzione desiderato. La % risultante \u00e8 approssimata.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>(N, 3) float array.</p> required <code>target_percent</code> <code>float</code> <p>Target percentage in [1, 100].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Indices of representative points (1D int array).</p> Source code in <code>src/c2f4dt/utils/io/importers.py</code> <pre><code>def downsample_voxel_auto(points: np.ndarray, target_percent: float) -&gt; np.ndarray:\n    \"\"\"Voxel-grid downsampling using a simple auto voxel-size heuristic.\n\n    Heuristic: scala la dimensione del voxel con l'estensione del bounding-box e\n    il fattore di riduzione desiderato. La % risultante \u00e8 approssimata.\n\n    Args:\n        points: (N, 3) float array.\n        target_percent: Target percentage in [1, 100].\n\n    Returns:\n        Indices of representative points (1D int array).\n    \"\"\"\n    n = points.shape[0]\n    if n == 0:\n        return np.empty((0,), dtype=np.int64)\n    p = np.clip(target_percent, 1.0, 100.0) / 100.0\n    if p &gt;= 0.999:\n        return np.arange(n, dtype=np.int64)\n\n    mins = points.min(axis=0)\n    maxs = points.max(axis=0)\n    extent = np.maximum(maxs - mins, 1e-9)\n\n    reduction = max(1e-3, 1.0 - p)\n    base = float(extent.max())\n    voxel = base * reduction * 0.02  # 2% bbox @50% riduzione\n    voxel = max(voxel, base * 1e-4)\n\n    q = np.floor((points - mins) / voxel).astype(np.int64)\n    key = (q[:, 0] * 73856093) ^ (q[:, 1] * 19349663) ^ (q[:, 2] * 83492791)\n    order = np.argsort(key, kind=\"mergesort\")\n    key_sorted = key[order]\n    mask = np.concatenate(([True], key_sorted[1:] != key_sorted[:-1]))\n    kept_sorted = order[mask]\n    return np.sort(kept_sorted)\n</code></pre>"},{"location":"api/c2f4dt/utils/io/importers/#c2f4dt.utils.io.importers.import_file","title":"<code>import_file(path)</code>","text":"<p>Import a geometry file into one or more <code>ImportedObject</code>.</p> <p>Auto-detects reader by extension and available backends.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>File path.</p> required <p>Returns:</p> Type Description <code>List[ImportedObject]</code> <p>List of imported objects.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>On unsupported type or missing backend.</p> Source code in <code>src/c2f4dt/utils/io/importers.py</code> <pre><code>def import_file(path: str) -&gt; List[ImportedObject]:\n    \"\"\"Import a geometry file into one or more `ImportedObject`.\n\n    Auto-detects reader by extension and available backends.\n\n    Args:\n        path: File path.\n\n    Returns:\n        List of imported objects.\n\n    Raises:\n        ValueError: On unsupported type or missing backend.\n    \"\"\"\n    p = Path(path)\n    ext = p.suffix.lower()\n\n    if ext in {\".ply\", \".obj\", \".vtp\", \".stl\", \".vtk\", \".gltf\", \".glb\"}:\n        return _import_with_pyvista(p)\n\n    if ext in {\".las\", \".laz\"}:\n        return _import_las(p)\n\n    if ext in {\".e57\"}:\n        return _import_e57(p)\n\n    raise ValueError(f\"Unsupported file type: {ext}\")\n</code></pre>"},{"location":"guide/architecture/","title":"Code Architecture","text":""},{"location":"guide/architecture/#package-layout-indicative","title":"Package layout (indicative)","text":"<pre><code>c2f4dt/\n  ui/             # Qt .ui files and PySide6 widgets for the main application interface\n  viewer/         # Core 3D viewer classes and VTK/PyVista rendering backend\n  plugins/        # Built-in plugins (Cloud2FEM and others)\n  utils/          # Shared helper functions and utilities\n  app/            # Application entry points and high-level orchestration\n  data/           # Assets (icons, styles, default resources)\nexamples/\n  run_app.py      # Minimal launcher\nextensions/       # Optional external extensions (distributed separately)\ntests/            # Unit and integration tests\n</code></pre>"},{"location":"guide/architecture/#plugins","title":"Plugins","text":"<ul> <li>Cloud2FEM is included as a plugin that transforms point clouds into finite element meshes.</li> <li>Additional plugins can extend the viewer with new features (e.g., clustering, import/export, custom visualization).</li> <li>External extensions can be distributed in separate repositories and integrated at runtime.</li> </ul>"},{"location":"guide/architecture/#conventions","title":"Conventions","text":"<ul> <li>Docstrings: Follow Google or NumPy style for clarity.</li> <li>Naming: Use clear names for Qt signals/slots, viewer methods, and plugin entry points.</li> <li>Tests: Add lightweight tests where feasible; include both unit and integration tests.</li> <li>Style: Follow PEP8 guidelines for Python code formatting.</li> <li>Typing: Use type hints consistently for function signatures.</li> <li>Logging: Employ Python\u2019s <code>logging</code> module for runtime information and debugging.</li> <li>Separation of concerns: Maintain modularity by separating UI, core viewer, plugins, and data handling.</li> <li>Testing strategy: Place tests alongside modules or in a dedicated <code>tests/</code> directory; ensure plugin APIs are tested as well.</li> </ul>"},{"location":"guide/code_tree/","title":"Code Tree","text":"<p>This page shows a depth-limited, clickable tree of the <code>c2f4dt</code> package. Links point to corresponding API pages generated at build time.</p> <p>Root: <code>c2f4dt/</code> \u2014 depth \u2264 4 (negative means unlimited)</p> <ul> <li>assets/<ul> <li>icons/<ul> <li>C2F4DT.iconset/</li> </ul> </li> </ul> </li> <li>plugins/<ul> <li>example_display_button/<ul> <li><code>__init__.py</code></li> <li>plugin.py</li> </ul> </li> <li>transform_rt/<ul> <li><code>__init__.py</code></li> <li>plugin.py</li> </ul> </li> <li>units/<ul> <li><code>__init__.py</code></li> <li>plugin.py</li> </ul> </li> <li>vtk_import/<ul> <li><code>__init__.py</code></li> <li>plugin.py</li> </ul> </li> <li><code>__init__.py</code></li> <li>manager.py</li> </ul> </li> <li>scripts/</li> <li>ui/<ul> <li><code>__init__.py</code></li> <li>console.py</li> <li>display_panel.py</li> <li>import_summary_dialog.py</li> <li>viewer3d.py</li> </ul> </li> <li>utils/<ul> <li>io/<ul> <li><code>__init__.py</code></li> <li>importers.py</li> </ul> </li> <li><code>__init__.py</code></li> <li>icons.py</li> <li>systeminfo.py</li> <li>theme.py</li> </ul> </li> <li><code>__init__.py</code></li> <li>app.py</li> <li>main_window.py</li> </ul>"},{"location":"guide/console_guide/","title":"C2F4DT Python Console \u2014 User Guide &amp; Cheat Sheet","text":"<p>The C2F4DT console is a lightweight, Abaqus-style interactive Python terminal built into the UI. It lets you: - Inspect objects in the current scene (viewer, datasets, treeMCTS). - Query VTK/PyVista data (points, cells, arrays). - Batch operations: styling, screenshots, exports. - Run quick scripts with a persistent namespace.</p> <p>Tip: Press TAB for autocompletion. Use Shift+Enter to insert a newline without executing.</p>"},{"location":"guide/console_guide/#quick-start","title":"Quick Start","text":"<ol> <li>Open View \u2192 Console (or the console tab/pane if pinned).</li> <li>At the prompt <code>&gt;&gt;&gt;</code> type Python code and press Enter.</li> <li>Multi-line blocks are supported; continuation prompts use <code>...</code>.</li> <li>Use Up/Down to navigate command history on the current prompt.</li> </ol>"},{"location":"guide/console_guide/#cheat-sheet-tldr","title":"Cheat Sheet (TL;DR)","text":"<pre><code># Get common objects from the live context\nwindow           # MainWindow instance\nviewer = window.viewer3d\nmct              # Current dataset record (dict)\nmcts             # All dataset records (dict[str, dict])\n\n# Current dataset index and record\nds = window._current_dataset_index()\nrec = viewer._datasets[ds]\n\n# Switch representation / color mode\nviewer.set_mesh_representation(ds, \"Surface with Edges\")\nviewer.set_color_mode(\"Solid Color\", ds)\nviewer.set_color_mode(\"PointData/displacement\", ds)  # then choose vector mode in UI\n\n# Change visuals\nviewer.set_mesh_opacity(ds, 60)       # 0..100\nviewer.set_point_size(5, ds)\nviewer.set_line_width(ds, 2)\nviewer.set_edge_visibility(ds, True)\nviewer.set_edge_color(ds, 0, 0, 0)\nviewer.set_scalar_bar_visible(ds, True)\n\n# Fit camera &amp; screenshot\nviewer.view_fit()\nviewer.save_screenshot(\"scene.png\")\n\n# File system magics\n%pwd\n%ls *.vtk\n%cd path/to/data\n%run my_script.py\n%clear\n</code></pre>"},{"location":"guide/console_guide/#keybindings","title":"Keybindings","text":"<ul> <li>Enter: Execute (if the code block is syntactically complete).</li> <li>Shift+Enter: Newline (do not execute).</li> <li>TAB: Autocomplete (popup with names/attributes/keys).</li> <li>Up/Down: Command history (at current prompt).</li> <li>Home/Backspace: Protected before prompt (can\u2019t edit past output).</li> </ul>"},{"location":"guide/console_guide/#supported-magics","title":"Supported \u201cMagics\u201d","text":"<p>The console implements a few IPython-like \u201cmagics\u201d (single-line commands):</p> <ul> <li><code>%pwd</code> \u2014 print current working directory  </li> <li><code>%cd &lt;path&gt;</code> \u2014 change directory (e.g., <code>%cd ../data</code>)  </li> <li><code>%ls [pattern]</code> \u2014 list files (glob pattern, e.g., <code>%ls *.vtk</code>)  </li> <li><code>%run &lt;file.py&gt;</code> \u2014 run a local Python file with access to <code>window/mct/mcts</code> </li> <li><code>%clear</code> \u2014 clear the console buffer</li> </ul> <p>Note: <code>%run</code> calls <code>window._exec_script_file()</code> under the hood, so your script can interact with the live app.</p>"},{"location":"guide/console_guide/#the-live-context","title":"The Live Context","text":"<p>Every time you execute, the console refreshes a persistent namespace that includes:</p> <ul> <li><code>window</code>: the main UI/controller</li> <li><code>viewer3d</code> (via <code>window.viewer3d</code>): the plotter &amp; dataset actors</li> <li><code>mct</code>: the current dataset\u2019s metadata/visual state (dict)</li> <li><code>mcts</code>: the collection of all dataset entries (dict)</li> </ul> <p>This means you can write short, stateful snippets that build on previous ones.</p>"},{"location":"guide/console_guide/#practical-examples","title":"Practical Examples","text":""},{"location":"guide/console_guide/#1-inspect-the-current-scene","title":"1) Inspect the current scene","text":"<pre><code># Inspect current dataset and its arrays\nds = window._current_dataset_index()\nrec = window.viewer3d._datasets[ds]           # internal record\n\n# Prefer the renderable surface (PolyData) for visualization\npdata = rec.get(\"mesh_surface\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n\nprint(\"Dataset keys:\", list(rec.keys()))\nprint(\"n_points =\", getattr(pdata, \"n_points\", None), \" n_cells =\", getattr(pdata, \"n_cells\", None))\nprint(\"PointData arrays:\", list(getattr(pdata, \"point_data\", {}).keys()))\nprint(\"CellData arrays:\",  list(getattr(pdata, \"cell_data\",  {}).keys()))\n</code></pre>"},{"location":"guide/console_guide/#2-extract-a-pointdata-vector-magnitude-to-csv","title":"2) Extract a PointData vector magnitude to CSV","text":"<pre><code>import numpy as np\nimport csv\n\ndef export_point_magnitude(array_name: str, csv_path: str) -&gt; None:\n    # Export the vector magnitude of a PointData array to CSV\n    ds = window._current_dataset_index()\n    rec = window.viewer3d._datasets[ds]\n    src = rec.get(\"mesh_orig\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n    arr = np.asarray(src.point_data[array_name])\n    if arr.ndim != 2 or arr.shape[1] not in (2, 3):\n        raise ValueError(f\"{array_name} is not a 2D vector array\")\n    mag = np.linalg.norm(arr, axis=1)\n\n    with open(csv_path, \"w\", newline=\"\") as f:\n        w = csv.writer(f)\n        w.writerow([\"point_id\", f\"{array_name}_magnitude\"])\n        for i, v in enumerate(mag):\n            w.writerow([i, float(v)])\n\nexport_point_magnitude(\"displacement\", \"displacement_mag.csv\")\nprint(\"Saved: displacement_mag.csv\")\n</code></pre>"},{"location":"guide/console_guide/#3-color-the-mesh-by-displacement-magnitude-from-the-console","title":"3) Color the mesh by displacement magnitude from the console","text":"<pre><code>ds = window._current_dataset_index()\nwindow.viewer3d.set_color_mode(\"PointData/displacement\", ds)\nmct[\"vector_mode\"] = \"Magnitude\"\nmct[\"colormap\"] = \"Viridis\"\nmct[\"invert_lut\"] = False\nwindow.viewer3d.set_scalar_bar_visible(ds, True)\nwindow.viewer3d.view_render()\n</code></pre>"},{"location":"guide/console_guide/#4-batch-toggle-styles-and-take-screenshots","title":"4) Batch toggle styles and take screenshots","text":"<pre><code>from pathlib import Path\n\ndef batch_screenshots(out_dir: str = \"_shots\") -&gt; None:\n    reps = [\"Surface\", \"Surface with Edges\", \"Wireframe\", \"Points\"]\n    Path(out_dir).mkdir(exist_ok=True)\n    ds = window._current_dataset_index()\n\n    for r in reps:\n        window.viewer3d.set_mesh_representation(ds, r)\n        window.viewer3d.view_fit()\n        path = str(Path(out_dir) / f\"{r.replace(' ', '_')}.png\")\n        window.viewer3d.save_screenshot(path)\n        print(\"[saved]\", path)\n\nbatch_screenshots()\n</code></pre>"},{"location":"guide/console_guide/#5-extract-displacement-xyz-to-pandas-optional","title":"5) Extract displacement X/Y/Z to Pandas (optional)","text":"<pre><code>import numpy as np\nimport pandas as pd\n\ndef point_components_to_dataframe(array_name: str) -&gt; \"pd.DataFrame\":\n    ds = window._current_dataset_index()\n    rec = window.viewer3d._datasets[ds]\n    src = rec.get(\"mesh_orig\") or rec.get(\"mesh\") or rec.get(\"pdata\") or rec.get(\"full_pdata\")\n    vec = np.asarray(src.point_data[array_name])\n    if vec.ndim != 2 or vec.shape[1] not in (2, 3):\n        raise ValueError(\"Not a vector array\")\n    cols = [\"X\", \"Y\"] if vec.shape[1] == 2 else [\"X\", \"Y\", \"Z\"]\n    return pd.DataFrame(vec, columns=cols)\n\ndf = point_components_to_dataframe(\"displacement\")\ndf.describe()\n</code></pre>"},{"location":"guide/console_guide/#6-programmatically-edit-appearance","title":"6) Programmatically edit appearance","text":"<pre><code>def set_pretty_style(ds: int) -&gt; None:\n    viewer = window.viewer3d\n    viewer.set_mesh_representation(ds, \"Surface with Edges\")\n    viewer.set_mesh_opacity(ds, 100)\n    viewer.set_edge_visibility(ds, True)\n    viewer.set_edge_color(ds, 0, 0, 0)\n    viewer.set_point_size(3, ds)\n    viewer.set_line_width(ds, 1)\n    viewer.view_fit()\n    viewer.view_render()\n\nset_pretty_style(window._current_dataset_index())\n</code></pre>"},{"location":"guide/console_guide/#data-mapping-notes","title":"Data Mapping Notes","text":"<p>C2F4DT renders non-PolyData inputs (e.g., <code>UnstructuredGrid</code>) via an extracted surface. PointData arrays are mapped using:</p> <ol> <li><code>vtkOriginalPointIds</code></li> <li>KDTree nearest neighbor (if SciPy installed)</li> <li>Pass-through if sizes match</li> </ol>"},{"location":"guide/console_guide/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>No colors / white mesh \u2192 choose a valid array in \u201cColor by\u201d  </li> <li>LUT not working \u2192 install matplotlib (<code>pip install matplotlib</code>)  </li> <li>Mapping fails \u2192 install SciPy (<code>pip install scipy</code>)  </li> </ul>"},{"location":"guide/console_guide/#appendix-minimal-api-reference","title":"Appendix: Minimal API Reference","text":"<ul> <li><code>window._current_dataset_index()</code> </li> <li><code>viewer3d.set_mesh_representation(ds, mode)</code> </li> <li><code>viewer3d.set_color_mode(mode, ds)</code> </li> <li><code>viewer3d.set_scalar_bar_visible(ds, on: bool)</code> </li> <li><code>viewer3d.set_mesh_opacity(ds, value: int)</code> </li> <li><code>viewer3d.set_point_size(value: int, ds)</code> </li> <li><code>viewer3d.set_line_width(ds, value: int)</code> </li> <li><code>viewer3d.set_edge_visibility(ds, on: bool)</code> </li> <li><code>viewer3d.set_edge_color(ds, r, g, b)</code> </li> <li><code>viewer3d.view_fit()</code>, <code>viewer3d.view_render()</code>, <code>viewer3d.save_screenshot(path)</code></li> </ul>"},{"location":"guide/console_guide/#changelog-credits","title":"Changelog &amp; Credits","text":"<p>This guide corresponds to the version where: - PointData \u2192 surface mapping was added (via <code>vtkOriginalPointIds</code> + KDTree fallback). - LUT normalization and scalar array robustness were improved.</p>"},{"location":"guide/flowchart/","title":"Flowchart","text":""},{"location":"guide/flowchart/#flowchart-of-main-components","title":"Flowchart of main components","text":"<p>The following Mermaid flowchart illustrates the main components and data flow within the C2F4DT application. C2F4DT acts as a viewer and plugin host. The diagram shows GUI elements, data input/output, processing steps, data models, grid and FEM generation, visualization overlays, and optional tools. Cloud2FEM is represented as a built-in plugin extending these capabilities.</p> <p>```mermaid flowchart TD   %% Grouped by responsibility   subgraph \"GUI / UX\"     A1[\"Main Window (PySide6) \u2014 c2f4dt.main_window\"]     A2[\"3D Viewer (PyVista/VTK) \u2014 c2f4dt.ui.viewer3d\"]     A3[\"2D Slice Window \u2014 c2f4dt.ui.display_panel\"]   end</p> <p>subgraph \"I/O\"     B1[\"Point Cloud Import/Export \u2014 c2f4dt.utils.io.importers\"]     B2[\"Boundary Conditions Export \u2014 c2f4dt.plugins.cloud2fem (BCs)\"]   end</p> <p>subgraph \"Data Model\"     C1[\"TwinState / SliceSet / Slice \u2014 c2f4dt.plugins.cloud2fem.model\"]     C2[\"Materials &amp; Boundary Conditions \u2014 c2f4dt.plugins.cloud2fem.model\"]   end</p> <p>subgraph \"Processing\"     D1[\"Create Slices \u2014 c2f4dt.plugins.cloud2fem.slices\"]     D2[\"Centroid &amp; Feature Extraction \u2014 c2f4dt.plugins.cloud2fem.geometry\"]     D3[\"Normals Estimation \u2014 c2f4dt.plugins.cloud2fem.normals\"]   end</p> <p>subgraph \"Grid &amp; FEM\"     E1[\"Grid Model \u2014 c2f4dt.plugins.cloud2fem.grid_model\"]     E2[\"FEM Generation / Export \u2014 c2f4dt.plugins.cloud2fem (FEM)\"]   end</p> <p>subgraph \"Visualization\"     F1[\"2D Overlays (Points / Labels) \u2014 c2f4dt.ui.display_panel\"]     F2[\"3D Overlays (Points / Labels) \u2014 c2f4dt.ui.viewer3d\"]   end</p> <p>subgraph \"Optional Tools\"     G1[\"Additional Utilities / Plugins \u2014 c2f4dt.plugins.*\"]   end   ```</p> <p><code>mermaid   A1 --&gt;|Open / Load| B1   B1 --&gt;|NDArray + Channels| C1   A1 --&gt;|Slice Parameters| D1   D1 --&gt;|SliceSet| C1   D1 --&gt;|Indices per Slice| D2   D2 --&gt;|Centroids / Polylines / Polygons| C1   A1 --&gt;|Compute Normals| D3   D3 --&gt;|Normals Channel| C1   C1 --&gt;|Slice Polygons| E1   E1 --&gt;|Slice-Aligned Grid| E2   C2 --&gt;|Attach BCs| E2   C2 --&gt;|Export BCs| B2   C1 --&gt;|Derived Layers| A2   F1 --&gt;|Points / Legend| A2   F2 --&gt;|3D Points / Legend| A2   A1 --&gt;|Open 2D View| A3   C1 --&gt;|Slice Layers| A3   G1 --&gt;|Optional Utilities| A1</code>mermaid</p>"},{"location":"guide/gui_layout/","title":"C2F4DT \u2014 GUI Layout (Qt Object Names)","text":"<p>This document provides a structured overview of the main GUI elements in C2F4DT, focusing on Qt <code>objectName</code>s to assist developers when wiring widgets, signals, and extensions.</p>"},{"location":"guide/gui_layout/#c2f4dt-gui-layout-tree-view","title":"C2F4DT \u2014 GUI Layout (Tree View)","text":"<pre><code>MainWindow (QMainWindow)\n\u2502\n\u251c\u2500\u2500 Menu bar (menubar)\n\u2502\n\u251c\u2500\u2500 Toolbars\n\u2502   \u251c\u2500\u2500 barTOPCOMMAND              # Top horizontal toolbar\n\u2502   \u251c\u2500\u2500 barVERTICALCOMMAND_left    # Left vertical toolbar\n\u2502   \u251c\u2500\u2500 barVERTICALCOMMAND_right   # Right vertical toolbar\n\u2502   \u2514\u2500\u2500 barVIEWER3D                # Small toolbar inside 3D viewer\n\u2502\n\u251c\u2500\u2500 Central area\n\u2502   \u251c\u2500\u2500 tabMain (QTabWidget)            # Main tab container\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 tabDisplay (QWidget)            # Tab: Display\n\u2502   \u2502   \u2514\u2500\u2500 scrollDISPLAY_CONTENT       # Scrollable content area for Display\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 tabSLICING (QWidget)            # Tab: Slices\n\u2502   \u2502   \u2514\u2500\u2500 scrollSLICING_CONTENT       # Scrollable content area for Slices\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 tabFEM (QWidget)                # Tab: FEM / Mesh\n\u2502   \u2502   \u2514\u2500\u2500 scrollFEM_CONTENT           # Scrollable content area for FEM\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 tabRESULTS (QWidget)            # Tab: Results\n\u2502   \u2502   \u2514\u2500\u2500 scrollRESULTS_CONTENT       # Scrollable content area for Results\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 tabINSPECTOR (QWidget)          # Tab: Inspector / Tree\n\u2502   \u2502   \u2514\u2500\u2500 treeMCT (QTreeWidget)       # Main MCT tree\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 tabCONSOLE (QTabWidget)         # Console tab (can host multiple pages)\n\u2502       \u2514\u2500\u2500 (page \"Console\") \u2192 layout with custom console widget\n\u2502\n\u251c\u2500\u2500 3D Viewer Panel\n\u2502   \u2514\u2500\u2500 VIEWER3D (QWidget, QVBoxLayout)\n\u2502       \u251c\u2500\u2500 barVIEWER3D (QToolBar)      # Viewer toolbar\n\u2502       \u2514\u2500\u2500 (placeholder \u2192 replaced by QtInteractor for PyVista)\n\u2502\n\u251c\u2500\u2500 Secondary Trees / Data\n\u2502   \u2514\u2500\u2500 treeMCTS (QTreeWidget)          # Optional: second dataset tree\n\u2502\n\u251c\u2500\u2500 Status bar area\n\u2502   \u251c\u2500\u2500 barPROGRESS (QProgressBar)      # Progress indicator\n\u2502   \u2514\u2500\u2500 buttonCANCEL (QPushButton)      # Cancel action\n\u2502\n\u2514\u2500\u2500 Messages\n    \u2514\u2500\u2500 txtMessages (QPlainTextEdit)    # Log / messages output\n</code></pre>"},{"location":"guide/gui_layout/#1-main-window-structure","title":"1. Main Window Structure","text":"<ul> <li>QMainWindow</li> <li>Top toolbar \u2192 <code>barTOPCOMMAND</code></li> <li>Left vertical toolbar \u2192 <code>barVERTICALCOMMAND_left</code></li> <li>Right vertical toolbar \u2192 <code>barVERTICALCOMMAND_right</code></li> <li>Viewer 3D area \u2192 <code>VIEWER3D</code><ul> <li>Contains toolbar \u2192 <code>barVIEWER3D</code></li> </ul> </li> <li>Message log \u2192 <code>txtMessages</code></li> <li>Progress bar \u2192 <code>barPROGRESS</code></li> <li>Cancel button \u2192 <code>buttonCANCEL</code></li> <li>Tabs (main) \u2192 <code>tabMain</code></li> </ul>"},{"location":"guide/gui_layout/#2-tab-pages-and-containers","title":"2. Tab Pages and Containers","text":"<ul> <li>Display tab \u2192 <code>tabDisplay</code></li> <li>Scroll container: <code>scrollDISPLAY_CONTENT</code></li> <li>Slices tab \u2192 <code>tabSLICING</code></li> <li>Scroll container: <code>scrollSLICING_CONTENT</code></li> <li>FEM tab \u2192 <code>tabFEM</code></li> <li>Scroll container: <code>scrollFEM_CONTENT</code></li> <li>Results tab \u2192 <code>tabRESULTS</code></li> <li>Scroll container: <code>scrollRESULTS_CONTENT</code></li> <li>Inspector tab \u2192 <code>tabINSPECTOR</code></li> <li>Tree widget: <code>treeMCT</code></li> <li>Console tab \u2192 <code>tabCONSOLE</code></li> <li>Replaces placeholder with console widget</li> <li>MCTS tab \u2192 <code>tabMCTS</code></li> <li>Tree widget: <code>treeMCTS</code></li> </ul>"},{"location":"guide/gui_layout/#3-actions-and-menus","title":"3. Actions and Menus","text":"<ul> <li>File:</li> <li><code>actionNew</code>, <code>actionOpen</code>, <code>actionSave</code>, <code>actionSaveAs</code></li> <li>Import cloud:</li> <li><code>actionImportCloud</code></li> <li>Grid tools:</li> <li><code>actionCreateGrid</code>, <code>actionToggleGrid</code></li> <li>Normals:</li> <li><code>actionToggleNormals</code></li> <li>Tab navigation:</li> <li><code>actionOpen_Display_Tab</code></li> <li><code>actionOpen_Slices_Tab</code></li> <li><code>actionOpen_FEM_Tab</code></li> <li><code>actionOpen_Inspector_Tab</code></li> <li><code>actionOpen_2dView</code></li> </ul>"},{"location":"guide/gui_layout/#4-slice-visualization-actions","title":"4. Slice Visualization Actions","text":"<ul> <li><code>toggle_current_slice_3D_view</code></li> <li><code>toggle_all_slices_3D_view</code></li> <li><code>toggle_centroids_view</code></li> <li><code>toggle_polylines_view</code></li> <li><code>toggle_polygons_view</code></li> <li><code>toggle_mesh_view</code></li> </ul>"},{"location":"guide/gui_layout/#abbreviated-map-cheat-sheet","title":"Abbreviated Map (Cheat Sheet)","text":"Area Object name(s) Top toolbar <code>barTOPCOMMAND</code> Left toolbar <code>barVERTICALCOMMAND_left</code> Right toolbar <code>barVERTICALCOMMAND_right</code> Viewer container <code>VIEWER3D</code> Viewer toolbar <code>barVIEWER3D</code> Message editor <code>txtMessages</code> Progress bar <code>barPROGRESS</code> Cancel button <code>buttonCANCEL</code> Tabs root <code>tabMain</code> Display container <code>scrollDISPLAY_CONTENT</code> Slicing container <code>scrollSLICING_CONTENT</code> FEM container <code>scrollFEM_CONTENT</code> Results container <code>scrollRESULTS_CONTENT</code> Inspector tree <code>treeMCT</code> MCTS tree <code>treeMCTS</code> Console tab <code>tabCONSOLE</code>"},{"location":"guide/gui_layout/#quick-reference-for-slice-tools","title":"Quick reference for slice tools:","text":"<ul> <li>Current slice overlay: <code>toggle_current_slice_3D_view</code></li> <li>All slices overlay: <code>toggle_all_slices_3D_view</code></li> <li>Centroids: <code>toggle_centroids_view</code></li> <li>Polylines: <code>toggle_polylines_view</code></li> <li>Polygons: <code>toggle_polygons_view</code></li> <li>Mesh: <code>toggle_mesh_view</code></li> </ul>"},{"location":"guide/installation/","title":"Installation and Setup","text":""},{"location":"guide/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: Version 3.11 or later.</li> <li>IDE: Visual Studio Code is recommended.</li> <li>Git: Either Git (command line) or GitHub Desktop.</li> </ul>"},{"location":"guide/installation/#creating-a-virtual-environment-in-vs-code","title":"Creating a Virtual Environment in VS Code","text":"<ol> <li>Open the C2F4DT folder in VS Code.</li> <li>Open the terminal (`Ctrl+``).</li> <li>Create a virtual environment:   <pre><code>python -m venv venv_c2f4dt\n</code></pre></li> <li>Activate the environment:</li> <li>On macOS/Linux:     <pre><code>source venv_c2f4dt/bin/activate\n</code></pre></li> <li>On Windows:     <pre><code>venv_c2f4dt\\Scripts\\activate\n</code></pre></li> </ol> <p>VS Code should auto-detect the <code>venv_c2f4dt</code>. If not, select it manually (<code>Python: Select Interpreter</code>).</p>"},{"location":"guide/installation/#installing-packages","title":"Installing Packages","text":"<p>Once the environment is active, install dependencies: <pre><code>pip install --upgrade pip\npip install -r requirements.txt\n</code></pre></p>"},{"location":"guide/installation/#activating-in-regular-or-development-mode","title":"Activating in Regular or Development Mode","text":""},{"location":"guide/installation/#regular-mode","title":"Regular Mode","text":"<p>To activate the application in regular mode, run: <pre><code>pip install .\n</code></pre></p>"},{"location":"guide/installation/#development-mode","title":"Development Mode","text":"<p>For development mode, which includes additional tools and dependencies for development, run: <pre><code>pip install -e .[dev]\n</code></pre></p> <p>You can also activate in user mode (without requiring administrative privileges): <pre><code>pip install --user .\n</code></pre></p>"},{"location":"guide/installation/#running-the-application","title":"Running the Application","text":"<ul> <li>To launch the main app:   <pre><code>python main.py\n</code></pre></li> <li>Or run example scripts:   <pre><code>python examples/run_app.py\n</code></pre></li> </ul>"},{"location":"guide/installation/#version-control-with-git","title":"Version Control with Git","text":""},{"location":"guide/installation/#cloning-the-repository","title":"Cloning the Repository","text":"<pre><code>git clone https://github.com/gcastellazzi/C2F4DT.git\ncd C2F4DT\n</code></pre> <p>If using GitHub Desktop, choose \u201cClone repository\u201d and paste the repo URL.</p>"},{"location":"guide/installation/#creating-a-branch","title":"Creating a Branch","text":"<p>Always create a feature branch before editing: <pre><code>git checkout -b feature/my-change\n</code></pre></p>"},{"location":"guide/installation/#making-commits","title":"Making Commits","text":"<ul> <li>Keep commits small and focused.</li> <li>Use descriptive messages:   <pre><code>git commit -m \"fix: corrected normals orientation in slice viewer\"\n</code></pre></li> <li>Do not commit:</li> <li><code>venv_c2f4dt/</code></li> <li>large datasets</li> <li>build artifacts</li> </ul> <p>Make sure <code>.gitignore</code> includes <code>venv_c2f4dt/</code>, <code>__pycache__/</code>, and <code>site/</code>.</p>"},{"location":"guide/installation/#pushing-changes","title":"Pushing Changes","text":"<pre><code>git push origin feature/my-change\n</code></pre> <p>Then open a Pull Request on GitHub.</p>"},{"location":"guide/overview/","title":"Overview","text":"<p>This guide describes project goals, scope, and current status.</p> <ul> <li>Repository: <code>C2F4DT</code></li> <li>Python package: <code>c2f4dt</code></li> <li>Viewer: PyVista/VTK + PySide6</li> <li>Scope: point-cloud import, slicing, inspection, GUI, and plugin-based FEM workflows</li> </ul>"},{"location":"guide/overview/#project-goals-and-significance","title":"Project Goals and Significance","text":"<p>C2F4DT is designed as a core viewer and host framework that enables the integration and execution of specialized plugins for finite element method (FEM) analysis and related workflows. It provides a flexible and user-friendly environment to import, slice, inspect, and visualize complex 3D point-cloud data, while supporting extensible plugins such as Cloud2FEM for FEM model generation.</p> <p>Key goals include:</p> <ul> <li>Developing a robust core framework for processing and slicing large-scale point clouds.</li> <li>Integrating advanced visualization tools for inspection and validation of data.</li> <li>Providing a graphical user interface (GUI) that simplifies interaction with the viewer and plugins.</li> <li>Supporting extensibility through a plugin architecture that includes FEM workflows like Cloud2FEM.</li> </ul> <p>The significance of C2F4DT lies in its ability to serve as a versatile platform bridging raw 3D scanning data and engineering simulations, facilitating more accurate and efficient structural assessments and designs through modular plugins.</p>"},{"location":"guide/overview/#scope","title":"Scope","text":"<ul> <li>Importing and managing diverse point-cloud datasets.</li> <li>Implementing slicing algorithms to extract meaningful cross-sections.</li> <li>Enabling detailed inspection and visualization through PyVista and VTK.</li> <li>Integrating a GUI based on PySide6 for enhanced user experience.</li> <li>Providing a plugin infrastructure to support FEM-ready model generation and other workflows.</li> </ul>"},{"location":"guide/overview/#relevant-published-works","title":"Relevant Published Works","text":"<p>Cloud2FEMi builds upon a series of foundational methodologies developed and published by Castellazzi and colleagues:</p> <ul> <li>Cloud2FEM: A finite element mesh generator based on point clouds of existing/historical structures. Castellazzi, G., et al. (2022). SoftwareX.</li> <li>An innovative numerical modeling strategy for the structural analysis of historical monumental buildings. Castellazzi, G., et al. (2017). Engineering Structures.</li> <li>From Laser Scanning to Finite Element Analysis of Complex Buildings by Using a Semi-Automatic Procedure. Castellazzi, G., et al. (2015). Sensors.</li> </ul> <p>These works establish the theoretical and practical background for the techniques implemented in Cloud2FEMi.</p>"},{"location":"guide/overview/#note","title":"Note","text":"<p>C2F4DT provides the core viewer and plugin infrastructure, with Cloud2FEM integrated as one of the key plugins enabling FEM workflows. This modular approach enhances usability, flexibility, and accessibility for researchers and practitioners in the field.</p> <p>Project status</p> <p>Under development - not a stable release.</p>"},{"location":"guide/plugins_developer_guide/","title":"C2F4DT \u2014 Plugin/Extensions Developer Guide","text":"<p>This guide shows how to build drop-in extensions for C2F4DT without modifying <code>main_window.py</code>. Extensions live in the <code>./extensions/</code> folder and are loaded automatically at startup. The Cloud2FEM plugin is included as an example, but the framework is designed for any plugin or extension.</p>"},{"location":"guide/plugins_developer_guide/#tldr","title":"TL;DR","text":"<ul> <li>Create a folder under <code>extensions/your_plugin/</code></li> <li>Add a small <code>extension.json</code> manifest</li> <li>Provide a Python module with a factory <code>create_extension()</code> that returns an object implementing:</li> <li><code>name: str</code>, <code>version: str</code></li> <li><code>activate(ctx: HostContext) -&gt; None</code></li> <li><code>deactivate() -&gt; None</code></li> </ul>"},{"location":"guide/plugins_developer_guide/#1-folder-layout","title":"1) Folder layout","text":"<pre><code>extensions/\n  your_plugin/\n    extension.json\n    __init__.py\n    your_plugin.py\n</code></pre> <p>Example <code>extension.json</code>: <pre><code>{\n  \"name\": \"My Plugin\",\n  \"package\": \"your_plugin\",\n  \"entry\": \"create_extension\",\n  \"version\": \"1.0.0\",\n  \"requires_api\": \"1.0\"\n}\n</code></pre></p> <ul> <li><code>package</code>: python module (filename without <code>.py</code>)</li> <li><code>entry</code>: factory function returning the extension instance</li> <li><code>requires_api</code>: host API version your plugin expects</li> </ul>"},{"location":"guide/plugins_developer_guide/#2-host-api-what-you-get","title":"2) Host API (what you get)","text":"<p>Extensions receive a <code>HostContext</code> at <code>activate()</code>:</p> <pre><code>from dataclasses import dataclass\nfrom typing import Any\n\n@dataclass\nclass HostContext:\n    window: Any                 # MainWindow (QMainWindow)\n    registry: dict[str, Any]    # Shared services registry\n    add_tab: callable           # add_tab(title, widget, target=\"main\")\n    log: callable               # log(level, message)\n</code></pre> <p>(In the current codebase, <code>HostContext</code> is defined in <code>c2f4dt.plugins.manager</code> and re-used by plugins.)</p> <ul> <li>Use <code>ctx.add_tab(widget_title, widget, target=\"main\")</code> to add whole tabs to <code>tabMain</code>.</li> <li>Access existing content panels with:</li> <li><code>scrollDISPLAY_CONTENT</code>, <code>scrollSLICING_CONTENT</code>, <code>scrollFEM_CONTENT</code>, <code>scrollRESULTS_CONTENT</code></li> <li>Store persistent UI prefs in <code>ctx.window.view_opts</code> (a dict), e.g., <code>view_opts[\"slice_point_size\"]</code>.</li> </ul> <p>Stability: the host exposes <code>APP_PLUGIN_API_VERSION</code> to gate incompatible plugins.</p>"},{"location":"guide/plugins_developer_guide/#3-minimal-plugin-template","title":"3) Minimal plugin template","text":"<pre><code># extensions/your_plugin/your_plugin.py\nfrom __future__ import annotations\nfrom typing import Optional\nfrom PySide6 import QtWidgets\nfrom c2f4dt.plugins.manager import HostContext\n\nclass MyPlugin:\n    name = \"My Plugin\"\n    version = \"1.0.0\"\n\n    def __init__(self):\n        self._ctx: Optional[HostContext] = None\n        self._panel: Optional[QtWidgets.QGroupBox] = None\n\n    def activate(self, ctx: HostContext) -&gt; None:\n        self._ctx = ctx\n        ctx.log(\"INFO\", \"Activating My Plugin\")\n\n        # 1) Create UI\n        container = ctx.window.findChild(QtWidgets.QWidget, \"scrollDISPLAY_CONTENT\")\n        if container is None:\n            ctx.log(\"WARN\", \"scrollDISPLAY_CONTENT not found\")\n            return\n\n        self._panel = QtWidgets.QGroupBox(\"My Plugin Panel\", container)\n        form = QtWidgets.QFormLayout(self._panel)\n\n        btn = QtWidgets.QPushButton(\"Do something\", self._panel)\n        btn.clicked.connect(self._on_click)\n        form.addRow(btn)\n\n        # 2) Mount into the panel container\n        lay = container.layout() or QtWidgets.QVBoxLayout(container)\n        lay.addWidget(self._panel)\n\n    def deactivate(self) -&gt; None:\n        if self._ctx and self._panel:\n            self._panel.setParent(None)\n            self._panel.deleteLater()\n        self._panel = None\n        self._ctx = None\n\n    def _on_click(self):\n        self._ctx.log(\"INFO\", \"Button clicked!\")\n\ndef create_extension():\n    return MyPlugin()\n</code></pre> <p>Prefer embedding controls inside existing <code>scrollXXX_CONTENT</code> containers for a cohesive UX. Use <code>ctx.add_tab(...)</code> if your feature needs a dedicated full tab.</p>"},{"location":"guide/plugins_developer_guide/#4-ui-targets-object-names","title":"4) UI targets &amp; object names","text":"<p>Common insertion points (object names):</p> <ul> <li>Display: <code>scrollDISPLAY_CONTENT</code></li> <li>Slices: <code>scrollSLICING_CONTENT</code></li> <li>FEM: <code>scrollFEM_CONTENT</code></li> <li>Results: <code>scrollRESULTS_CONTENT</code></li> </ul> <p>Adding toolbar actions is allowed (use <code>ctx.window.menuBar()</code> or find toolbars by name), but keep toolbar minimal and consistent.</p>"},{"location":"guide/plugins_developer_guide/#5-reading-setting-view-options","title":"5) Reading &amp; setting view options","text":"<p>Use <code>ctx.window.view_opts</code> to store simple preferences:</p> <pre><code>v = getattr(ctx.window, \"view_opts\", {}) or {}\nv[\"myplugin_threshold\"] = 0.25\nctx.window.view_opts = v\n</code></pre> <p>Renderers (3D viewer, etc.) can read those values to affect visualization. Example keys used by the Slices visualization extension:</p> <ul> <li><code>slice_point_size</code> / <code>slice_point_color</code> (all slices)</li> <li><code>slice_current_point_size</code> / <code>slice_current_point_color</code> (current slice)</li> </ul>"},{"location":"guide/plugins_developer_guide/#6-integrating-with-existing-logic-optional","title":"6) Integrating with existing logic (optional)","text":"<p>If you need to sync with host behavior, you can look up helpful widgets or actions:</p> <ul> <li><code>cbSliceIndex</code> (<code>QComboBox</code>): current slice index</li> <li><code>toggle_current_slice_3D_view</code> / <code>toggle_all_slices_3D_view</code> (<code>QAction</code>)</li> </ul> <p>Prefer host-agnostic logic; call internal helpers only when necessary and available.</p>"},{"location":"guide/plugins_developer_guide/#7-logging-messages","title":"7) Logging &amp; messages","text":"<ul> <li>Use <code>ctx.log(\"INFO\", \"message\")</code> for plugin logs.</li> <li>For user-facing messages, use the host\u2019s message area:   <pre><code>txt = ctx.window.findChild(QtWidgets.QPlainTextEdit, \"txtMessages\")\nif txt:\n    txt.appendPlainText(\"[MyPlugin] Something happened\u2026\")\n</code></pre></li> </ul>"},{"location":"guide/plugins_developer_guide/#8-versioning-compatibility","title":"8) Versioning &amp; compatibility","text":"<ul> <li>Set <code>requires_api</code> in <code>extension.json</code>.</li> <li>When the host bumps <code>APP_PLUGIN_API_VERSION</code>, incompatible plugins are skipped.</li> <li>Keep your plugin\u2019s <code>version</code> in sync with your changes.</li> </ul>"},{"location":"guide/plugins_developer_guide/#9-testing-checklist","title":"9) Testing checklist","text":"<ul> <li> No crashes if target containers are missing (fail gracefully).</li> <li> No global state required; clean up in <code>deactivate()</code>.</li> <li> Works with/without a loaded point cloud.</li> <li> Honors dark theme where possible (avoid hard-coded colors).</li> <li> No blocking calls on the UI thread for long operations.</li> </ul>"},{"location":"guide/plugins_developer_guide/#10-packaging-distribution","title":"10) Packaging &amp; distribution","text":"<ul> <li>Ship your plugin folder (<code>your_plugin/</code>) as a zip; users unzip into <code>./extensions/</code>.</li> <li>Avoid heavy dependencies; if needed, handle absence gracefully.</li> <li>Keep names unique to avoid clashes.</li> </ul>"},{"location":"guide/plugins_developer_guide/#11-advanced-tips","title":"11) Advanced tips","text":"<ul> <li>Hot reload (dev): add a host command to call <code>plugin_manager.unload_all(); plugin_manager.load_all()</code>.</li> <li>Shared services: use <code>ctx.registry</code> to publish/reuse services between plugins.</li> <li>Targeted tabs: the host\u2019s <code>add_tab</code> supports <code>target=\"main\"</code> and can be extended for additional tab stacks.</li> </ul>"},{"location":"guide/reference/","title":"Project Group","text":"<p>Principal Investigator: Giovanni Castellazzi Affiliations: Associate Professor in Solids and Structural Mechanics, DICAM \u2014 University of Bologna Email: giovanni.castellazzi@unibo.it</p> Collaborators Affiliations Giovanni Castellazzi Solids and Structural Mechanics, DICAM \u2014 University of Bologna Stefano de Miranda Solids and Structural Mechanics, DICAM \u2014 University of Bologna Antonio Maria D'Altri Solids and Structural Mechanics, DICAM \u2014 University of Bologna Francesco Ubertini Solids and Structural Mechanics, DICAM \u2014 University of Bologna Nicol\u00f2 Lo Presti PhD Student, DICAM \u2014 University of Bologna Kaj Kolodziej Master Student, University of Bologna Former Collaborators Gabriele Bitelli Geomatics, DICAM \u2014 University of Bologna Alessandro Lambertini Geomatics, DICAM \u2014 University of Bologna"},{"location":"guide/reference/#report-a-problem-bug","title":"Report a Problem / Bug","text":"<p>Preferred channel: GitHub Issues (recommended for tracking &amp; transparency) Alternative: Email support (for private data or access\u2011restricted material)</p>"},{"location":"guide/reference/#1-via-github-issues","title":"1) Via GitHub Issues","text":""},{"location":"guide/reference/#recommended-method-for-reporting-problems","title":"Recommended Method for Reporting Problems","text":"<p>The preferred way to report issues is via GitHub Issues, as it ensures transparency and allows for better tracking and collaboration. Follow the steps below:</p> <ol> <li>Navigate to the repository\u2019s Issues page.</li> <li>Click New issue and select Bug report.</li> <li>Fill out the template, providing as much detail as possible (refer to the checklist below).</li> <li>Attach relevant files, such as screenshots, logs, or minimal datasets. If your data is sensitive, consider using the email option instead.</li> </ol> <p>By using GitHub Issues, you help streamline the process and contribute to improving the project for everyone.</p> <p>If your dataset is confidential, please do not upload it publicly. Instead, strip/obfuscate sensitive parts or use the email channel.</p>"},{"location":"guide/reference/#2-via-email","title":"2) Via Email","text":"<p>In the case of private or urgent communications send an email to giovanni.castellazzi@unibo.it with subject: <code>[C2F4DT] Bug report: &lt;short description&gt;</code></p> <p>Include the same checklist information below. You may attach files or share a secure link (e.g., institutional cloud drive).</p>"},{"location":"guide/reference/#bug-report-checklist","title":"Bug Report Checklist","text":"<p>Please provide the following to help us reproduce and fix the issue quickly:</p> <ol> <li>Summary</li> <li>Short, descriptive title.</li> <li> <p>What did you expect to happen? What happened instead?</p> </li> <li> <p>Steps to Reproduce</p> </li> <li>Step-by-step instructions.</li> <li> <p>Minimal files (e.g., a small VTK demonstrating the issue).</p> </li> <li> <p>Screenshots / Videos</p> </li> <li> <p>UI state, error dialogs, wrong rendering outcomes, etc.</p> </li> <li> <p>Logs &amp; Console Output</p> </li> <li>Copy any text from the built-in Console or terminal.</li> <li> <p>If available, attach <code>_vtk_report/report.json</code> or similar validator outputs.</p> </li> <li> <p>Environment</p> </li> <li>OS (Windows/macOS/Linux + version), Python version.</li> <li>Package versions: <code>pyvista</code>, <code>vtk</code>, <code>numpy</code>, <code>matplotlib</code>, <code>scipy</code>.</li> <li> <p>GPU/driver info if rendering\u2011related.</p> </li> <li> <p>Configuration</p> </li> <li>Representation settings (Surface/Wireframe/etc.).</li> <li>Color by (Solid/PointData/CellData + vector component).</li> <li>LUT + invert, scalar bar on/off, edges visibility, opacity.</li> <li> <p>Any custom plugins or local modifications.</p> </li> <li> <p>Frequency / Regression</p> </li> <li>Does it happen always or intermittently?</li> <li>Did it appear after an update? Which version worked?</li> </ol>"},{"location":"guide/reference/#example-minimal-issue-template","title":"Example (Minimal) Issue Template","text":"<pre><code>**Summary**\nSurface with Edges hides nodes when edges are enabled.\n\n**Steps to Reproduce**\n1. File \u25b8 Import VTK\u2026 \u2192 load `demo.vtu`\n2. Representation = Surface with Edges\n3. Color by = PointData/displacement (Magnitude)\n4. Toggle Edges = ON\n\n**Observed**\nEdges are visible but nodes are white.\n\n**Expected**\nEdges and scalar-colored nodes visible together.\n\n**Environment**\n- OS: Windows 11, Python 3.11\n- pyvista 0.43.10, vtk 9.3.0, numpy 2.0.2, matplotlib 3.9.2, scipy 1.13\n- GPU: NVIDIA RTX 3070 (driver 552.xx)\n\n**Attachments**\n- `_vtk_report/rep_Surface_with_Edges.png`\n- Console log excerpt\n</code></pre>"},{"location":"guide/reference/#optional-github-issue-templates","title":"Optional: GitHub Issue Templates","text":"<p>To streamline reports, consider adding <code>.github/ISSUE_TEMPLATE/</code> files to your repo:</p> <ul> <li><code>.github/ISSUE_TEMPLATE/bug_report.md</code></li> <li><code>.github/ISSUE_TEMPLATE/feature_request.md</code></li> </ul> <p>Example <code>bug_report.md</code>:</p> <pre><code>name: Bug report\ndescription: Create a report to help us improve\nlabels: [bug]\nbody:\n  - type: textarea\n    id: summary\n    attributes:\n      label: Summary\n      description: What happened and what did you expect?\n      placeholder: Short description...\n    validations:\n      required: true\n\n  - type: textarea\n    id: repro\n    attributes:\n      label: Steps to Reproduce\n      description: Provide a minimal, complete, and verifiable example.\n      placeholder: |\n        1. Import file ...\n        2. Set representation to ...\n        3. Toggle edges ...\n    validations:\n      required: true\n\n  - type: textarea\n    id: evidence\n    attributes:\n      label: Evidence\n      description: Screenshots, logs, minimal datasets, validator output.\n    validations:\n      required: false\n\n  - type: input\n    id: env-os\n    attributes:\n      label: OS\n      placeholder: Windows 11 / macOS 14 / Ubuntu 22.04\n    validations:\n      required: true\n\n  - type: input\n    id: env-python\n    attributes:\n      label: Python\n      placeholder: 3.11.x\n    validations:\n      required: true\n\n  - type: textarea\n    id: env-packages\n    attributes:\n      label: Package Versions\n      placeholder: pyvista, vtk, numpy, matplotlib, scipy\n    validations:\n      required: true\n</code></pre>"},{"location":"guide/reference/#faq","title":"FAQ","text":"<p>Q: I found a bug while using a confidential dataset. How should I proceed? A: Prefer the email channel. Provide a minimal, anonymized extract if possible, or share access privately.</p> <p>Q: Where do I ask for new features or improvements? A: Use GitHub Issues \u2192 Feature request to track discussion and prioritization.</p> <p>Q: I\u2019m offline and cannot reach GitHub. A: Send an email to giovanni.castellazzi@unibo.it with the Bug Report Checklist filled in.</p> <p>Thank you for helping improve C2F4DT! Your clear reports save everyone time and make the tool better for the community.</p>"},{"location":"guide/theory/","title":"Theory &amp; Equations","text":""},{"location":"guide/theory/#motivation-and-significance","title":"Motivation and Significance","text":"<p>This section provides the theoretical framework underlying the Cloud2FEMi software, which aims to facilitate the conversion of point cloud data into finite element meshes. The motivation stems from the need to bridge the gap between experimental or simulated data represented as point clouds and numerical analysis tools requiring structured meshes. By automating this conversion, the software enhances the efficiency and accuracy of computational modeling workflows in engineering and scientific applications.</p>"},{"location":"guide/theory/#software-description","title":"Software Description","text":"<p>Cloud2FEMi processes 3D point cloud data to generate finite element meshes suitable for simulation. The software incorporates algorithms for voxelization, geometry reconstruction, and mesh generation. It supports various input formats and allows customization of voxel tolerance and slicing parameters to adapt to different data characteristics and modeling requirements.</p>"},{"location":"guide/theory/#workflow-and-equations-under-development","title":"Workflow and Equations (Under development)","text":"<p>The core workflow involves several key steps:</p> <ol> <li>Voxelization: The point cloud is discretized into voxels, with voxel size controlled by a tolerance parameter ( \\epsilon ). This parameter defines the maximum allowed distance between points within a voxel:</li> </ol> <p>[ \\epsilon = \\max_{i,j} | \\mathbf{p}_i - \\mathbf{p}_j |, \\quad \\mathbf{p}_i, \\mathbf{p}_j \\in \\text{voxel} ]</p> <ol> <li>Centroid Calculation and Slicing: For each voxel, the centroid ( \\mathbf{c} ) is computed to represent the voxel's position:</li> </ol> <p>[ \\mathbf{c} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{p}_i ]</p> <p>where ( N ) is the number of points in the voxel. The point cloud is then sliced along specified axes to facilitate mesh generation layers.</p> <ol> <li>Mesh Generation: Using the voxel centroids and slices, a finite element mesh is constructed. The mesh respects the geometry defined by the voxelized data and ensures element quality suitable for numerical simulations.</li> </ol> <p>These steps collectively enable the transformation from raw point cloud data to a structured mesh, ready for finite element analysis.</p>"},{"location":"guide/contribute/code_of_conduct/","title":"Code of Conduct","text":"<p>This project has adopted the Contributor Covenant Code of Conduct, version 2.1.</p>"},{"location":"guide/contribute/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone.</p>"},{"location":"guide/contribute/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment include: - Using welcoming and inclusive language - Being respectful of differing viewpoints - Gracefully accepting constructive criticism - Focusing on what is best for the community - Showing empathy towards others</p> <p>Examples of unacceptable behavior include: - Trolling, insulting/derogatory comments, and personal attacks - Public or private harassment - Publishing others\u2019 private information without explicit permission</p>"},{"location":"guide/contribute/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team.</p>"},{"location":"guide/contribute/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at: https://www.contributor-covenant.org/version/2/1/code_of_conduct/</p>"},{"location":"guide/contribute/development_workflows/","title":"Development workflows","text":""},{"location":"guide/contribute/development_workflows/#development-workflow","title":"Development Workflow","text":"<ol> <li>Create a feature branch</li> <li>Implement code with clear docstrings</li> <li>Update pages in <code>docs/guide/</code></li> <li><code>mkdocs serve</code> for local preview</li> <li>Open a PR with screenshots/gifs when helpful</li> </ol>"},{"location":"guide/contribute/development_workflows/#docstring-style-google","title":"Docstring style (Google)","text":"<pre><code>def compute_normals(points, k=16):\n    \"\"\"Compute normals for a point cloud.\n\n    Args:\n        points (ndarray): (N, 3) array of XYZ.\n        k (int): Neighborhood size.\n\n    Returns:\n        ndarray: (N, 3) array of normals.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"guide/contribute/development_workflows/#processing-workflow","title":"Processing Workflow","text":"<p>The processing workflow in Cloud2FEMi consists of the following 10 steps:</p> <ol> <li> <p>Point Cloud Import    Load the raw point cloud data (e.g., from LiDAR or photogrammetry) into the system.</p> </li> <li> <p>Slice Creation    Divide the point cloud into slices, typically along a chosen axis, to simplify further processing.</p> </li> <li> <p>Centroid Generation    Compute centroids for each slice, representing the central position of points within a slice.</p> </li> <li> <p>Polyline Generation    Connect centroids or selected points within each slice to form polylines that outline key features.</p> </li> <li> <p>Polygon Creation    Convert polylines into closed polygons to define cross-sectional shapes.</p> </li> <li> <p>Grid Generation    Generate a computational grid (mesh) within each polygon, suitable for FEM analysis.</p> </li> <li> <p>Grid Extrusion/Adaptation    Extrude or adapt the 2D grids into 3D elements, following the geometry of the original point cloud.</p> </li> <li> <p>FEM Generation    Assemble the full finite element model, assigning nodes and elements based on the extruded grid.</p> </li> <li> <p>Boundary Conditions and Export    Define boundary conditions and export the FEM model in a format ready for simulation.</p> </li> <li> <p>Visualization     Visualize the processed data and FEM model to verify geometry and mesh quality before simulation.</p> </li> </ol>"},{"location":"guide/contribute/guidelines/","title":"Contribution Guidelines","text":"<p>We welcome contributions from the community! Please follow these guidelines to ensure a smooth process.</p>"},{"location":"guide/contribute/guidelines/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Fork the Repository on GitHub.</li> <li>Create a Branch for your changes:    <pre><code>git checkout -b feature/my-new-feature\n</code></pre></li> <li>Make Changes:</li> <li>Follow PEP8 coding standards.</li> <li>Use Google-style docstrings for all functions/classes.</li> <li>Add or update tests where applicable.</li> <li> <p>Update documentation in <code>docs/</code>.</p> </li> <li> <p>Commit Changes:</p> </li> <li>Use small, focused commits with descriptive messages.</li> <li> <p>Avoid committing generated files, <code>.venv/</code>, and large datasets.</p> </li> <li> <p>Push and Open a Pull Request:    <pre><code>git push origin feature/my-new-feature\n</code></pre>    Then open a Pull Request on the main repository.</p> </li> </ol>"},{"location":"guide/contribute/guidelines/#review-process","title":"Review Process","text":"<ul> <li>A maintainer will review your PR.</li> <li>Be open to comments and requested changes.</li> <li>Once approved, your PR will be merged.</li> </ul>"},{"location":"guide/contribute/guidelines/#reporting-issues","title":"Reporting Issues","text":"<ul> <li>Use the GitHub Issues page to report bugs or request features.</li> <li>Provide context, logs, or screenshots if possible.</li> </ul>"},{"location":"guide/plugins/cloud2fem/","title":"Cloud2FEM Plugin","text":"<p>The Cloud2FEM Plugin converts point cloud slices into finite element meshes.</p> <p></p>"},{"location":"guide/plugins/cloud2fem/#features","title":"Features","text":"<ul> <li>Slicing point clouds along chosen axes.</li> <li>Centroid clustering and polyline extraction.</li> <li>Polygonization and mesh preparation.</li> <li>FEM export compatible with Julia Finetools.</li> </ul>"},{"location":"guide/plugins/cloud2fem/#usage","title":"Usage","text":"<ol> <li>Load a point cloud dataset.</li> <li>Open the Slicing Panel from the toolbar.</li> <li>Adjust options:</li> <li>Axis, thickness, spacing</li> <li>In-plane filtering</li> <li>Polygon simplification</li> <li>Generate slices \u2192 review results in 2D/3D overlays.</li> <li>Export to FEM input.</li> </ol>"},{"location":"guide/plugins/cloud2fem/#options","title":"Options","text":"<ul> <li>Slicing Modes: fixed step, fixed count, custom.</li> <li>Centroids: tolerance parameters for wall thickness &amp; clustering.</li> <li>Visualization: 3D overlay with points, centroids, and polygons.</li> <li>Export: save mesh to Finetools format.</li> </ul>"},{"location":"guide/plugins/cloud_inspection/","title":"Cloud Inspection Plugin","text":"<p>The Cloud Inspection Plugin computes descriptive metrics on loaded point clouds.</p> <p></p>"},{"location":"guide/plugins/cloud_inspection/#features","title":"Features","text":"<ul> <li>Global metrics: point count, bounding box, mean NN distance, density.</li> <li>Structural detection: horizontal planes, clustering, edge indicators.</li> <li>Per-point properties: normals, curvature, roughness, planarity, linearity.</li> <li>Visualization through the Cloud Info panel (coloring by property with colormaps).</li> <li>Report window + export to dataset tree.</li> </ul>"},{"location":"guide/plugins/cloud_inspection/#usage","title":"Usage","text":"<ol> <li>Load a point cloud dataset.</li> <li>Open the plugin from the toolbar button.</li> <li>Select the metrics to compute and click Compute.</li> <li>The results appear in:</li> <li>Dataset Tree \u2192 Inspection branch  </li> <li>Message Window \u2192 textual report  </li> <li>Cloud Info Panel \u2192 property-based coloring  </li> </ol>"},{"location":"guide/plugins/cloud_inspection/#options","title":"Options","text":"<ul> <li>Quick Test: preview computation for one metric.</li> <li>Dataset chooser: when multiple clouds are loaded.</li> <li>Color mapping: viridis, plasma, magma, inferno, jet.</li> <li>Copy report: export results to clipboard.</li> </ul>"},{"location":"guide/plugins/import_vtk/","title":"Import VTK Plugin","text":"<p>The Import VTK Plugin loads datasets in VTK/VTU format directly into the viewer.</p> <p></p>"},{"location":"guide/plugins/import_vtk/#features","title":"Features","text":"<ul> <li>Support for <code>.vtk</code> and <code>.vtu</code> files.</li> <li>Import point clouds, meshes, and unstructured grids.</li> <li>Automatic placement in the dataset tree.</li> </ul>"},{"location":"guide/plugins/import_vtk/#usage","title":"Usage","text":"<ol> <li>Click the toolbar button .</li> <li>Select one or more VTK files.</li> <li>The datasets appear in the Tree Inspector.</li> <li>Visualize and interact with the data in 3D.</li> </ol>"},{"location":"guide/plugins/import_vtk/#options","title":"Options","text":"<ul> <li>Multi-file import: load several VTK datasets in one action.</li> <li>Dataset labeling: files are shown with their filename by default.</li> <li>Compatibility: works with PyVista and VTK formats.</li> </ul>"},{"location":"guide/plugins/transformations/","title":"Transformations Plugin","text":"<p>The Transformations Plugin applies geometric transformations to loaded datasets.</p> <p></p>"},{"location":"guide/plugins/transformations/#features","title":"Features","text":"<ul> <li>Translate, rotate, and scale datasets interactively.</li> <li>Apply transformations to one or multiple datasets.</li> <li>Restore original position or reset transformations.</li> </ul>"},{"location":"guide/plugins/transformations/#usage","title":"Usage","text":"<ol> <li>Select a dataset in the tree.</li> <li>Open the plugin from the toolbar.</li> <li>Enter parameters for:</li> <li>Translation (X, Y, Z)</li> <li>Rotation (degrees around axis)</li> <li>Scale (uniform or per-axis)</li> <li>Press Apply to update the dataset in the viewer.</li> </ol>"},{"location":"guide/plugins/transformations/#options","title":"Options","text":"<ul> <li>Incremental mode: apply transformations relative to current state.</li> <li>Reset: restore to original coordinates.</li> <li>Batch mode: apply the same transformation to all selected datasets.</li> </ul>"},{"location":"guide/plugins/units/","title":"Units Plugin","text":"<p>The Units Plugin provides conversion tools and reference tables for common engineering units.</p> <p></p>"},{"location":"guide/plugins/units/#features","title":"Features","text":"<ul> <li>Quick conversion between SI and Imperial units.</li> <li>Reference values for typical structural materials.</li> <li>Inline use from the right vertical toolbar.</li> </ul>"},{"location":"guide/plugins/units/#usage","title":"Usage","text":"<ol> <li>Open the plugin via the toolbar button .</li> <li>Select the source and target units.</li> <li>Enter a value and press Convert.</li> <li>Copy the converted value into your workflow.</li> </ol>"},{"location":"guide/plugins/units/#options","title":"Options","text":"<ul> <li>Length (m, cm, mm, in, ft)</li> <li>Force (N, kN, lb)</li> <li>Stress (Pa, MPa, psi)</li> <li>Custom presets can be added via <code>plugin.yaml</code>.</li> </ul>"}]}
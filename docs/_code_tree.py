"""Generate a Markdown page with a clickable code tree (depth-limited).

This script walks the `c2f4dt` package up to a given depth and emits
`docs/guide/code_tree.md` with a nested list of folders and Python modules.

Linking policy:
- For each `*.py` file (excluding `__init__.py` and `__main__.py`), if the module
  successfully imports, we link to the corresponding Auto-API page under
  `docs/api/<module>.md` (generated by `docs/_autoapi.py`).
- If import fails, we still show the file name as code, without a link.

Depth policy:
- Set `MAX_DEPTH >= 0` to limit the directory depth (0 == only top level).
- Set `MAX_DEPTH < 0` for **unlimited depth**.
"""
from __future__ import annotations

import importlib
import os
import pathlib
from typing import Iterable

import mkdocs_gen_files

ROOT = pathlib.Path(__file__).resolve().parents[1]
PKG_NAME = "c2f4dt"
PKG_ROOT = ROOT / PKG_NAME
OUTPUT_MD = pathlib.Path(ROOT, "docs/guide") / "code_tree.md"

# Depth limit: set to a non-negative integer to limit; negative => unlimited
MAX_DEPTH = 4  # e.g. behaves like `tree -L 4`; use -1 for unlimited


def _module_name_for(py_path: pathlib.Path) -> str | None:
    """Return dotted module name for a Python file, or ``None`` for dunders.
    Example: c2f4dt/io/pcl.py -> "c2f4dt.io.pcl"
    Excludes: __init__.py and __main__.py
    """
    if py_path.name in {"__init__.py", "__main__.py"}:
        return None
    rel = py_path.relative_to(PKG_ROOT).with_suffix("")
    dotted = ".".join(rel.parts)
    return f"{PKG_NAME}.{dotted}"


def _is_hidden(name: str) -> bool:
    return name.startswith(".") or name == "__pycache__"


def _iter_dir(path: pathlib.Path) -> Iterable[pathlib.Path]:
    try:
        with os.scandir(path) as it:
            # Sort: dirs first, then files; both lexicographically
            for entry in sorted(it, key=lambda e: (not e.is_dir(), e.name.lower())):
                if _is_hidden(entry.name):
                    continue
                yield pathlib.Path(entry.path)
    except FileNotFoundError:
        return


def _write_tree(fd, base: pathlib.Path, depth: int = 0) -> None:
    # Respect depth policy: negative MAX_DEPTH => unlimited
    if MAX_DEPTH >= 0 and depth > MAX_DEPTH:
        return

    for p in _iter_dir(base):
        indent = "  " * 2 * depth
        if p.is_dir():
            fd.write(f"{indent}- **{p.name}/**\n")
            _write_tree(fd, p, depth + 1)
        elif p.suffix == ".py":
            mod = _module_name_for(p)
            if not mod:
                fd.write(f"{indent}- `{p.name}`\n")
                continue

            # Try importing to decide if we can link to Auto-API page
            link = None
            try:
                importlib.import_module(mod)
                link = f"../api/{mod}.md"
            except Exception:
                link = None

            if link:
                fd.write(f"{indent}- [{p.name}]({link})\n")
            else:
                fd.write(f"{indent}- `{p.name}`\n")


with mkdocs_gen_files.open(OUTPUT_MD, "w") as fd:
    fd.write("# Code Tree\n\n")
    fd.write(
        "This page shows a depth-limited, clickable tree of the `c2f4dt` package.\n"
        "Links point to corresponding API pages generated at build time.\n\n"
    )
    depth_note = (
        f"**Root:** `{PKG_NAME}/` — depth ≤ {MAX_DEPTH} (negative means unlimited)\n\n"
        if MAX_DEPTH >= 0 else f"**Root:** `{PKG_NAME}/` — depth: unlimited\n\n"
    )
    fd.write(depth_note)
    _write_tree(fd, PKG_ROOT, depth=0)
